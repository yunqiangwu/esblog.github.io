<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title></title>
      <link href="/pub/0/"/>
      <url>/pub/0/</url>
      <content type="html"><![CDATA[<h1 id="自然语言理解"><a href="#自然语言理解" class="headerlink" title="自然语言理解"></a>自然语言理解</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>什么是NLU？怎样才算理解了语言？</p><p>自然语言理解，也就是人或机器理解人类语言，有两种不同定义：一种<strong>基于表征</strong>，另一种<strong>基于行为</strong>。<br>基于表征（representation），就是系统根据输入的语言产生相应的内部表征，这个过程也称为语义<br>接地（semantic grounding）。比如，有人说「哈利波特」，在大脑里联系到哈利波特的概念就意<br>味着理解了对方的语言。基于行为，就是系统根据输入的语言采取相应的动作。比如，有人说「给我<br>拿一杯茶」，机器人按照命令做了，就认为它理解了人的语言。这两个定义在一定程度上互为补充，<br>前者从语义角度，后者从语用角度界定这个问题。</p>]]></content>
      
      
    </entry>
    
    <entry>
      <title></title>
      <link href="/pub/0/"/>
      <url>/pub/0/</url>
      <content type="html"><![CDATA[]]></content>
      
      
    </entry>
    
    <entry>
      <title>【机器翻译】- 资源集合</title>
      <link href="/pub/178d9d40/"/>
      <url>/pub/178d9d40/</url>
      <content type="html"><![CDATA[<h1 id="codes-常用深度学习工具包"><a href="#codes-常用深度学习工具包" class="headerlink" title="codes [常用深度学习工具包]"></a>codes [常用深度学习工具包]</h1><ul><li>pytorch <a href="http://pytorch.org/tutorials/intermediate/seq2seq_translation_tutorial.html" target="_blank" rel="noopener">seq2seq_translation</a></li><li><a href="">tensorflow tutorial</a></li><li><a href="">tensor2tensor</a></li><li><a href="http://opennmt.net/" target="_blank" rel="noopener">OpenNMT - 支持tf和pytorch</a></li></ul><h1 id="公开数据集"><a href="#公开数据集" class="headerlink" title="公开数据集"></a>公开数据集</h1><h1 id="开源社区、toolbox"><a href="#开源社区、toolbox" class="headerlink" title="开源社区、toolbox"></a>开源社区、toolbox</h1><p>汇总</p><ul><li>Giza++ a training tool for IBM Model 1-5 (version for gcc-4) , and extension of Giza</li><li>MGiza++是在Giza++基础上扩充的一中多线程Giza++工具</li><li>Pgiza++是运行在分布式机器上的Giza++工具，使用了MapReduce技术的框架</li><li>Moses, a complete SMT system</li><li>UCAM-SMT, the Cambridge Statistical Machine Translation system</li><li>Phrasal, a toolkit for phrase-based SMT</li><li>cdec, a decoder for syntax-based SMT * Joshua, a decoder for syntax-based SMT</li><li>Jane, decoder for syntax-based SMT</li><li>Pharaoh a decoder for phrase-based SMT</li><li>Rewrite a decoder for IBM Model 4</li><li>BLEU scoring tool for machine translation evaluation</li></ul><ul><li>Egypt<br><br>Egypt是在1999年约翰霍普金斯大学统计机器翻译夏季讨论班上，由一些研究人员共同合作开发的统计机器翻译工具包。它包括4个模块：<br>Whittle：语料库预处理模块；<br>GIZA：用于从句子对齐的双语语料库中训练词语对齐；<br>Cairo：词语对齐的可视化工具<br>Decoder：解码器，即用来执行具体的翻译过程模块，这一模块没有开放源码。</li><li>SRILM<br><br>SRILM是一个建立和使用统计语言模型的开源工具包，从1995年开始由SRI 口语技术与研究实验室（SRI Speech Technology and Research Laboratory）开发，现在仍然不断推出新版本，被广泛应用于语音识别、机器翻译等领域。这个工具包包含一组C++类库、一组进行语言模型训练和应用的可执行程序等。利用它可以非常方便地训练和应用语言模型。</li><li>法老（Pharaoh）系统<br><br>“法老”是较早公开的统计机器翻译系统，是由美国南加州大学信息科学实验室（Information Science Institute）的菲利普.科恩（Philipp Koehn）在2004年做博士论文期间编写的。可能由于较早的开源软件以“埃及（Egypt）”命名的缘故吧，这一系统也采用埃及的代表性事物“法老（Pharaoh）”命名。它是一个基于短语的（Phrased-based）统计机器翻译系统。。它利用了已有的开源软件GIZA++和SRILM，GIZA++用来训练词语对齐，SRILM训练语言模型。既然是以短语作为翻译的基本单元，因此还需要获得关于短语翻译的知识。通过前面的介绍我们知道通过GIZA++训练可以得到单词对齐，根据单词对齐我们可以进行短语抽取。</li><li><strong>Moses</strong><br><br>当今最有名的开源统计机器翻译系统。绝大多数的统计机器翻译技术在Moses中都有支持，比如基于短语的模型、基于句法的模型、各种解码方法、各种特征权重训练方法。概括一下：历史悠久（相对），技术全面，性能出色，论文的baseline。<br>“摩西”是“法老”的升级版本，增加了许多功能。它是由英国爱丁堡大学、德国亚琛工业大学等8家单位联合开发的一个基于短语的统计机器翻译系统。来自这8家单位的研究人员于2006年在约翰霍普金斯大学召开了一次研讨会，利用6个星期的时间共同开发了这一系统。整个系统用C++语言写成，从训练到解码完全开放源代码，可以运行在Windows平台和Linux平台。<br><br>相比于“法老”，“摩西”主要有如下几个新的特性：<br>a.使用要素翻译模型（Factored Translation Model）<br>b.混合网络解码（Confusion Network Decoding）<br><br>现在的Moses系统极其复杂，代码阅读起来是比较吃力的。如果是想学习统计机器翻译技术，我倒是觉得Joshua和NiuTrans是不错的选择。</li><li><a href="http://www.nlp.org.cn/project/project.php?projid=14" target="_blank" rel="noopener">SilkRoad</a> 丝路<br><br>中国第一个开源的统计机器翻译系统，“法老”的出现揭开了统计机器翻译的神秘面纱，然而其核心部分解码器的源码仍然没有公开。为此，中国的研究人员联合开发了一个完全开放源代码的统计机器翻译系统“丝路”。该系统由中国的五家研究机构和高校（中科院计算所、中科院自动化所、中科院软件所、厦门大学、哈尔滨工业大学）联合开发，并在2006年中国第二届统计机器翻译研讨会[14]上发布。“丝路”包括以下模块：语料预处理及后处理模块“仙人掌”、词语对齐模块“楼兰”、短语抽取模块“胡杨”、以及三个解码器（“骆驼”、“绿洲”和“商队”）。<br><br>后期的更新和维护没有跟上，现在使用的似乎不是非常多。</li><li><a href="http://www.nlplab.com/NiuPlan/NiuTrans.html" target="_blank" rel="noopener">NiuTrans</a><br><br>NiuTrans的特点是国人开发，性能稳定，翻译模型支持全面，NiuTrans团队对系统进行不断升级。<br>从全世界范围来看，现在机器翻译的开源工具不下30个。还有其它的系统，比如Akamon等，还有比较相关的如GIZA++，SRILM等，但是这里就不详细介绍了。</li></ul><h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><div class="table-container"><table><thead><tr><th style="text-align:left">模型</th><th style="text-align:right">paper</th><th style="text-align:right">year + 会议</th><th style="text-align:right">简介</th><th style="text-align:right">创新点</th><th style="text-align:center">缺陷</th><th>code</th></tr></thead><tbody><tr><td style="text-align:left">基于短语的翻译（PBMT）</td><td style="text-align:right"></td><td style="text-align:right">IBM 1989</td><td style="text-align:right">模型超复杂</td></tr><tr><td style="text-align:left"></td><td style="text-align:right">Sequence to Sequence Learning with Neural Networks</td><td style="text-align:right">NIPS 2014</td><td style="text-align:right"></td><td style="text-align:right"></td><td style="text-align:center"></td><td><a href="https://www.tensorflow.org/tutorials/seq2seq" target="_blank" rel="noopener">tensorflow</a></td></tr><tr><td style="text-align:left"></td><td style="text-align:right">Learning Phrase Representations using RNN Encoder-Decoder for SMT</td><td style="text-align:right">EMNLP2014</td></tr><tr><td style="text-align:left"></td><td style="text-align:right">Effective Approaches to Attention-based Neural Machine Translation</td><td style="text-align:right">EMNLP 2015</td><td style="text-align:right">基于高斯分布推导了Local Attention,比较了Global Align Attention和Local Align Attention， 和视频处理里面 Soft Attention 和 Hard Attention建立了联系。</td><td style="text-align:right"></td><td style="text-align:center"></td><td><a href="https://nlp.stanford.edu/projects/nmt/" target="_blank" rel="noopener">code</a></td></tr><tr><td style="text-align:left"></td><td style="text-align:right">Neural machine translation by jointly learning to align and translate</td><td style="text-align:right">ICLR 2015</td><td style="text-align:right">RNN+attention</td><td style="text-align:right">首次加入attention，ALIGN AND TRANSLATE</td></tr><tr><td style="text-align:left">GNMT</td><td style="text-align:right">Google’s Neural Machine Translation System: Bridging the Gap between Human and Machine Translation</td><td style="text-align:right">2016</td><td style="text-align:right">deep_LSTM, residual, attention, converage，subword</td></tr></tbody></table></div><ul><li>宗成庆：《自然语言理解》<br>-</li></ul><h1 id="必看"><a href="#必看" class="headerlink" title="必看"></a>必看</h1><ul><li><a href="http://mp.weixin.qq.com/s?__biz=MzA3MzI4MjgzMw==&amp;mid=2650719470&amp;idx=1&amp;sn=3368dea980517ea7d7942967da2740dc&amp;chksm=871b0090b06c89863620be4e75c757940d03d8a43cd3c1d9a8309b6594c1bccd769cab193177&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">GNMT | 谷歌2016</a> —- <a href="https://github.com/tensorflow/nmt" target="_blank" rel="noopener">官方code</a></li><li><a href="http://mp.weixin.qq.com/s?__biz=MzA3MzI4MjgzMw==&amp;mid=2650720536&amp;idx=2&amp;sn=1617ed96796bba31f4d6c6749b7579db&amp;chksm=871b0d66b06c8470e86bf243fab1b7710dd8b222ecbfa99d5ac61dac07694542e6d4b6846db8&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">Multilingual-NMT 实现多语言翻译和zero-shot翻译| Google 2016</a></li><li><a href="http://mp.weixin.qq.com/s?__biz=MzA3MzI4MjgzMw==&amp;mid=2650726462&amp;idx=1&amp;sn=144e68df0057ac69002e3927073fc540&amp;chksm=871b2440b06cad565eb98857d057cf8dbb6cbde7786da2ffb676ae76c6246090640591e76572&amp;mpshare=1&amp;scene=23&amp;srcid=0510r21f1gUKWuv7YaLlLLmF##" target="_blank" rel="noopener">conv-seq2seq 利用多跳注意（multi-hop attention）和门控（gating）来改善翻译效果| Facebook 2017</a></li><li><a href="..">Attention Is All You Need 不用CNN和RNN| Google 2017</a></li><li><a href="https://new.qq.com/omn/20180317/20180317A11P6X.html" target="_blank" rel="noopener">Achieving Human Parity on Automatic Chinese to English News Translation | 微软2018</a></li></ul>]]></content>
      
      <categories>
          
          <category> -machine translation </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>基于规则的机器翻译</title>
      <link href="/pub/c6347fef/"/>
      <url>/pub/c6347fef/</url>
      <content type="html"><![CDATA[<h2 id="基于规则的机器翻译"><a href="#基于规则的机器翻译" class="headerlink" title="基于规则的机器翻译"></a>基于规则的机器翻译</h2><p>基于规则的翻译过程分成6个步骤：<br>(a) 对源语言句子进行<code>词法分析</code><br>(b) 对源语言句子进行<code>句法/语义分析</code><br>(c) 源语言<code>句子结构</code>到译文结构的转换<br>(d) 译文<code>句法结构</code>生成<br>(e) 源语言词汇到译文<code>词汇</code>的转换<br>(f) 译文词法选择与生成</p>]]></content>
      
      <categories>
          
          <category> -machine translation </category>
          
          <category> 2. 主流model-研究现状 </category>
          
          <category> 0. 基于规则的机器翻译 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>【机器翻译】- 面临的挑战</title>
      <link href="/pub/43028def/"/>
      <url>/pub/43028def/</url>
      <content type="html"><![CDATA[<h1 id="面临的挑战"><a href="#面临的挑战" class="headerlink" title="面临的挑战"></a>面临的挑战</h1><h2 id="NLP常见的问题"><a href="#NLP常见的问题" class="headerlink" title="NLP常见的问题"></a>NLP常见的问题</h2><p>见trick-NLP</p><h2 id="机器翻译独有的问题"><a href="#机器翻译独有的问题" class="headerlink" title="机器翻译独有的问题"></a>机器翻译独有的问题</h2><h2 id="歧义"><a href="#歧义" class="headerlink" title="歧义"></a>歧义</h2><p>自然语言中普遍存在的歧义和未知现象</p><ul><li>句法结构歧义/词汇歧义/语用歧义 …</li><li>新的词汇、术语、结构、语义</li></ul><p>机器翻译不仅仅是字符串的转换<br>不同语言之间文化的差异<br>现有方法无法表示和利用世界知识和常识</p><p><strong>bad case</strong></p><h2 id="未登录词-OOV-的影响以及策略"><a href="#未登录词-OOV-的影响以及策略" class="headerlink" title="未登录词(OOV)的影响以及策略"></a>未登录词(OOV)的影响以及策略</h2><p>NMT 系统为了能够控制计算的复杂度，有<br>着一个固定大小的词汇表，通常会将词汇表限制在 30k 到 80k 之间，这就导致了其在翻译未登录词时有着严重的不足。</p><p>对于未出现在该词汇表中的词，NMT系统用 UNK 标记来替代。结果，NMT 系统不仅无法将它们翻译准确，而且<strong>破坏了句子的结构特征</strong>。</p><p><strong>策略</strong></p><h2 id="长距离依赖"><a href="#长距离依赖" class="headerlink" title="长距离依赖"></a>长距离依赖</h2><p> 神经机器翻译有两个关键技术，一个是 gating，另外还有一个是 attention，这两个特别适合处理语言中长距离调序，生成的译文要比传统的方式生成的译文流利很多。</p><h2 id="同步翻译-实时翻译"><a href="#同步翻译-实时翻译" class="headerlink" title="同步翻译/实时翻译"></a>同步翻译/实时翻译</h2><p> Learning to Translate in Real-time with Neural Machine Translation</p><h2 id="多语种"><a href="#多语种" class="headerlink" title="多语种"></a>多语种</h2><h2 id="机器翻译的解不唯一，而且始终存在的人为的标准"><a href="#机器翻译的解不唯一，而且始终存在的人为的标准" class="headerlink" title="机器翻译的解不唯一，而且始终存在的人为的标准"></a>机器翻译的解不唯一，而且始终存在的人为的标准</h2><h2 id="机器翻译不仅仅是字符串的转换"><a href="#机器翻译不仅仅是字符串的转换" class="headerlink" title="机器翻译不仅仅是字符串的转换"></a>机器翻译不仅仅是字符串的转换</h2><ul><li>不同语言之间文化的差异</li><li>现有方法无法表示和利用世界知识和常识</li></ul><p>翻译诗歌、散文和小说等高难度文艺作品</p><p>食品或菜单名的翻译：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">|馒头:  steamed bread |  Steamed bun |</span><br><span class="line">| 夫妻肺片 | Husband and wife’s lung slices | Fuqifeipian/ Spicy beef |</span><br><span class="line">| 童子鸡 | Young lad chicken | Spring chicken/ Broiler chicken |</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">2011年，中国日报，翻译效果</span><br><span class="line">原文：WASHINGTON - China and the United States have far more shared interests than differences, and nothing can hold back the momentum of cooperation, Vice-Premier Wang Qishan said on Monday. He made the remark at the opening of the third round of the China-US Strategic &amp; Economic Dialogue in the US capital.</span><br><span class="line">google翻译：华盛顿－中国和美国有更多的共同利益大于分歧，没有什么能阻挡历史的合作势头，国务院副总理王岐山周一表示。 他在中国的中美战略与经济对话在美国首都第三轮开幕时作上述表示。</span><br><span class="line">SYSTRAN：华盛顿-中国和美国比区别有分享兴趣，并且什么都不能阻止合作的动量，在星期一，Wang Qishan 副总理说。 他发表了这个评论在中美战略&amp;经济对话的第三个回合的开头在美国首都。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">原文：Beijing made a third solemn representation to Manila and warned that it is hard to be optimistic about a territorial impasse over an island. Authorities say they have prepared for any escalation of the situation by Manila.</span><br><span class="line">Google Translator (2012.5.8)： 北京提出了第三次严正交涉，马尼拉，并警告说，这是大约一个多岛屿的领土僵局难以乐观。当局说，他们已经准备为任何升级的情况下由马尼拉。</span><br><span class="line">Google Translator 2013.5.7：北京做了第三马尼拉严正交涉，并警告说，这是很难被看好在一个小岛的领土僵局。当局说，他们已经准备任何马尼拉局势升级。</span><br><span class="line">SYSTRAN (2012.5.8)：北京交涉第三庄严的向马尼拉并且警告是乐观对在海岛的一个领土僵局是难。 当局说他们为这个情况的所有逐步升级做准备由马尼拉。</span><br></pre></td></tr></table></figure><h2 id="评价标准"><a href="#评价标准" class="headerlink" title="评价标准"></a>评价标准</h2><p>机器翻译的解不唯一，而且始终存在的人为的标准</p>]]></content>
      
      <categories>
          
          <category> -machine translation </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>【机器翻译】- 发展史</title>
      <link href="/pub/c874b3c5/"/>
      <url>/pub/c874b3c5/</url>
      <content type="html"><![CDATA[<h1 id="机器翻译历史"><a href="#机器翻译历史" class="headerlink" title="机器翻译历史"></a>机器翻译历史</h1><ul><li>直接转换法<ul><li>从源语言句子的表层出发，将单词、短语或句子直接置换成目标语言译文，必要时进行简单的词序调整。对原文句子的分析仅满足于特定译文生成的需要。这类翻译系统一般针对某一个特定的语言对，将分析与生成、语言数据、文法和规则与程序等都融合在一起。例如：I like Mary. —&gt; Me(I) gusta(like) Maria(Mary).<br>X like Y —&gt; Y X gusta</li></ul></li><li>基于规则的机器翻译(Rule-based)<ul><li>对源语言和目标语言均进行适当描述、把翻译机制与语法分开、用规则描述语法的实现思想</li><li>1954年 Georgetown 大学在 IBM 协助下，用IBM-701计算机实现了世界上第一个 MT 系统，实现俄译英翻译，1954年1月该系统在纽约公开演示。系统只有250条俄语词汇，6 条语法规则，可以翻译简单的俄语句子。</li></ul></li><li>统计机器翻译 SMT(-2016)：<ul><li>1990年，IBM 提出统计机器翻译模型，机器翻译研究进入了一个空前辉煌的繁荣时期。</li></ul></li><li>神经机器翻译 NMT(2016-):<ul><li>优点：翻译更加顺畅；不需要去存储短语表，而是有着一个小规模的词汇表，这大大减小了计算的复杂度。</li><li>缺点：为了能够控制计算的复杂度，有着一个固定大小的词汇表，通常会将词汇表限制在 30k 到 80k 之间，这就导致了其在翻译未登录词时有着严重的不足</li></ul></li></ul><h2 id="主流架构"><a href="#主流架构" class="headerlink" title="主流架构"></a>主流架构</h2><ul><li>基于规则的机器翻译</li><li>统计机器翻译 SMT：</li><li>神经机器翻译 NMT<ul><li>优点：翻译更加顺畅；不需要去存储短语表，而是有着一个小规模的词汇表，这大大减小了计算的复杂度。</li><li>缺点：为了能够控制计算的复杂度，有着一个固定大小的词汇表，通常会将词汇表限制在 30k 到 80k 之间，这就导致了其在翻译未登录词时有着严重的不足。</li></ul></li></ul><p>我们首先要了解一下基于短语的系统的工作原理。<br>基于短语的方法是目前比较成熟的统计机器翻译技术，它的主要思想是以短语作为翻译的基本单元。给定一个源语言句子，其翻译过程如下：<br>a． 对源语言句子进行短语划分；<br>b． 根据翻译模型翻译每个短语；<br>c． 对短语进行重排序。</p><h1 id="Facebook总结的很好"><a href="#Facebook总结的很好" class="headerlink" title="Facebook总结的很好"></a>Facebook总结的很好</h1><p>顺便介绍一下CNN缺陷，RNN缺陷</p><ul><li><strong>Convolutional Neural Networks (CNN)</strong><ul><li><a href="https://arxiv.org/abs/1612.08083" target="_blank" rel="noopener">Dauphin et al. (2017): Language Modeling with Gated Convolutional Networks</a></li><li><a href="https://arxiv.org/abs/1705.03122" target="_blank" rel="noopener">Gehring et al. (2017): Convolutional Sequence to Sequence Learning</a></li><li><strong><em>New</em></strong> <a href="https://arxiv.org/abs/1711.04956" target="_blank" rel="noopener">Edunov et al. (2018): Classical Structured Prediction Losses for Sequence to Sequence Learning</a></li><li><strong><em>New</em></strong> <a href="https://arxiv.org/abs/1805.04833" target="_blank" rel="noopener">Fan et al. (2018): Hierarchical Neural Story Generation</a></li></ul></li><li><strong>Long Short-Term Memory (LSTM) networks</strong><ul><li><a href="https://arxiv.org/abs/1508.04025" target="_blank" rel="noopener">Luong et al. (2015): Effective Approaches to Attention-based Neural Machine Translation</a></li><li><a href="https://arxiv.org/abs/1606.02960" target="_blank" rel="noopener">Wiseman and Rush (2016): Sequence-to-Sequence Learning as Beam-Search Optimization</a></li></ul></li><li><strong>Transformer (self-attention) networks</strong><ul><li><a href="https://arxiv.org/abs/1706.03762" target="_blank" rel="noopener">Vaswani et al. (2017): Attention Is All You Need</a></li><li><strong><em>New</em></strong> <a href="https://arxiv.org/abs/1806.00187" target="_blank" rel="noopener">Ott et al. (2018): Scaling Neural Machine Translation</a></li></ul></li></ul><h2 id="context很重要"><a href="#context很重要" class="headerlink" title="context很重要"></a>context很重要</h2><p>上下文很重要，比如以下这句话：</p><p>“I arrived at the bank after crossing the…” 要知道bank的意思，最后一个词是“road”还是“river”很重要。</p><h3 id="RNN"><a href="#RNN" class="headerlink" title="RNN"></a>RNN</h3><p><strong>优点</strong>：</p><p>-</p><ul><li><strong>长依赖</strong>: RNN的成功引入， 解决了长距离依赖的问题， 而且引入了上下文和记忆的概念。</li><li><strong>LSTM</strong>: 相对传统RNN</li></ul><p><strong>缺点</strong>：</p><ul><li>非线性数目：<!--  --></li><li><strong>编码能力弱</strong>: 没有attention的RNN，对长序列编码能力较弱</li><li><strong>难并行</strong>：training阶段RNN很难并行</li><li><strong>决策步骤太长</strong>: RNN需要一个个地读取bank到river之间的所有单词，才能够确定bank的实际意义。<!-- the more such steps decisions require, the harder it is for a recurrent network to learn how to make those decisions。--></li></ul><p>另外，由于RNN是时序处理，在GPU上<strong>不易并行化</strong>。</p><p>这两点说的太好了，赞，赞。</p><h3 id="CNN"><a href="#CNN" class="headerlink" title="CNN"></a>CNN</h3><p><strong>优点</strong>:</p><ul><li><strong>易并行</strong>：CNN的计算不存在序列依赖问题，training时容易并行化<!-- 1. Compared to recurrent models, computations over all elements can be fully parallelized during training。 2. CNN do not depend on the computations of the previous time step.--></li><li><strong>易优化</strong>：CNN的非线性单元的数目固定，容易优化。而RNN的非线性单元随序列长度变化<!-- 1. optimization is easier since the number of non-linearities is fixed and independent of the input length 2. Fixing the number of nonlinearities applied to the inputs also eases learning --></li><li><strong>依赖路径更短</strong>: 对于距离为n的长依赖，RNN的复杂度是O(n), CNN的复杂度是O(n/k)，k是kernel width</li><li>gated linear units<!-- gated linear units eases gradient propagation --></li></ul><p><strong>缺点</strong>：<br>-<br><!-- the number of steps required to combineinformation from distant parts of the input still grows with increasing distance. 没看懂 --><br>-</p><p><strong>其他</strong></p><ul><li>long-dependency问题：<br><br>LSTM引以为豪的是long-dependency较好。实际上CNN也可以通过堆叠CNN层来增大感受野，实现long-dependency。</li></ul><!--1. Compared to recurrent layers, convolutions create representations for fixed size contexts, however, the effective context size of the network can easily be made larger by stacking several layers on top of each other.2. nearby input elements interact at lower layers while distant elements interact at higher layers.--><p><br>或者dilated convolutions<br>-</p><h3 id="通用trick"><a href="#通用trick" class="headerlink" title="通用trick"></a>通用trick</h3><ul><li>gated linear units</li><li>residual connections</li></ul><h2 id="模型汇总"><a href="#模型汇总" class="headerlink" title="模型汇总"></a>模型汇总</h2><div class="table-container"><table><thead><tr><th>模型</th><th style="text-align:right">paper</th><th style="text-align:right">出处</th><th style="text-align:right">简介</th><th style="text-align:right">创新点</th><th style="text-align:center">缺陷</th><th>code</th></tr></thead><tbody><tr><td>基于规则的翻译</td><td style="text-align:right"></td><td style="text-align:right"></td><td style="text-align:right"></td><td style="text-align:right"></td><td style="text-align:center"></td><td></td></tr><tr><td>基于短语的翻译（PBMT）</td><td style="text-align:right"></td><td style="text-align:right">IBM 1989</td><td style="text-align:right">较复杂</td><td style="text-align:right"></td><td style="text-align:center"></td><td></td></tr><tr><td>seq2seq-RNN</td><td style="text-align:right"><a href="https://arxiv.org/abs/1409.3215" target="_blank" rel="noopener">Seq2seq Learning with NN</a></td><td style="text-align:right">NIPS 2014</td><td style="text-align:right"></td><td style="text-align:right"></td><td style="text-align:center"></td><td><a href="https://www.tensorflow.org/tutorials/seq2seq" target="_blank" rel="noopener">code</a></td></tr><tr><td>seq2seq-RNN</td><td style="text-align:right"><a href="https://arxiv.org/abs/1406.1078" target="_blank" rel="noopener">Learning Phrase Representations using RNN Encoder-Decoder for SMT</a></td><td style="text-align:right">EMNLP2014</td><td style="text-align:right"></td><td style="text-align:right"></td><td style="text-align:center"></td><td></td></tr><tr><td>☆seq2seq-RNN+attention</td><td style="text-align:right"><a href="">Effective Approaches to Attention-based NMT</a></td><td style="text-align:right">EMNLP 2015</td><td style="text-align:right">基于高斯分布推导了Local Attention,比较了Global Align Attention和Local Align Attention， 和视频处理里面 Soft Attention 和 Hard Attention建立了联系。</td><td style="text-align:right"></td><td style="text-align:center"></td><td><a href="https://nlp.stanford.edu/projects/nmt/" target="_blank" rel="noopener">code</a></td></tr><tr><td>seq2seq-attention</td><td style="text-align:right">Neural machine translation by jointly learning to align and translate</td><td style="text-align:right">ICLR 2015</td><td style="text-align:right">RNN+attention</td><td style="text-align:right">首次加入attention，ALIGN AND TRANSLATE</td><td style="text-align:center"></td><td></td></tr><tr><td></td><td style="text-align:right">On using very large target vocabulary for neural machine translation</td><td style="text-align:right">2015</td><td style="text-align:right">提出词表扩大的方法</td><td style="text-align:right"></td><td style="text-align:center"></td><td></td></tr><tr><td>☆GNMT</td><td style="text-align:right">Google’s Neural Machine Translation System: Bridging the Gap between Human and Machine Translation</td><td style="text-align:right">Google 2016</td><td style="text-align:right">deep_LSTM, residual, attention, converage，subword</td><td style="text-align:right"></td><td style="text-align:center"></td><td></td></tr><tr><td>BPE</td><td style="text-align:right">Neural Machine Translation of Rare Words with Subword Units</td><td style="text-align:right">2016</td><td style="text-align:right"></td><td style="text-align:right"></td><td style="text-align:center"></td><td><a href="https://github.com/rsennrich/subword-nmt" target="_blank" rel="noopener">code-Sennrich</a></td></tr><tr><td></td><td style="text-align:right">Character Based Neural Machine Translation</td><td style="text-align:right">2016</td><td style="text-align:right"></td><td style="text-align:right"></td><td style="text-align:center"></td><td></td></tr><tr><td></td><td style="text-align:right">Achieving open vocabulary neural machine translation with hybrid word-character models</td><td style="text-align:right">2016</td><td style="text-align:right"></td><td style="text-align:right"></td><td style="text-align:center"></td><td></td></tr><tr><td>☆ConvSeq2seq</td><td style="text-align:right"><a href="https://arxiv.org/abs/1611.02344" target="_blank" rel="noopener">paper1</a>; <a href="https://arxiv.org/abs/1705.03122" target="_blank" rel="noopener">paper2</a></td><td style="text-align:right">Facebook 2016</td><td style="text-align:right"></td><td style="text-align:right"></td><td style="text-align:center"></td><td><a href="https://github.com/facebookresearch/fairseq" target="_blank" rel="noopener">code1</a>;</td></tr><tr><td>☆Transformer</td><td style="text-align:right"><a href="">Attention is all you need</a></td><td style="text-align:right">Google 2017</td><td style="text-align:right"></td><td style="text-align:right"></td><td style="text-align:center"></td><td><a href="https://github.com/tensorflow/tensor2tensor/tree/master/tensor2tensor" target="_blank" rel="noopener">G-tf</a></td></tr><tr><td></td><td style="text-align:right"></td><td style="text-align:right"></td><td style="text-align:right"></td><td style="text-align:right"></td><td style="text-align:center"></td></tr></tbody></table></div><!--- Depthwise Separable Convolutions for Neural Machine Translation- Modeling Coverage for Neural Machine Translation. 解决机器翻译中“过度翻译”和“漏翻译”的问题；- Neural Machine Translation in Linear Time- Interactive Attention for Neural Machine Translation-Visualizing and Understanding Neural Models in NLP--><h2 id="SMT时代"><a href="#SMT时代" class="headerlink" title="SMT时代"></a>SMT时代</h2><ul><li>1978年欧共体启动多语言机器翻译计划； 11.1.2 机器翻译的产生与发展</li><li>1982 ~ 1986，日本在提出第五代机的同时，研究日英双向机器翻译系统 Mu 和亚洲多语言机器翻译（日语、汉语、印尼语、马来西亚语、泰国语）；</li><li>1990年，IBM 提出统计机器翻译模型，机器翻译研究进入了一个空前辉煌的繁荣时期。</li></ul><h2 id="NMT时代"><a href="#NMT时代" class="headerlink" title="NMT时代"></a>NMT时代</h2><ul><li>2005年，Google基于统计方法的翻译系统全面超过基于规则方法的SysTran翻译系统。基于规则方法固守的最后一个堡垒被拔掉了。</li><li>2016 <a href="">GNMT</a></li><li>facebook FAIR在上个月刚祭出state of the art的convseq2seq</li><li>谷歌全attention机器翻译模型Transformer, WMT en-de和en-fr都刷<br>到了新的state of the art，而且这次不用RNN，不用CNN，只有attention</li></ul>]]></content>
      
      <categories>
          
          <category> -machine translation </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>【Docker系列】Docker的存储</title>
      <link href="/pub/bb3d8549/"/>
      <url>/pub/bb3d8549/</url>
      <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p><a href="https://docs.docker.com/storage/storagedriver/" target="_blank" rel="noopener">https://docs.docker.com/storage/storagedriver/</a></p><p>每个Docker镜像（Image）都引用了一些只读的（read-only）层（layer），不同的文件系统layer也不同。这些layer堆叠在一起构成了容器（Container）的根文件系统（root filesystem）。</p><p>当你基于Ubuntu 创建一个新的容器的时候，你其实只是在它的上层又增加了一个新的、薄的、可写层。这个新增的可写层称为容器层（container layer）。当这个新的容器运行时，所有的改动（比如创建新文件、修改已有文件、删除文件等）都会写到这一层。</p><h2 id="存储-镜像层-Layers"><a href="#存储-镜像层-Layers" class="headerlink" title="存储 - 镜像层(Layers)"></a>存储 - 镜像层(Layers)</h2><p>镜像层依赖于一系列的底层技术，比如文件系统(filesystems)、写时复制(copy-on-write)、联合挂载(union mounts)等</p><p><img alt="docker的镜像分层技术" title="docker的镜像分层技术" src="/images/raw/Cloud - docker - image layer.jpg"></p><p>容器层是可写层。</p><p>例如：<br><code>docker history  tensorflow/tensorflow:1.8.0-gpu</code></p><p><img alt="tensorflow的镜像分层" title="tensorflow的镜像分层" src="/images/raw/Cloud - docker - image layer - tensorflow.png"></p><ul><li><a href="https://github.com/tensorflow/tensorflow/blob/master/tensorflow/tools/docker/Dockerfile.gpu" target="_blank" rel="noopener">tensorflow镜像</a></li><li><a href="https://gitlab.com/nvidia/cuda/blob/ubuntu16.04/9.0/base/Dockerfile" target="_blank" rel="noopener">nvidia-cuda镜像</a></li><li><a href="https://github.com/tianon/docker-brew-ubuntu-core/blob/58cc180042b7ebec2b683576faa00c04d5d011e2/xenial/Dockerfile" target="_blank" rel="noopener">ubuntu镜像</a></li></ul><h1 id="写时拷贝策略-CopyOnWrite"><a href="#写时拷贝策略-CopyOnWrite" class="headerlink" title="写时拷贝策略(CopyOnWrite)"></a>写时拷贝策略(CopyOnWrite)</h1><p>CopyOnWrite容器即写时复制的容器。通俗的理解是当我们往一个容器添加元素的时候，不直接往当前容器添加，而是<strong>先将当前容器进行Copy，复制出一个新的容器，然后新的容器里添加元素，之后再将原容器的引用指向新的容器</strong>。这样做的好处是我们可以对CopyOnWrite容器进行<strong>并发的读，而不需要加锁</strong>，因为当前容器不会添加任何元素。所以CopyOnWrite容器也是一种<strong>读写分离</strong>的思想，读和写不同的容器。</p><p><strong>缺点</strong></p><ul><li>内存占用问题：<br>在进行写操作的时候，内存里会同时驻扎两个对象的内存，<strong>旧的对象</strong>和<strong>新写入的对象</strong>（注意:在复制的时候只是复制容器里的引用，只是在写的时候会创建新对象添加到新容器里，而旧容器的对象还在使用，所以有两份对象内存）。 <br> docker的什么操作会写容器？不涉及文件写操作的会涉及到容器的写操作吗？只有commit操作会写操作？</li><li>数据一致性问题</li></ul><h2 id="COW的应用"><a href="#COW的应用" class="headerlink" title="COW的应用"></a>COW的应用</h2><p>CopyOnWrite容器非常有用，可以在非常多的并发场景中使用到。</p><h3 id="COW在java"><a href="#COW在java" class="headerlink" title="COW在java"></a>COW在java</h3><p>从JDK1.5开始Java并发包里提供了两个使用CopyOnWrite机制实现的并发容器,它们是CopyOnWriteArrayList和CopyOnWriteArraySet</p><h3 id="COW在C"><a href="#COW在C" class="headerlink" title="COW在C++"></a>COW在C++</h3><p>C++的STL中，曾经也有过Copy-On-Write的玩法，参见陈皓的《C++ STL String类中的Copy-On-Write》，后来，因为有很多线程安全上的事，就被去掉了。</p><h1 id="数据持久化"><a href="#数据持久化" class="headerlink" title="数据持久化"></a>数据持久化</h1><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li><a href="http://www.maiziedu.com/wiki/cloud/dockerimage/" target="_blank" rel="noopener">Docker镜像分层技术</a></li><li><a href="https://coolshell.cn/articles/11175.html" target="_blank" rel="noopener">JAVA中的COPYONWRITE容器</a></li></ul>]]></content>
      
      <categories>
          
          <category> -docker </category>
          
          <category> tutorial </category>
          
      </categories>
      
      
        <tags>
            
            <tag> docker </tag>
            
            <tag> cloud </tag>
            
            <tag> 写时拷贝 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>【Docker系列】Docker入门教程</title>
      <link href="/pub/19bc9ce2/"/>
      <url>/pub/19bc9ce2/</url>
      <content type="html"><![CDATA[<h1 id="环境配置的难题"><a href="#环境配置的难题" class="headerlink" title="环境配置的难题"></a>环境配置的难题</h1><p>如果你正好是一个运维工程师而且你正感觉你的运维<strong>环境一团糟</strong>，麻烦请你思考一下这是为什么？你是不是正在运维着一个使用 php、java、C#甚至 C/C++等用各种语言编写的应用都在运行的环境里？这个环境是不是因为某种历史原因，使你的操作系统运行着各个版本的内核甚至还有 windows？即使是同样语言编写的业务也运行着<strong>不同版本的库</strong>？你的整个系统环境是不是甚至找不出来两台硬件、操作系统、库版本以及语言版本完全一样的环境？于是你每次遇到问题都要去排查到底那个坑到底在那里？从网络、内核到应用逻辑。你每次遇到产品升级都要在各种环境上做稳定性测试，发现不同的环境代码 crash 的原因都不尽相同。你就像一个老中医一样去经历各种疑难杂症，如果遇到问题能找到原因甚至都是幸运的，绝大多数情况是解决了但不知道原因和没解决自动好了也不知道原因。于是你们在一个特定的公司的环境中积累着“经验”，成为你们组新手眼中的大神，凭借历经故障养成的条件反射在快速解决不断发生的重复问题，并故弄玄虚的说：这就是工作经验。因为经验经常是搞不清楚原因时的最后一个遮羞布。当别人抱怨你们部门效率低的时候，你一般的反应是：”you can you up，no can no 逼逼！“</p><blockquote><p>来自知乎</p></blockquote><h1 id="简介-amp-简单原理"><a href="#简介-amp-简单原理" class="headerlink" title="简介 &amp; 简单原理"></a>简介 &amp; 简单原理</h1><p><img src="https://assets.gitlab-static.net/uploads/-/system/project/avatar/3846659/vertical_large.png" alt=""></p><ul><li>可重复</li><li>可移植。镜像应该可以运行在任何主机上并且运行尽可能多的次数。</li></ul><p>用了 Docker，就像世界出现了集装箱，这样你的业务就可以随意的、无拘无束的运行在任何地方。</p><p>Docker 公司的口号：Build，Ship，and Run Any App，Anywhere。大概意思就是编译好一个应用后，可以在任何地方运行，不会像传统的程序一样，一旦换了运行环境，往往就会出现缺这个库，少那个包的问题。</p><h2 id="Docker-concepts"><a href="#Docker-concepts" class="headerlink" title="Docker concepts"></a>Docker concepts</h2><ul><li><strong>镜像</strong>（Image）：Docker 把应用程序及其依赖，打包在 image 文件里面</li><li><strong>容器</strong>（Container）: 镜像本身是只读的，容器从镜像启动时，Docker在镜像的上层创建一个可写层，镜像本身不变。同一个 image 文件，可以生成多个同时运行的容器实例。</li><li><strong>注册服务器</strong>（Registry）: 存放实际的镜像的地方，比如Docker的官方仓库<a href="https://hub.docker.com/" target="_blank" rel="noopener">Docker Hub</a>、<a href="https://store.docker.com/" target="_blank" rel="noopener">Docker Store</a></li><li><strong>仓库</strong>（Repository）: 仓库是存放一组关联镜像的集合，比如同一个应用的不同版本的镜像。比如<a href="https://hub.docker.com/r/tensorflow/tensorflow/tags/" target="_blank" rel="noopener">tensorflow</a></li></ul><h2 id="容器-VS-虚拟机"><a href="#容器-VS-虚拟机" class="headerlink" title="容器 VS 虚拟机"></a>容器 VS 虚拟机</h2><table>  <tbody>    <tr>      <td><img src="https://www.docker.com/sites/default/files/Container%402x.png" alt="Container stack example" width="300px"></td>      <td><img src="https://www.docker.com/sites/default/files/VM%402x.png" alt="Virtual machine stack example" width="300px"></td>    </tr>  </tbody></table><ul><li>轻量级：<br>硬盘空间: ubuntu 16.4的<a href="https://hub.docker.com/_/ubuntu/" target="_blank" rel="noopener">docker镜像</a>只有114M，<a href="https://mirrors.tuna.tsinghua.edu.cn/ubuntu-releases/16.04/" target="_blank" rel="noopener">系统镜像iso</a>则需要1.5G。<br> 运行时: 多个容器共享主机的内核，VM会消耗更多资源</li><li>启动快：<br>虚拟机等完整系统，冗余步骤多：比如用户登录</li><li>Stackable: You can stack services vertically and on-the-fly.</li></ul><!--Hypervisor是一种运行在物理服务器和操作系统之间的中间软件层,可允许多个操作系统和应用共享一套基础物理硬件，因此也可以看作是虚拟环境中的“元”操作系统，它可以协调访问服务器上的所有物理设备和虚拟机，也叫虚拟机监视器（Virtual Machine Monitor）。- 虚拟化的级别越偏底层，速度越慢，用户越难察觉到虚拟化的存在。- 虚拟化的级别越偏上层，速度越快，用户越容易感知。JVM- 程序虚拟机：Java虚拟机（JVM）- 系统虚拟机：VPC，v-Box，VMware Server。。KVM、Xen、OpenVZ。需要一个完整的操作系统，所以体积会比较大，如果想优化速度就必须要精简操作系统了，- VMware ESX Server 裸机安装那么 Docker 的实质是什么？在我看来**就是个针对 PAAS 平台的自动化运维工具而已**。虚拟机启动太慢，额外开销太高，性能由于多了一层会下降。KVM：KVM并没有选择从底层开始新写一个Hypervisor，而是选择了基于Linux Kernel，通过加载新的模块从而使Linux Kernel本身变成一个Hypervisor--><h1 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h1><h2 id="关于镜像的基本操作"><a href="#关于镜像的基本操作" class="headerlink" title="关于镜像的基本操作"></a>关于镜像的基本操作</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">docker images          <span class="comment"># 列出本机所有的docker镜像</span></span><br><span class="line">docker inspect img_id  <span class="comment"># 查看镜像详细信息</span></span><br><span class="line">docker <span class="built_in">history</span> img_id  <span class="comment"># 查看镜像分层</span></span><br><span class="line">docker rmi img_id      <span class="comment"># 删除镜像</span></span><br><span class="line">docker rmi -f $(docker images -q)  <span class="comment"># 删除所有镜像</span></span><br><span class="line">docker pull repository:tag    <span class="comment"># 拉取镜像，类似 git pull</span></span><br><span class="line">docker push repository:tag    <span class="comment"># 上传镜像，类似git push</span></span><br></pre></td></tr></table></figure><h2 id="关于容器的基本操作"><a href="#关于容器的基本操作" class="headerlink" title="关于容器的基本操作"></a>关于容器的基本操作</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1. 基于镜像启动一个容器</span></span><br><span class="line">NAME=name_test           <span class="comment"># 命名你的容器，姓名_任务_其他</span></span><br><span class="line">PROJECT_DIR=`<span class="built_in">pwd</span>`/tutorial</span><br><span class="line">nvidia-docker run -it \</span><br><span class="line">  --name <span class="variable">$NAME</span> \</span><br><span class="line">  -v <span class="variable">$PROJECT_DIR</span>:/root/  \</span><br><span class="line">  tensorflow/tensorflow:latest-gpu bash</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. 运行程序</span></span><br><span class="line"><span class="built_in">cd</span> /root</span><br><span class="line"><span class="built_in">export</span> CUDA_VISIBLE_DEVICES=   <span class="comment"># 只占用cpu</span></span><br><span class="line">python convolutional.py</span><br><span class="line"><span class="comment"># 3. 退出容器</span></span><br><span class="line">ctrl+p+q    <span class="comment"># 临时退出容器而不终止它 (不关闭bash进程)</span></span><br><span class="line"><span class="comment"># ctrl+d    # 退出shell，退出容器</span></span><br><span class="line"><span class="comment"># 4. 查看所有正在运行的容器，并通过name找到你运行的容器</span></span><br><span class="line">docker ps</span><br><span class="line"><span class="comment"># 5. 查看运行日志</span></span><br><span class="line">docker logs container_id</span><br><span class="line"><span class="comment"># 6. 重新进入容器</span></span><br><span class="line">docker attach container_id         <span class="comment"># 进入同一个bash</span></span><br><span class="line"><span class="comment"># 或者</span></span><br><span class="line">docker <span class="built_in">exec</span> -it container_id bash  <span class="comment"># 重新创建一个bash</span></span><br><span class="line"><span class="comment"># 7. 删除容器</span></span><br><span class="line">docker rm container_id</span><br><span class="line"><span class="comment"># 8. 删除所有容器</span></span><br><span class="line">docker rm -f $(docker ps -a -q)</span><br></pre></td></tr></table></figure><p><strong>注意</strong>：</p><ul><li><code>attach</code> 与 <code>exec</code>的区别</li><li><code>ctrl+p+q</code> 与 <code>ctrl+d</code>的区别</li></ul><h2 id="使用建议"><a href="#使用建议" class="headerlink" title="使用建议"></a>使用建议</h2><ul><li>合理命名镜像和容器</li><li>少用port</li><li>不要把频繁更新的项目打入镜像</li><li>不用的镜像及时删除</li><li>不用的容器及时退出</li></ul><h1 id="定制自己的镜像-Dockerfile"><a href="#定制自己的镜像-Dockerfile" class="headerlink" title="定制自己的镜像 - Dockerfile"></a>定制自己的镜像 - Dockerfile</h1><h2 id="自己写dockerfile"><a href="#自己写dockerfile" class="headerlink" title="自己写dockerfile"></a>自己写dockerfile</h2><ul><li><strong>FROM</strong>: 指定基础镜像</li><li><strong>MAINTAINER</strong>：用来指定维护者的姓名和联系方式</li><li><strong>ENV</strong>: 设置环境变量</li><li><strong>RUN</strong>：在shell或者exec的环境下执行的命令。RUN指令会在新创建的镜像上添加新的层</li><li><strong>EXPOSE</strong>: 指定容器在运行时监听的端口</li><li><strong>COPY</strong>:</li><li><strong>VOLUME</strong>: 授权访问从容器内到主机上的目录。用于containers之间共享数据</li><li><strong>WORKDIR</strong>: 指定RUN、CMD与ENTRYPOINT命令的工作目录。</li><li><strong>ENTRYPOINT</strong>:</li><li><strong>CMD</strong>: 提供了容器默认的执行命令</li></ul><p><strong>注意</strong></p><ul><li><code>CMD</code>与 <code>ENTRYPOINT</code> 的区别：<br><code>CMD</code>不能接受参数，运行时可被覆盖；<br> <code>ENTRYPOINT</code>能够接收参数，运行时不可被覆盖</li><li><code>COPY</code>与映射<code>-v</code>的区别</li></ul><p><a href="dockerfile/dockerfile.tf1.8-t2t1.6">示例dockerfile</a></p><h2 id="build-images"><a href="#build-images" class="headerlink" title="build images"></a>build images</h2><p>从文件进行build<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker build -f dockerfile . -t tensorflow/t2t:nmt</span><br></pre></td></tr></table></figure></p><p>或 从标准输入中读取 Dockerfile 进行构建<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat dockerfile | docker build -</span><br></pre></td></tr></table></figure></p><h2 id="docker镜像升级"><a href="#docker镜像升级" class="headerlink" title="docker镜像升级"></a>docker镜像升级</h2><ul><li>更改 &amp; commit的方式   (不推荐)</li><li>更改<code>dockerfile</code>，重新build镜像   (推荐)</li></ul><h2 id="Dockerfile-优化"><a href="#Dockerfile-优化" class="headerlink" title="Dockerfile 优化"></a>Dockerfile 优化</h2><ul><li><code>apt-get install</code>之前先<code>apt-get update</code></li><li>尽量选取满足需求但较小的基础系统镜像，建议选择debian:wheezy镜像，仅有86MB大小</li><li>清理编译生成文件、安装包的缓存等临时文件</li><li>安装各个软件时候要指定准确的版本号，并避免引入不需要的依赖</li><li>从安全的角度考虑，应用尽量使用系统的库和依赖</li><li>使用Dockerfile创建镜像时候要添加.dockerignore文件或使用干净的工作目录</li></ul><p><strong>扩展阅读</strong>:</p><ul><li><a href="https://docs.docker.com/develop/develop-images/dockerfile_best-practices" target="_blank" rel="noopener">Best practices for writing Dockerfiles | 官网</a></li></ul><h1 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h1><p>登录服务器<code>ssh docker1@10.31.39.12</code></p><h2 id="关于镜像的操作"><a href="#关于镜像的操作" class="headerlink" title="关于镜像的操作"></a>关于镜像的操作</h2><p><a href="#关于镜像的基本操作">参考上文↑</a></p><h2 id="关于容器的基本操作-1"><a href="#关于容器的基本操作-1" class="headerlink" title="关于容器的基本操作"></a>关于容器的基本操作</h2><ol><li>从已有docker启动容器，参考<br><a href="https://hub.docker.com/r/tensorflow/tensorflow/" target="_blank" rel="noopener">https://hub.docker.com/r/tensorflow/tensorflow/</a></li><li>从bash启动容器，<a href="#关于容器的基本操作">参考上文↑</a></li></ol><p>optinal:</p><ul><li><strong>httpd</strong>： 利用docker搭一个http server</li><li><strong>gitlab</strong>: 利用docker搭一个gitlab server</li><li><strong>kaldi</strong>: 利用docker跑kaldi</li><li><strong>pytorch</strong>: 利用docker跑pytorch</li></ul><h2 id="Dockerfile相关"><a href="#Dockerfile相关" class="headerlink" title="Dockerfile相关"></a>Dockerfile相关</h2><ol><li>找到<code>tensorflow</code>的dockerfile，并参考</li><li>找到<code>nvidia/cuda</code>的dockerfile，并参考</li><li>自己根据需求，修改dockerfile，build image</li></ol><h2 id="思考题"><a href="#思考题" class="headerlink" title="思考题"></a>思考题</h2><ol><li>卸载 + commit 操作，镜像会变小吗？</li><li><code>run yum clean cache</code>这样写dockerfile镜像会变小吗？</li><li>可以在一个容器中同时运行多个应用进程吗？</li><li>Docker运行时内部删除的文件，如何恢复？</li><li><code>RUN rm -rf somefile</code> 镜像会减小吗？<a href="https://github.com/tianon/docker-brew-ubuntu-core/blob/58cc180042b7ebec2b683576faa00c04d5d011e2/xenial/Dockerfile#L36" target="_blank" rel="noopener">示例</a></li></ol><h1 id="扩展阅读"><a href="#扩展阅读" class="headerlink" title="扩展阅读"></a>扩展阅读</h1><ul><li><a href="https://cloud.tencent.com/developer/article/1005172" target="_blank" rel="noopener">什么是 Docker ？ | 腾讯云社区 </a></li><li><a href="http://www.ruanyifeng.com/blog/2018/02/docker-tutorial.html" target="_blank" rel="noopener">Docker 入门教程 | 阮一峰</a></li><li><a href="https://yeasy.gitbooks.io/docker_practice/" target="_blank" rel="noopener">docker practice</a></li></ul>]]></content>
      
      <categories>
          
          <category> -docker </category>
          
          <category> tutorial </category>
          
      </categories>
      
      
        <tags>
            
            <tag> docker </tag>
            
            <tag> cloud </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>docker中的权限</title>
      <link href="/pub/ee61a13a/"/>
      <url>/pub/ee61a13a/</url>
      <content type="html"><![CDATA[<h1 id="docker-客户端"><a href="#docker-客户端" class="headerlink" title="docker 客户端"></a>docker 客户端</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ ls -lh /usr/bin/docker</span><br><span class="line">-rwxr-xr-x 1 root root 37M Apr 26 15:18 /usr/bin/docker</span><br></pre></td></tr></table></figure><p>默认所有用户都能够执行docker命令，但是执行其他命令，会出现权限问题。</p><h1 id="docker-服务"><a href="#docker-服务" class="headerlink" title="docker 服务"></a>docker 服务</h1><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ docker images</span><br><span class="line">Got permission denied <span class="keyword">while</span> trying to connect to the Docker daemon socket at unix:///var/run/docker.sock: Get http://%2Fvar%2Frun%2Fdocker.sock/v1.37/images/json: dial unix /var/run/docker.sock: connect: permission denied</span><br></pre></td></tr></table></figure><p>执行查询镜像命令，报错。因为该用户不在docker用户组。而只有docker用户组才有权限访问docker server。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> /var/run/</span><br><span class="line">$ ls -lh | grep docker</span><br><span class="line">drwx------  9 root  root    200 Jul  7 11:03 docker</span><br><span class="line">-rw-r--r--  1 root  root      4 Jul  6 14:33 docker.pid</span><br><span class="line">srw-rw----  1 root  docker    0 Jul  6 14:32 docker.sock   <span class="comment"># docker server</span></span><br></pre></td></tr></table></figure><p>docker.sock属于docker用户组。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ cat /etc/group | grep docker</span><br><span class="line">docker:x:999:song.xu01</span><br></pre></td></tr></table></figure><h2 id="添加权限"><a href="#添加权限" class="headerlink" title="添加权限"></a>添加权限</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ usermod -aG docker 用户名 <span class="comment"># 添加到docker用户组</span></span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> -docker </category>
          
          <category> tutorial </category>
          
      </categories>
      
      
        <tags>
            
            <tag> docker </tag>
            
            <tag> cloud </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>从wmt竞赛看机器翻译史</title>
      <link href="/pub/c5a74607/"/>
      <url>/pub/c5a74607/</url>
      <content type="html"><![CDATA[<h1 id="简介-amp-汇总"><a href="#简介-amp-汇总" class="headerlink" title="简介 &amp; 汇总"></a>简介 &amp; 汇总</h1><ul><li>wmt15</li><li>wmt16</li><li>wmt17</li><li>wmt18</li></ul><h1 id="WMT15"><a href="#WMT15" class="headerlink" title="WMT15"></a>WMT15</h1><h1 id="WMT16"><a href="#WMT16" class="headerlink" title="WMT16"></a>WMT16</h1><h1 id="WMT2017"><a href="#WMT2017" class="headerlink" title="WMT2017"></a>WMT2017</h1><p><a href="http://m.sohu.com/a/164001797_465975" target="_blank" rel="noopener">搜狗机器翻译团队获得 WMT 2017 中英机器翻译冠军</a></p><p><img alt="审计署" src="/images/raw/ML - NLP - MT - wmt17 best system.png"></p><p><img alt="审计署" src="/images/raw/ML - NLP - MT - wmt17 best score.png"></p><p>尚未出现transformer，主流模型是attention-RNN。</p><p>核心问题通常是如何优化神经网络结构以便解决机器翻译中的词对齐、罕见词、长句等难点问题。</p><p>2014 年提出的注意力（attention）模块就是针对性处理因为不同语言语法结构不同产生的语序不同、来源词与目标词对齐难的问题。注意力机制通过选全局性的选择关注源语言橘子的不同部分，动态地构建上下文向量来对传统 RNN 编码器-解码器进行了优化，极大改善了语言调序，尤其是中长距离调序问题。</p><h1 id="WMT2018"><a href="#WMT2018" class="headerlink" title="WMT2018"></a>WMT2018</h1><p><a href="https://mp.weixin.qq.com/s/DUp1_dsR70r8RqQ08SaC-A" target="_blank" rel="noopener">腾讯信息安全部征战世界机器翻译大赛获不俗战绩 - 2018</a></p><p>阿里、腾讯冠军。主流方法transformer。比wmt17提升</p><p><img alt="审计署" src="/images/raw/ML - NLP - MT - wmt18 best system.png"></p><p><img alt="审计署" src="/images/raw/ML - NLP - MT - wmt18 best score.png"></p><h2 id="阿里达摩院-5项冠军"><a href="#阿里达摩院-5项冠军" class="headerlink" title="阿里达摩院 - 5项冠军"></a>阿里达摩院 - 5项冠军</h2><p>5个项目包括英文-中文翻译、英文-俄罗斯语互译、英文-土耳其语互译，达摩院在这几个项目的自动评测指标BLEU都位居第一。</p><ul><li>陈博兴博士</li><li>司罗教授 - NLP 首席科学家</li></ul><p>基于业界最新的Transformer结构，进行了网络结构的改进和对<strong>词语位置信息</strong>的充分利用。</p><p>尽管 Transformer <strong>在解码速度和位置编码等方面有一些缺点</strong>，但它仍然是当前效果最好的神经机器翻译基本架构</p><h2 id="腾讯"><a href="#腾讯" class="headerlink" title="腾讯"></a>腾讯</h2><h3 id="transformer改进"><a href="#transformer改进" class="headerlink" title="transformer改进"></a>transformer改进</h3><p>将 Transformer 中的 Multi-Head Attention 替换为多个自注意力分支，而模型会在训练阶段中将学习结合这些分支注意力模块。其次，阿里采用了一种编码相对位置的表征以扩展自注意力机制，并令模型能更好地理解序列元素间的相对距离。</p><h3 id="多模型融合"><a href="#多模型融合" class="headerlink" title="多模型融合"></a>多模型融合</h3><ul><li>主体是transformer</li><li>rnn seq2seq<br>每一种翻译任务都<strong>集成了几十上百个基础模型</strong></li></ul><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="http://www.sohu.com/a/234238473_129720" target="_blank" rel="noopener">专访达摩院</a></p><h2 id="云知声-第三"><a href="#云知声-第三" class="headerlink" title="云知声 - 第三"></a>云知声 - 第三</h2><p>transformer + 数据生成（back translation）、多形态模型融合（ensemble）、多特征重排序（rerank）等，优化翻译效果。</p>]]></content>
      
      <categories>
          
          <category> -machine translation </category>
          
          <category> 竞赛 &amp; 业界 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>【机器翻译】</title>
      <link href="/pub/19f3291d/"/>
      <url>/pub/19f3291d/</url>
      <content type="html"><![CDATA[<p>2015<br>Addressing the rare word problem in neural machine translation<br>采用了未登录词替换的方法</p>]]></content>
      
      
    </entry>
    
    <entry>
      <title></title>
      <link href="/pub/0/"/>
      <url>/pub/0/</url>
      <content type="html"><![CDATA[]]></content>
      
      
    </entry>
    
    <entry>
      <title>文本特征提取</title>
      <link href="/pub/78b8672a/"/>
      <url>/pub/78b8672a/</url>
      <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><h1 id="特征"><a href="#特征" class="headerlink" title="特征"></a>特征</h1><ul><li>[BOW]</li></ul><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li><a href="http://scikit-learn.org/stable/modules/feature_extraction.html#text-feature-extraction" target="_blank" rel="noopener">文本特征提取</a></li></ul>]]></content>
      
      <categories>
          
          <category> ML </category>
          
          <category> applications </category>
          
          <category> nlp </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>【反爬虫系列】代理IP</title>
      <link href="/pub/64cff6f7/"/>
      <url>/pub/64cff6f7/</url>
      <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>市面上的免费代理IP种类繁多，很多品牌被吹嘘得天花乱坠，让用户在挑选时不知道该如何下手。<br>其实对于大部分用户来说，选择一款服务器稳定的代理IP资源是十分明智的，而对于免费代理IP来说，稳定性恰恰是它们的通用诟病，<br>你需要花费大量的时间精力来筛选可用IP资源，</p><h1 id="资源"><a href="#资源" class="headerlink" title="资源"></a>资源</h1><h2 id="免费IP"><a href="#免费IP" class="headerlink" title="免费IP"></a>免费IP</h2><p><a href="https://github.com/jhao104/proxy_pool" target="_blank" rel="noopener">https://github.com/jhao104/proxy_pool</a></p><h2 id="收费IP"><a href="#收费IP" class="headerlink" title="收费IP"></a>收费IP</h2><div class="table-container"><table><thead><tr><th>供应商</th><th>节点来源</th><th>协议支持</th><th>线路类型</th><th>价格</th></tr></thead><tbody><tr><td><a href="http://www.dailiyun.com/" target="_blank" rel="noopener">代理云</a></td><td>宽带拨号</td><td>Http/Https/Socks4 5</td><td>电信、联通、移动</td><td>最低5000IP/日（起售），最高可满足10万IP/日</td></tr><tr><td>[太阳HTTP]</td><td></td><td>Http/Https/Socks5</td><td></td><td>每日免费领20个IP。公司给买的每天300个IP，估计是最低套餐</td></tr><tr><td></td><td></td><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td><td></td></tr></tbody></table></div><h1 id="方式"><a href="#方式" class="headerlink" title="方式"></a>方式</h1><ul><li>HTTP代理IP从成本上区分有免费版和付费版两种，免费IP获取方便，在百度搜索关键词就可以得到大量资源，<br>缺点是免费IP服务器存在不安全因素，用户的访问信息有可能会被记录，<br>造成个人隐私泄漏，无法保障使用者的安全性。由于代理IP传输的特殊性，甚至还可能掉进一些伪造的钓鱼网站，带来不必要的麻烦。</li></ul><p>分布式高质量代理IP变成了爬虫业的刚需，通过接入代理云平台，直接进行多线程操作</p><p>代理云为爬虫提供分布式代理IP解决方案</p><p>#</p><p>代理IP速度慢的原因有很多，<br>原因一，代理IP服务器所处网络速度不佳；<br>原因二，代理IP服务器性能差；<br>原因三，代理IP服务器传输距离远；<br>原因四，目标站点速度不稳定；<br>原因五，用户电脑配置差；原因六，用户网速慢。</p>]]></content>
      
      <categories>
          
          <category> CS </category>
          
          <category> network </category>
          
          <category> 爬虫 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>马尔科夫模型</title>
      <link href="/pub/92ba39c3/"/>
      <url>/pub/92ba39c3/</url>
      <content type="html"><![CDATA[<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li><a href="http://www.nlpr.ia.ac.cn/cip/ZongReportandLecture/Lecture_on_NLP/Chp-06.pdf" target="_blank" rel="noopener">隐马尔可夫模型 | 宗成庆</a></li><li></li></ul>]]></content>
      
      <categories>
          
          <category> ML </category>
          
          <category> machine learning 传统方法 </category>
          
          <category> supervised </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>贝叶斯学派 VS 频率学派</title>
      <link href="/pub/ed02138c/"/>
      <url>/pub/ed02138c/</url>
      <content type="html"><![CDATA[<p>见知乎</p>]]></content>
      
      <categories>
          
          <category> ML </category>
          
          <category> machine learning 传统方法 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>自然语言处理 - 从规则到统计</title>
      <link href="/pub/cd9c7906/"/>
      <url>/pub/cd9c7906/</url>
      <content type="html"><![CDATA[<h1 id="语言"><a href="#语言" class="headerlink" title="语言"></a>语言</h1><p>字母(或者中文的笔画)、文字和数字实际上是信息编码的不同单元。任何一种语言都是一种编码的方式，而<strong>语言的语法规则是编解码的算法</strong>。</p><p>我们把一个要表达的意思，通过某种语言的一句话表达出来，就是用这种语言的编码方式对头脑中的信息做了一次<strong>编码</strong>，编码的结果就是一串文字。而如果对方懂得这门语言，他就可以用这门语言的<strong>解码方法</strong>获得说话人要表达的信息。这就是语言的数学本质。</p><!-- --><h2 id="基本名词"><a href="#基本名词" class="headerlink" title="基本名词"></a>基本名词</h2><ul><li>文法、语法 Grammer</li><li>文法包括词法和句法</li><li>词法主要研究词的内部结构，包括变形、构词法。又称形态学(Morphologic)</li><li>句法研究句子结构成分的相关关系</li></ul><ul><li>上下文无关文法 (Context Independent Grammar)，比如程序设计语言。计算复杂度大约是句子长度的2次方</li><li>上下文有关文法 (Context dependency Grammar)，比如自然语言。计算复杂度大约是语句长度的6次方。</li></ul><h1 id="自然语言理解"><a href="#自然语言理解" class="headerlink" title="自然语言理解"></a>自然语言理解</h1><ul><li>人是怎样理解语言的？</li><li>机器能否像人一样理解语言？</li></ul><p>今天，机器翻译和语音识别已经做得不错，但大部分这个领域之外的人依然错误地认为这两个应用是靠计算机理解了自然语言而完成的。事实上，它们全都靠得是数学，更准确地说是<strong>靠统计</strong>。</p><h2 id="门派"><a href="#门派" class="headerlink" title="门派"></a>门派</h2><ul><li>基于规则的：专家根据自己的经验 人工撰写规则。<ul><li>背景：</li><li>优点：设计规则，简单有效。</li><li>缺点：费时费力；规则不能覆盖各种语言现象</li></ul></li><li>基于统计的：<ul><li>背景：上个世纪80年代后期，机器学习算法被引入到自然语言处理中，这要归功于不断提高的计算能力。</li><li>优点：相对基于规则的方法，更鲁棒</li><li>缺点/局限性：data-driven，强烈依赖数据，需要大规模的训练语料。计算能力</li></ul></li></ul><p>基于统计的方法代替传统的方法，需要等原有的一批语言学家退休。</p><p>今天几乎不再有科学家宣称自己是基于规则方法的捍卫者。而自然语言处理的研究也<strong>从单纯的句法分析和语义理解，变成了非常贴近应用的机器翻译、语音识别、文本到数据库自动生成、数据挖掘和知识的获取等等。</strong></p><blockquote><p>上面是什么意思？从无监督学习变成了有监督学习？贬低语义理解？</p></blockquote><h3 id="门派斗争"><a href="#门派斗争" class="headerlink" title="门派斗争"></a>门派斗争</h3><ul><li>基于统计的方法只能处理浅层的自然语言处理问题，无法进入生层次的研究</li></ul><h2 id="基于规则的自然语言处理"><a href="#基于规则的自然语言处理" class="headerlink" title="基于规则的自然语言处理"></a>基于规则的自然语言处理</h2><p><code>语法规则</code>(Gramar Rules)、<code>词性</code>(Part of Speech)、<code>构词法</code>(Morphologic)等，这些规则是人类学习语言(尤其是外语)的好工具。而恰恰这些语法规则又很容易用计算机的算法描述，这就更坚定了大家对基于规则的自然语言处理的信心。</p><p>语法树太复杂</p><h2 id="基于统计的自然语言处理"><a href="#基于统计的自然语言处理" class="headerlink" title="基于统计的自然语言处理"></a>基于统计的自然语言处理</h2><p><strong>由于计算量十分庞大，在20世纪70年代，基于规则的句法分析很快走到了尽头</strong>。</p><p>1970年以后统计语言学的出现使得自然语言处理重获新生。<br>当时，基于统计的方法核心模型是通信系统加<code>隐马尔科夫模型</code>。<strong>这个系统的输入和输出都是一维的符号序列，而且保持原有的次序</strong>(即sequence labeling问题)。最早获得成功的是语音识别，接下来是磁性分析。</p><p>但是在句法分析中，输入时一维的句子，输出是二维的分析树。在机器翻译中，<strong>输出的次序会有很大的变化</strong>（翻译不再是sequence labeling问题）。HMM就不太管用了。1988年，IBM的Peter Brown等人提出了基于统计的机器翻译方法，框架是对的，但是效果很差，因为当时既没有足够的数据，也没有足够强大的模型来解决不同语言<strong>语序颠倒的问题</strong>。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li>《数学之美》 | 吴军</li><li>《》</li></ul>]]></content>
      
      <categories>
          
          <category> ML </category>
          
          <category> applications </category>
          
          <category> nlp </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>优化方法总结比较（SGD，Adagrad，Adadelta，Adam，Adamax，Nadam）</title>
      <link href="/pub/b64e6f85/"/>
      <url>/pub/b64e6f85/</url>
      <content type="html"><![CDATA[<p><img src="http://img.mp.itc.cn/upload/20170404/44ce325fe7ae4be6b68641e9a7b927ba_th.gif"></p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li><a href="https://zhuanlan.zhihu.com/p/27609238" target="_blank" rel="noopener">为什么说随机最速下降法(SGD)是一个很好的方法？ | 知乎</a></li><li><a href="https://zhuanlan.zhihu.com/p/36624193" target="_blank" rel="noopener">SGD在两层神经网络上是怎么收敛的？</a></li><li><a href="http://ruder.io/optimizing-gradient-descent/index.html" target="_blank" rel="noopener">An overview of gradient descent optimization algorithms | 经典</a><ul><li><a href="https://hk.saowen.com/a/6075f19acc0a425be47ffbd40a08544269027c1210795b40f59449be3c888837" target="_blank" rel="noopener">繁体翻译 - 隨機梯度下降（SGD）優化算法及可視化</a></li><li><a href="https://zhuanlan.zhihu.com/p/22252270" target="_blank" rel="noopener">知乎翻译</a></li></ul></li><li><a href="https://keras.io/optimizers/" target="_blank" rel="noopener">keras的优化器</a></li><li><a href=""></a></li></ul>]]></content>
      
      <categories>
          
          <category> Math </category>
          
          <category> optimization </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>SVD与PCA</title>
      <link href="/pub/980c5a0f/"/>
      <url>/pub/980c5a0f/</url>
      <content type="html"><![CDATA[<p><a href="http://www.cnblogs.com/LeftNotEasy/archive/2011/01/19/svd-and-applications.html" target="_blank" rel="noopener">http://www.cnblogs.com/LeftNotEasy/archive/2011/01/19/svd-and-applications.html</a></p><p>Matrix Factorization<br>SVD</p><p>u =</p><p>-0.825066 -0.047735 -0.563016<br>-0.443084 -0.563669 0.697104<br>-0.350631 0.824620 0.443914</p><p>s =</p><p>Diagonal Matrix</p><p>9.2654 0 0</p><pre><code>0   3.2340        00        0   1.3016</code></pre><p>v =</p><p>-0.636527 -0.770982 -0.020485<br>-0.476317 0.372083 0.796666<br>-0.606593 0.516857 -0.604073</p><p>U V有个特性，每行，每列的平方和都等于1.</p><p>Matrix Factorization<br>应该是，Diagonal Matrix中比较大的值，对应的U，V相应的行列，影响权值越大。<br>特征值分解必须针对方阵，即只有方阵才有特征值，这也是特征值分解的一个局限</p><p> Q是矩阵A的特征向量组成的矩阵，Q不唯一<br>一个矩阵其实就是一个线性变换，因为一个矩阵乘以一个向量后得到的向量，其实就相当于将这个向量进行了线性变换</p><p>奇异值分解<br>在很多情况下，前10%甚至1%的奇异值的和就占了全部的奇异值之和的99%以上了</p><p>一个很好的tutorial<br><a href="http://www.puffinwarellc.com/index.php/news-and-articles/articles/30-singular-value-decomposition-tutorial.html?showall=1" target="_blank" rel="noopener">http://www.puffinwarellc.com/index.php/news-and-articles/articles/30-singular-value-decomposition-tutorial.html?showall=1</a><br><a href="http://www.ams.org/samplings/feature-column/fcarc-svd" target="_blank" rel="noopener">http://www.ams.org/samplings/feature-column/fcarc-svd</a></p><h1 id="fed"><a href="#fed" class="headerlink" title="fed"></a>fed</h1><p>实质是降维<br>对矩阵X和V的理解，X是latent vector representations ，V是词典，也就是latent space的坐标系。当然也可以U作为表达，sigma*V作为词典</p><p>我的实验<br>要解决的问题：<br>对1000个样本进行降维，我们可以采用SVD分解。如果又来了一个新样本，如何获得这个样本的降维表示？<br>方法一：与原始样本组成1001的矩阵，然后整体矩阵进行SVD分解（计算复杂度较高）。因此我们提出一下问题</p><p>SVD分解是否对新增样本具有不变性，包括1.降维表达不变性；2.词典不变性？？？<br>对 1000<em>30的矩阵进行svd分解，并降维到1000</em>20。<br>1000<em>30=【1000</em>20】<em>【20</em>20】<em>【20</em>30】=【1000<em>20】</em>【20*30】 ，这里第一项是降维表示，第二项是词典</p><p>新增一个样本，变为1001<em>30，对其SVD分解，U,S，V 与原始的USV几乎不变，只是增加了相应的行和列。这就寻找到了一个不变的量。<br>然后具体如何获得一个新样本的降维表示呢？<br>1</em>30=【1<em>20】</em>【20*30】<br>Ax=Y，超定方程组，一般无解，只能求近似解<br>类似超定方程求解，以下程序的方法不一定很好  。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">---------------------------------------------------------------</span><br><span class="line">clear,clc</span><br><span class="line">a=rand(100,1);       %a作为训练集</span><br><span class="line">[U,S,V]=svd(a);</span><br><span class="line">a20=U*S(:,1:20)*(V(1:20,:))&apos;;    %降维到20维后的重建</span><br><span class="line">error=sum(sum(abs(a-a20)));</span><br><span class="line">aplus=[a;rand(1,30)];</span><br><span class="line"></span><br><span class="line">%方法一：</span><br><span class="line">[U1,S1,V1]=svd(aplus);     % 对所有样本进行SVD分解</span><br><span class="line">P1=U1(101,:)*S1(:,1:20);    % 新样本降到20维后的表示</span><br><span class="line"></span><br><span class="line">%方法二：利用求解超定方程组的方法</span><br><span class="line">P2=inv(V&apos;*V)*V&apos;*aa&apos;         %利用训练集得到的词典，求得的新样本表示</span><br><span class="line">P3=inv(V1&apos;*V1)*V1&apos;*aa&apos;      %利用所有样本降维后的词典，求得的新样本表示</span><br><span class="line">-------------------------------------------------------------------</span><br><span class="line">P1=P3。说明这个方法很好，也就是把超定方程组化为普通方程组。这个方法有点类似</span><br></pre></td></tr></table></figure><h1 id="fd"><a href="#fd" class="headerlink" title="fd"></a>fd</h1>]]></content>
      
      <categories>
          
          <category> Math </category>
          
          <category> 线性代数 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>【机器翻译】RNN系列 - 注意力模型</title>
      <link href="/pub/6eefa992/"/>
      <url>/pub/6eefa992/</url>
      <content type="html"><![CDATA[<p><img title="attention based LSTM(图来自opennmt)" src="/images/raw/NN - seq2seq - attention based rnn.jpg"></p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1>]]></content>
      
      <categories>
          
          <category> -machine translation </category>
          
          <category> 2. 主流model-研究现状 </category>
          
          <category> 2. 神经网络机器翻译 NMT </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 机器翻译 </tag>
            
            <tag> seq2seq </tag>
            
            <tag> RNN </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>个人所得税</title>
      <link href="/pub/88165cc0/"/>
      <url>/pub/88165cc0/</url>
      <content type="html"><![CDATA[<p>2018.06.19，十三届全国人大常委会第三次会议，个税修正案提请审议。<br>这是个税法自1980年出台以后第七次大修。</p>]]></content>
      
      <categories>
          
          <category> economy </category>
          
          <category> 赋税 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>中朝</title>
      <link href="/pub/5d84fcc7/"/>
      <url>/pub/5d84fcc7/</url>
      <content type="html"><![CDATA[<h2 id="金正恩，百日内三度访华"><a href="#金正恩，百日内三度访华" class="headerlink" title="金正恩，百日内三度访华"></a>金正恩，百日内三度访华</h2><p>-</p><ul><li>2018-6.12 金正恩在新加坡会见特朗普 (朝鲜战争之后首次<code>朝美首脑会晤</code>) <strong>牛逼呀</strong><ul><li>迈出了半岛核问题政治解决进程的重要一步。</li></ul></li><li>2018.6.19-6.20，金正恩、李雪主第三次访华，钓鱼台国宾馆。（估计是<code>朝美首脑会晤</code>后的一个表态）<ul><li>参观农业科学院 科技创新园</li><li>参观北京市轨道交通指挥中心</li><li>希望同中方一道，推动构建朝鲜半岛持久牢固和平机制</li></ul></li></ul><p>金正恩为半岛无核化</p><p>李克强、王沪宁、王岐山、丁薛祥、杨洁篪、北京市委书记蔡奇、外部部长、王毅</p>]]></content>
      
      <categories>
          
          <category> others </category>
          
          <category> politics </category>
          
          <category> 朝鲜 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>【机器翻译】RNN系列 - GNMT</title>
      <link href="/pub/6eefa992/"/>
      <url>/pub/6eefa992/</url>
      <content type="html"><![CDATA[<p>2016年9月，Google机器翻译实现重大突破！Google研究团队宣布开发<code>Google神经机器翻译系统</code>(GNMT)。同年11月，Google翻译<strong>停止使用其自2007年10月以来一直使用的专有统计机器翻译（SMT）技术，开始使用神经机器翻译（NMT）</strong>。<br>从此宣告， 机器翻译经过27年左右， 正式从1989年的IBM机器翻译模型(PBMT，基于短语的机器翻译)，过渡到了神经网络机器翻译模型。</p><p>GNMT是一种端到端的学习方法，<strong>不再将句子分解为词和短语独立翻译，而是翻译完整的句子</strong>，使得误差降低了 55%-85% 以上。</p><p><img title="GNMT进行中英翻译的流程" src="/images/raw/NN - GNMT - flow.gif"></p><p>首先，模型对中文进行编码。整个句子编码完成后，启动decoder，进行解码。解码过程中的每一步，都需要一组attention weight，对输入序列的vector进行加权。</p><h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>NMT虽然已经开始应用，</p><p>但 NMT 系统的训练和翻译推理的计算成本非常高，同时也难以应对罕见词，这些问题阻碍了 NMT 在实际部署和服务中的应用，因为在实际应用中，准确度和速度都很关键。而谷歌的神经机器翻译提出了带有 8 个编码器和 8 个解码器的深度 LSTM 网络组成的模型，使用了注意力和残差连接。为了提升并行性从而降低训练时间，注意机制将解码器的底层连接到了编码器的顶层。在推理计算过程中使用了低精度运算来加速翻译速度。为改善对罕见词的处理，谷歌将词分成常见子词单元（词的组件）的一个有限集合，该集合既是输入也是输出。这种方法能提供「字符」-delimited models 的灵活性和「词」-delimited models 的有效性之间的平衡、能自然地处理罕见词的翻译、并能最终提升系统的整体准确度。谷歌的波束搜索技术使用了一个长度规范化过程，并使用了一个覆盖度惩罚，其可以激励很可能能覆盖源句子中所有的词的输出句子的生成。在 WMT’ 14 英语-法语和英语-德语基准上，GNMT 实现了可与当前最佳结果媲美的结果。通过在一个单独的简单句子集合的人类对比评估中，它相比于谷歌已经投入生产的基于短语的系统的翻译误差平均降低了 60%。</p><!--GNMT improves on the quality of translation by applying an example based (EBMT) MT method in which the system "learns from millions of examples"--><h1 id="模型"><a href="#模型" class="headerlink" title="模型"></a>模型</h1><p><img title="GNMT architecture" src="/images/raw/NN - GNMT - architecture.jpg"></p><p><img title="LSTM with residual connection" src="/images/raw/NN - GNMT - LSTM with residual.png"></p><h1 id="zero-shot翻译"><a href="#zero-shot翻译" class="headerlink" title="zero-shot翻译"></a>zero-shot翻译</h1><p>GNMT系统可以处理“零点翻译”，即直接将一种语言翻译成另一种语言（例如中文到日文）。以前Google翻译会<strong>先将源语言翻译成英文，然后将英文翻译成目标语言</strong>，而不是直接从一种语言翻译成另一种语言。</p><h1 id="Result"><a href="#Result" class="headerlink" title="Result"></a>Result</h1><p><img title="评分从0到6，0表示最差翻译，6表示最佳翻译" src="https://1.bp.blogspot.com/-jOLa-LdidQU/V-qV2oJn1aI/AAAAAAAABPg/-6OhKKPhxT89Vs9HhyKMEnyG_0ncWGjJQCLcB/s640/image00.png"></p><p><img title="不同翻译系统的效果对比" src="https://1.bp.blogspot.com/-TAEq5oc14jQ/V-qWTeqaA7I/AAAAAAAABPo/IEmOBO6x7nIkzLqomgk_DwVtzvpEtJF1QCLcB/s640/img3.png"></p><p>以上可以看出</p><h1 id="存在的问题"><a href="#存在的问题" class="headerlink" title="存在的问题"></a>存在的问题</h1><ul><li>漏翻 <!-- dropping words --></li><li>错翻：特别是对于名字和稀有词(rare word)</li><li>未考虑大语境(context of the paragraph or page)</li></ul><h1 id="扩展阅读"><a href="#扩展阅读" class="headerlink" title="扩展阅读"></a>扩展阅读</h1><ul><li><a href="">GNMT: Bridging the Gap between Human and Machine Translation</a></li><li><a href="https://ai.googleblog.com/2016/09/a-neural-network-for-machine.html" target="_blank" rel="noopener">NTM at Production Scale | Google Blog</a></li><li><a href="https://en.wikipedia.org/wiki/Google_Neural_Machine_Translation" target="_blank" rel="noopener">GNMT | 维基百科</a></li><li><a href="https://www.zhihu.com/question/51089192" target="_blank" rel="noopener">如何评价Google神经机器翻译（GNMT）系统？ | 知乎</a></li></ul>]]></content>
      
      <categories>
          
          <category> -machine translation </category>
          
          <category> 2. 主流model-研究现状 </category>
          
          <category> 2. 神经网络机器翻译 NMT </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 机器翻译 </tag>
            
            <tag> seq2seq </tag>
            
            <tag> attention </tag>
            
            <tag> RNN </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>【机器翻译】CNN系列 - convseq2seq</title>
      <link href="/pub/b4bccd18/"/>
      <url>/pub/b4bccd18/</url>
      <content type="html"><![CDATA[<h1 id="模型简介"><a href="#模型简介" class="headerlink" title="模型简介"></a>模型简介</h1><p>convseq2seq 架构<br><img alt="Illustration of batching during training" title="convs2s的batch training过程" src="/images/raw/NN - convseq2seq - architecture.png"><br><strong>注意</strong>: 这里的attention是同时得到的，RNN中的attention则是依次得到的。</p><p>卷积过程<br><img alt="convseq2seq的卷积过程" title="convseq2seq的卷积过程" src="/images/raw/NN - convseq2seq - flow.gif"></p><p>采用的全卷积网络(没有RNN)</p><ul><li><code>Position Embedding</code>: 给CNN更多的“位置感”</li><li><code>Gated Linear Units</code>: 给CNN的输出加gate<!-- gated linear units eases gradient propagation --></li><li><code>Residual Connection</code>: 给CNN都加</li><li><code>Multi-step Attention</code>: 一层attention不够那就上叠加的attention</li></ul><h1 id="Implementation-实现细节"><a href="#Implementation-实现细节" class="headerlink" title="Implementation/实现细节"></a>Implementation/实现细节</h1><p>Fairseq features:</p><ul><li>multi-GPU (distributed) training on one machine or across multiple machines</li><li>fast beam search generation on both CPU and GPU</li><li>large mini-batch training (even on a single GPU) via delayed updates</li><li>fast half-precision floating point (FP16) training</li></ul><h1 id="code"><a href="#code" class="headerlink" title="code"></a>code</h1><ul><li><a href="https://github.com/facebookresearch/fairseq" target="_blank" rel="noopener">fairseq - torch</a> 停止更新</li><li><a href="https://github.com/pytorch/fairseq" target="_blank" rel="noopener">fairseq - pytorch</a> 及时更新</li></ul><h1 id="paper"><a href="#paper" class="headerlink" title="paper"></a>paper</h1><ul><li>A Convolutional Encoder Model for Neural Machine Translation 2016</li><li>Convolutional Sequence to Sequence Learning 2017</li></ul><h1 id="扩展阅读"><a href="#扩展阅读" class="headerlink" title="扩展阅读"></a>扩展阅读</h1><ul><li><a href="https://code.facebook.com/posts/1978007565818999/a-novel-approach-to-neural-machine-translation/" target="_blank" rel="noopener">blog | facebook</a></li><li><a href="https://www.zhihu.com/question/59645329/answer/167704376" target="_blank" rel="noopener">https://www.zhihu.com/question/59645329/answer/167704376</a></li></ul>]]></content>
      
      <categories>
          
          <category> -machine translation </category>
          
          <category> 2. 主流model-研究现状 </category>
          
          <category> 2. 神经网络机器翻译 NMT </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 机器翻译 </tag>
            
            <tag> seq2seq </tag>
            
            <tag> CNN </tag>
            
            <tag> attention </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>【机器翻译】字符级机器翻译 - BPE</title>
      <link href="/pub/a8b3f785/"/>
      <url>/pub/a8b3f785/</url>
      <content type="html"><![CDATA[<p>2016</p><p>Neural Machine Translation of Rare Words with Subword Units</p><h1 id="解决的问题"><a href="#解决的问题" class="headerlink" title="解决的问题"></a>解决的问题</h1><p>OOV问题</p><p>中文也存在OOV问题。比如分词以后</p><h1 id="核心思想"><a href="#核心思想" class="headerlink" title="核心思想"></a>核心思想</h1><p>其核心思想是语料库中的高频词作为整体出现的可能性大，因此不对其进行切分，而<strong>对低频词进行切分</strong>，由此增加稀疏词中子词的共现次数。</p><p>encoding rare and unknown words as sequences<br>of subword units.</p><p>本文讨论了subword的不同分割技巧：</p><ul><li>character n-gram models</li><li>segmentation based on the byte pair encoding compression algorithm</li></ul><p>规避大词典。原来都是先把一个数据集中所有单词找出来，把最常用的一些（如90%）做成一个大词典，显然这是冗余的，words和word完全没必要区分。动不动就是50K的单词表，非常耗内存，在像Czech这类语言上更加不行。关键是冗余不优雅。很多研究者都注意到这个问题：</p><ul><li>subword，就是统计一下符号的频率，如“est”可能是一个符号，能组成“w est,b est”等词，因此称为subword。我觉得还是不够自然，而且效果并不是很好。</li><li>Hybrid Word-Character Models，相当于把未知的词训练成RNN小单元，据说华为很早就申请专利了。我表示，不能有word。</li><li>Junyoung Chung提出的不需要显式分隔的模型。提出bi-scale的RNN，我觉得很有意思，但我有个疑问，这跟base的RNN有什么区别？论文中也显示，确实差不多。我不知道为什么性能那么好。由于没有训练时间、训练所用内存等更多信息我无法作出判断。</li><li>还有Wang Ling提出的，但是完全不是NMT，需要借助IBM model来对齐和分层训练，而且效果不好。</li></ul><h1 id="related-work"><a href="#related-work" class="headerlink" title="related work"></a>related work</h1><ul><li>2016 年，Rico Sennrich 和 Barry Haddow 等人提出了 Byte Pair Encoding (BPE)的方法，将原有的单词拆解成了更小单元的高频词进行翻译。 BPE 方法在多大程度上解决了未登录词翻译的问题。对未登录词的翻译精准度达到了 45%左右，</li></ul><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li><a href="https://github.com/rsennrich/subword-nmt" target="_blank" rel="noopener">subword-nmt | github</a></li></ul>]]></content>
      
      <categories>
          
          <category> -machine translation </category>
          
          <category> 2. 主流model-研究现状 </category>
          
          <category> 2. 神经网络机器翻译 NMT </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Dropbox差异同步算法rsync及其改进算法原理</title>
      <link href="/pub/8c8e707b/"/>
      <url>/pub/8c8e707b/</url>
      <content type="html"><![CDATA[<p>打个比方，你一共在两台电脑上（A,B）用同一个帐号的Dropbox，一共有三个文件（C，D，E），你在A电脑上删了（或者任意操作后保存）C，只要同步，B上面的C就会执行自行同步你在A上对C 的操作。至于Ipad上的同步，原理是一样。</p><h2 id="yskin说"><a href="#yskin说" class="headerlink" title="yskin说"></a>yskin说</h2><p>eDonkey2000（好吧，就是大家说的电驴）是这样实现的：把文件按固定大小分成几段，然后每段生成一个Hash码，然后再把所有Hash码合并成一个Hash码表，再对其生成一个Hash码，于是就成为了ed2k链接。下载的时候，先拿ed2k链接找人要到Hash码表，然后再根据码表分别下载每个片段。</p><p>Dropbox的增量同步也一样，每4M生成一个Hash码，然后更新的时候把码表和隐藏目录里存储的原码表做一下比较，发现1-10、12-20段都没有改变，只有11段不一样了，于是就只上传了第11段的数据。</p><h2 id="dunning说"><a href="#dunning说" class="headerlink" title="dunning说"></a>dunning说</h2><p>dropbox最初是采用了类似rsync的技术，但后来好像还是采用了Fix Sized Chunk进行。一个10MB的文档我曾经试过，修改1个字基本也有50%~70%左右的部分会被重新上传。</p><h1 id="疑问"><a href="#疑问" class="headerlink" title="疑问"></a>疑问</h1><p>是否有版本记录功能？跟git什么区别？</p><p>是否是增量同步？</p><p>如何解决冲突问题？</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li><a href="https://www.v2ex.com/t/35128" target="_blank" rel="noopener">Dropbox的同步方式是怎样的？ | v2ex</a></li><li><a href="https://www.zhihu.com/question/20501544" target="_blank" rel="noopener">云存储或笔记的增量同步是如何实现的？ | 知乎</a></li><li><a href="https://gist.github.com/9468305/fa8f1307ea4738225fca" target="_blank" rel="noopener">gist</a></li><li><a href="https://tech.meituan.com/incre-sync-use-rsync.html" target="_blank" rel="noopener">基于rsync的文件增量同步方案 | 美团</a></li><li><a href="https://blog.csdn.net/russell_tao/article/details/7240661" target="_blank" rel="noopener">详解rsync算法—如何减少同步文件时的网络传输量</a></li></ul>]]></content>
      
      <categories>
          
          <category> CS </category>
          
          <category> tools </category>
          
          <category> 同步与版本管理 </category>
          
          <category> 云存储-dropbox </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 同步 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>A星寻路算法</title>
      <link href="/pub/89d326d4/"/>
      <url>/pub/89d326d4/</url>
      <content type="html"><![CDATA[<p>很多游戏特别是rts，rpg类游戏，都需要用到寻路。寻路算法有深度优先搜索（DFS），广度优先搜索(BFS)，A星算法等，而A星算法是一种具备启发性策略的算法，效率是几种算法中最高的，因此也成为游戏中最常用的寻路算法。</p>]]></content>
      
      <categories>
          
          <category> Math </category>
          
          <category> 运筹学-动态规划 </category>
          
          <category> 常见问题 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>维特比算法</title>
      <link href="/pub/25fb7022/"/>
      <url>/pub/25fb7022/</url>
      <content type="html"><![CDATA[<p>动态规划</p><p>这是个递归问题<br>递归思想就是：把问题分解成规模更小，但和原问题有着相同解法的问题。<br>但是递归低效<br>递归：1-T的最优，依赖2-T最优,…依赖T-1到T的最优。但是T-1到T的最优是无法</p><h1 id="HMM-示例"><a href="#HMM-示例" class="headerlink" title="HMM 示例"></a>HMM 示例</h1><p>模型</p><h1 id="全连接-指数级-朴素递归法"><a href="#全连接-指数级-朴素递归法" class="headerlink" title="全连接 - 指数级 - 朴素递归法"></a>全连接 - 指数级 - 朴素递归法</h1><p>重复计算子问题</p><p><script src="https://www.gstatic.com/charts/loader.js"></script><script>function drawSimpleNodeChart(){var a=new google.visualization.arrayToDataTable([["id","childLabel","parent","ss",{role:"style"}],[0,"初始状态",-1,322,"black"],[1,"1",0,111,"black"],[2,"2",0,5,"black"],[3,"3",0,1,"blue"],[11,"1",1,1,"black"],[12,"2",1,1,"black"],[13,"3",1,1,"black"],[111,"1",11,1,"black"],[112,"2",11,1,"black"],[113,"3",11,1,"black"],[121,"1",12,1,"black"],[122,"2",12,1,"black"],[123,"3",12,1,"black"],[131,"1",13,1,"black"],[132,"2",13,1,"black"],[133,"3",13,1,"black"],[21,"1",2,1,"black"],[22,"2",2,1,"black"],[23,"3",2,1,"black"],[211,"1",21,1,"black"],[212,"2",21,1,"black"],[213,"3",21,1,"black"],[221,"1",22,1,"black"],[222,"2",22,1,"black"],[223,"3",22,1,"black"],[231,"1",23,1,"black"],[232,"2",23,1,"black"],[233,"3",23,1,"black"],[31,"1",3,1,"black"],[32,"2",3,1,"red"],[33,"3",3,1,"blue"],[311,"1",31,1,"black"],[312,"2",31,1,"black"],[313,"3",31,1,"black"],[321,"1",32,1,"black"],[322,"2  --- line1 贪婪路径",32,1,"red"],[323,"3",32,1,"black"],[331,"1",33,1,"black"],[332,"2",33,1,"black"],[333,"3  --- line0 全局最优路径",33,1,"blue"]]);new google.visualization.WordTree(document.getElementById("wordtree_explicit")).draw(a,{wordtree:{format:"explicit",type:"suffix"}})}google.charts.load("current",{packages:["wordtree"]}),google.charts.setOnLoadCallback(drawSimpleNodeChart)</script><div id="wordtree_explicit" style="width:900px;height:500px"></div></p><p>复杂度 ( O(N^{T}) )</p><h2 id="最优路径-维特比算法"><a href="#最优路径-维特比算法" class="headerlink" title="最优路径 - 维特比算法"></a>最优路径 - 维特比算法</h2><p><script src="https://www.gstatic.com/charts/loader.js"></script><script>function drawChart(){var n=new google.visualization.DataTable;n.addColumn("number","时间"),n.addColumn("number","line0"),n.addColumn({type:"string",role:"annotation"}),n.addColumn("number","line1"),n.addColumn({type:"string",role:"annotation"}),n.addColumn("number","line2"),n.addColumn({type:"string",role:"annotation"}),n.addColumn("number","line3"),n.addColumn({type:"string",role:"annotation"}),n.addColumn("number","line4"),n.addColumn({type:"string",role:"annotation"}),n.addColumn("number","line5"),n.addColumn({type:"string",role:"annotation"}),n.addColumn({type:"string",role:"legend"}),n.addRows([[1,3,"0.28",3,"",3,"",3,"",2,"0.16",1,"0.1","none"],[2,3,"0.42",2,"0.0504",2,"",1,"0.028",null,"",null,"","none"],[3,3,"0.0147",2,"0.01008",1,"0.00756",null,"",null,"",null,"","none"]]),new google.visualization.LineChart(document.getElementById("visualization")).draw(n,{legend:{position:"bottom"},pointSize:7,vAxis:{title:"状态",titleTextStyle:{fontName:"Times-Roman",bold:!0,italic:!1},ticks:[0,1,2,3],viewWindow:{max:4},maxValue:0},hAxis:{title:"时间",ticks:[1,2,3],viewWindow:{max:4},maxValue:0,gridlines:{color:"transparent",count:0}}})}google.charts.load("current",{packages:["corechart"]}),google.charts.setOnLoadCallback(drawChart),google.load("visualization","1",{packages:["corechart"]}),google.setOnLoadCallback(drawChart)</script><div id="visualization"></div></p><p>全局最优：line0<br>贪心算法会找到 line1</p><p>维特比是少计算了？剪枝了？还是并未少计算，只是复用了前面的计算结果？</p><p>维特比并未少计算，只是去除了冗余计算量而已</p><h1 id="剪枝算法"><a href="#剪枝算法" class="headerlink" title="剪枝算法"></a>剪枝算法</h1><p>剪枝前，</p><h1 id="k-best-维特比"><a href="#k-best-维特比" class="headerlink" title="k-best 维特比"></a>k-best 维特比</h1><p>通常的维特比算法，如果要取top-k最优路径，那么只能在最后一层取topk，前面默认只缓存top-1。</p><p>这样导致所取的top-k并非全局最优top-k。</p>]]></content>
      
      <categories>
          
          <category> ML </category>
          
          <category> machine learning 传统方法 </category>
          
          <category> supervised </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 动态规划 </tag>
            
            <tag> viterbi </tag>
            
            <tag> hmm </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>alpha-go</title>
      <link href="/pub/d3abacec/"/>
      <url>/pub/d3abacec/</url>
      <content type="html"><![CDATA[<p>占坑</p>]]></content>
      
      <categories>
          
          <category> ML </category>
          
          <category> applications </category>
          
          <category> Reinforcement Learning </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>启发式算法</title>
      <link href="/pub/aa8b4e3e/"/>
      <url>/pub/aa8b4e3e/</url>
      <content type="html"><![CDATA[<h1 id="说文解字"><a href="#说文解字" class="headerlink" title="说文解字"></a>说文解字</h1><p>Heuristic 启发式的；探索的。</p><ul><li>启发法(Heuristics):是凭经验的解题方法,也可称经验规则。</li></ul><p>人在解决问题时所采取的一种根据经验规则进行发现的方法。其特点是在解决问题时,<strong>利用过去的经验,选择已经行之有效的方法</strong>，而不是系统地、以确定的步骤去寻求答案</p><p><strong>看上去有点类似streaming</strong>，有点像markov</p><ul><li>特点:不能保证问题一定得到解决,但却常常有效解决问题。</li></ul><h1 id="来源-定位-在算法中的位置"><a href="#来源-定位-在算法中的位置" class="headerlink" title="来源 定位 在算法中的位置"></a>来源 定位 在算法中的位置</h1><p>决方法， 有2类， 分别是 确定方式和近似方式（ Exact Method， Approximate Method）</p><p>对于优化问题的解决方法， 有2类， 分别是 确定方式和近似方式（ Exact Method， Approximate Method）</p><p>对于优化问题.  根据条件，和限制， 可以描绘出一个解集空间（Solution Space）， 确定算法， 只可用在解集空间很小的问题， 但对于NP hard 问题， 可行时间内在个空间中找到 全局最优解（Global Optimum ） 的可能性很小 （ 几乎不可能）。 故需要使用近似算法（Approximate Method） 在有限时间内来寻找一个近似最优解。 近似方法分为两种 分别为 近似算法（Approximate Algorithms） 和启发式算法（ Heuristic Algorithms)。 近似算法通常可得到一个有质量保证的解。 然而 启发式算法通常可找到在传统解决问题的经验中找到寻求一种面向问题的策略， 之后用这种策略来在可行时间内寻找一个相对比较好的解，但对解的质量没有保证。</p><p><a href="https://www.zhihu.com/question/28874818/answer/67504126" target="_blank" rel="noopener">https://www.zhihu.com/question/28874818/answer/67504126</a></p><h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>启发式就是能快速出结果的算法，出来的结果一般是可用的，但是<strong>不能保证全局最优</strong>，也<strong>不能保证算法的完备性</strong>。全局最优容易理解，完备性是说能这个算法能不能找到所有的解，或者干脆判定此问题无解。</p><p>启发式方法（试探法）是一种帮你寻求答案的技术，但它给出的答案是具有偶然性的（subject to chance），因为启发式方法<strong>仅仅告诉你该如何去找</strong>，而没有告诉你要找什么。它并不告诉你该如何直接从A 点到达B 点，它甚至可能连A点和B点在哪里都不知道。实际上，启发式方法是穿着小丑儿外套的算法：它的结果不太好预测，也更有趣，但不会给你什么30 天无效退款的保证。</p><h1 id="启发式方法-VS-算法"><a href="#启发式方法-VS-算法" class="headerlink" title="启发式方法 VS 算法"></a>启发式方法 VS 算法</h1><p>启发式解决问题的方法是与算法相对立的。算法是把各种可能性都一一进行尝试，最终能找到问题的答案，但它是在很大的问题空间内，花费大量的时间和精力才能求得答案。启发式方法则是在<strong>有限的搜索空间内，大大减少尝试的数量，能迅速地达到问题的解决</strong>。但由于这种方法具有尝试错误的特点，所以也有失败的可能性。科学家的许多重大发现，常常是利用极为简单的启发式规则。</p><p>驾驶汽车到达某人的家，写成算法是这样的：沿167 号高速公路往南行至Puyallup；从South Hill Mall 出口出来后往山上开4.5 英里；在一个杂物店旁边的红绿灯路口右转，接着在第一个路口左转；从左边褐色大房子的车道进去，就是North Cedar 路714 号。</p><p>用启发式方法来描述则可能是这样：找出上一次我们寄给你的信，照着信上面的寄出地址开车到这个镇；到了之后你问一下我们的房子在哪里。这里每个人都认识我们——肯定有人会很愿意帮助你的；如果你找不到人，那就找个公共电话亭给我们打电话，我们会出来接你。</p><p>算法和启发式方法之间的差别很微妙，两个术语的意思也有一些重叠。就本书的目的而言，它们之间的差别就在于其距离最终解决办法的间接程度：算法直接给你解决问题的指导，而启发式方法则告诉你该如何发现这些指导信息，或者至少到哪里去寻找它们。</p><h1 id="ss"><a href="#ss" class="headerlink" title="ss"></a>ss</h1><p>对于优化问题.  根据条件，和限制， 可以描绘出一个解集空间（Solution Space）， 确定算法， 只可用在解集空间很小的问题， 但对于NP hard 问题， 可行时间内在个空间中找到 全局最优解（Global Optimum ） 的可能性很小 （ 几乎不可能）。 故需要使用近似算法（Approximate Method） 在有限时间内来寻找一个近似最优解。 近似方法分为两种 分别为 近似算法（Approximate Algorithms） 和启发式算法（ Heuristic Algorithms)。 近似算法通常可得到一个有质量保证的解。 然而 启发式算法通常可找到在传统解决问题的经验中找到寻求一种面向问题的策略， 之后用这种策略来在可行时间内寻找一个相对比较好的解，但对解的质量没有保证。</p><h2 id="启发式算法的发展"><a href="#启发式算法的发展" class="headerlink" title="启发式算法的发展"></a>启发式算法的发展</h2><p>启发式算法的计算量都比较大，所以启发式算法伴随着计算机技术的发展，取得了巨大的成就。</p><ul><li>40年代：由于实际需要，提出了启发式算法（快速有效）。</li><li>50年代：逐步繁荣，其中贪婪算法和局部搜索 等到人们的关注。</li><li>60年代: 反思，发现以前提出的启发式算法速度很快，但是解得质量不能保证，而且对大规 模的问题仍然无能为力（收敛速度慢）。</li><li>70年代：计算复杂性理论的提出，NP问题。许多实际问题不可能在合理的时间范围内找到全局最优解。发现贪婪算法和局部搜索算法速度快，但解不好的原因主要是他们只是在局部的区域内找解，等到的解没有全局最优性。由此必须引入新的搜索机制和策略………..Holland的遗传算法出现了（GEnetic Algorithm）再次引发了人们研究启发式算法的兴趣。</li><li>80年代以后：模拟退火算法（SiMUlated Annealing Algorithm），人工神经网络（Artificial Neural Network），禁忌搜索（Tabu Search）相继出现。</li><li>最近比较热或刚热过去的：演化算法（Evolutionary Algorithm）, 蚁群算法（Ant Algorithms）， 拟人拟物算法，量子算法等。</li></ul><p>　　各个算法的思想这就不再详细给出，为什么要引出启发式算法，因为NP问题，一般的经典算法是无法求解，或求解时间过长，我们无法接受。这里要说明的是：<strong>启发式算法得到的解只是近似最优解</strong>（近似到什么程度，只有根据具体问题才能给出）. 二十一世纪的最大的数学难题NP？=P，如果NP=P启发式算法就不在有存在的意义。</p><p>群体智能算法就是启发式算法；研究的重点就是如何<strong>平衡局部搜索与全局搜索</strong>；<strong>有效逃离局部最优解</strong>；</p><p>近几年比较活跃的算法有如下：</p><ul><li>仿动物类的算法：粒子群优化，蚂蚁优化，鱼群算法，蜂群算法等；</li><li>仿植物类的算法：向光性算法，杂草优化算法，等等；仿人类的算法有：</li><li>和声搜索算法是较好的算法；近年开始研究情感计算的人较多。</li></ul><p>实际应用时差分进化算法较有优势。关于粒子群算法，理论成熟，应用广泛。</p><p>Shi Cheng: 上面提到的算法，应该属于元启发式算法 meta-heuristics algorithms</p><h1 id="疑问"><a href="#疑问" class="headerlink" title="疑问"></a>疑问</h1><p>那，梯度下降是贪心算法吗？</p><h2 id="贪心算法是启发式算法吗？"><a href="#贪心算法是启发式算法吗？" class="headerlink" title="贪心算法是启发式算法吗？"></a>贪心算法是启发式算法吗？</h2><p>贪心算法是一种启发式算法，它企图寻求局部最优解，容易陷入局部最优的困境。</p><h2 id="梯度下降法也是启发式咯？"><a href="#梯度下降法也是启发式咯？" class="headerlink" title="梯度下降法也是启发式咯？"></a>梯度下降法也是启发式咯？</h2><p>启发式搜索与传统基于梯度信息的方法</p><h2 id="启发式搜索在机器学习优化中的研究有哪些？"><a href="#启发式搜索在机器学习优化中的研究有哪些？" class="headerlink" title="启发式搜索在机器学习优化中的研究有哪些？"></a>启发式搜索在机器学习优化中的研究有哪些？</h2><h2 id="什么算法不是启发式算法？"><a href="#什么算法不是启发式算法？" class="headerlink" title="什么算法不是启发式算法？"></a>什么算法不是启发式算法？</h2><p>启发式方法并不告诉你该如何直接从A 点到达B 点，而是仅仅告诉你该如何去找。<br>按照这个意思，梯度下降法、神经网络、<br>机器学习算法 是不是 基本都是启发式方法？</p><p>决策树不是启发式的吧，</p><h2 id="哪些机器学习算法-是启发式算法咯？"><a href="#哪些机器学习算法-是启发式算法咯？" class="headerlink" title="哪些机器学习算法 是启发式算法咯？"></a>哪些机器学习算法 是启发式算法咯？</h2><p>#</p><p>所以后来有了元启发式算法，如蚁群算法，模拟退火算法，禁忌算法等等，这类算法通过一些策略，某种程度上可以跳出局部最优解，从而寻求更好的全局最优解。</p><h1 id="各类启发式算法概述"><a href="#各类启发式算法概述" class="headerlink" title="各类启发式算法概述"></a>各类启发式算法概述</h1><p>优胜劣汰是大自然的普遍规律，它主要通过选择和变异来实现。选择是优化的基本思想，变异（多样化）是随机搜索或非确定搜索的基本思想。“优胜劣汰”是算法搜索的核心，根据“优胜劣汰”策略的不同，可以获得不同的超启发式算法。超启发式算法的主要思想来自于人类经过长期对物理、生物、社会的自然现象仔细的观察和实践，以及对这些自然现象的深刻理解，逐步向大自然学习，模仿其中的自然现象的运行机制而得到的。</p><ul><li>遗传算法：是根据生物演化，模拟演化过程中基因染色体的选择、交叉和变异得到的算法。在进化过程中，较好的个体有较大的生存几率。</li><li>模拟退火：是模拟统计物理中固体物质的结晶过程。在退火的过程中，如果搜索到好的解接受；否则，以一定的概率接受不好的解（即实现多样化或变异的思想），达到跳出局部最优解得目的。</li><li>神经网络：模拟大脑神经处理的过程，通过各个神经元的竞争和协作，实现选择和变异的过程。</li><li>禁忌搜索：模拟人的经验，通过禁忌表记忆最近搜索过程中的历史信息，禁忌某些解，以避免走回头路，达到跳出局部最优解的目的。</li><li>蚂蚁算法：模拟蚂蚁的行为，拟人拟物，向蚂蚁的协作方式学习。</li></ul><p>这几种超启发式算法都有一个共同的特点：从随机的可行初始解出发，才用迭代改进的策略，去逼近问题的最优解。他们的基本要素：</p><p>　　（1）随机初始可行解；</p><p>　　（２）给定一个评价函数（常常与目标函数值有关）；</p><p>　　（３）邻域，产生新的可行解；</p><p>　　（４）选择和接受解得准则；</p><p>　　（５）终止准则。</p><p>　　其中（４）集中反映了超启发式算法的克服局部最优的能力。</p><h1 id="启发式算法的不足和如何解决方法："><a href="#启发式算法的不足和如何解决方法：" class="headerlink" title="启发式算法的不足和如何解决方法："></a>启发式算法的不足和如何解决方法：</h1><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li><a href="https://tuotiansudai.com/cms/fund/jijingongsi/57939.html" target="_blank" rel="noopener">https://tuotiansudai.com/cms/fund/jijingongsi/57939.html</a></li><li><a href="http://www.cnblogs.com/p2pstream/archive/2009/04/09/1432270.html" target="_blank" rel="noopener">http://www.cnblogs.com/p2pstream/archive/2009/04/09/1432270.html</a></li></ul>]]></content>
      
      <categories>
          
          <category> Math </category>
          
          <category> 运筹学-动态规划 </category>
          
          <category> 启发式算法 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>路径搜索算法</title>
      <link href="/pub/9c2934f2/"/>
      <url>/pub/9c2934f2/</url>
      <content type="html"><![CDATA[<div class="table-container"><table><thead><tr><th>算法</th><th>en</th><th></th><th>简介</th><th>时间复杂度</th><th></th><th>全局最优解</th><th>缺陷</th><th>应用场合</th></tr></thead><tbody><tr><td>全搜索</td><td></td><td></td><td></td><td>( N^T )</td><td></td><td>√</td><td></td><td>指数级</td></tr><tr><td>维特比算法</td><td>Viterbi</td><td></td><td></td><td>T*N^2</td><td></td><td>√</td><td>深度T影响不大，N影响比较大。比如seq2seq中的N是词典大小。因此可采用近似算法</td><td>常用于HMM模型，分词、中文输入法</td></tr><tr><td>束搜索</td><td>beam search</td><td>属于贪心算法思想</td><td>beam search是一种启发式搜索，没有条件限制，都可以用，利用定义好的代价来剪枝，需要创建一个搜索树，因此每一个结点都与前面所有的父亲结点连接，生成很多结点在搜索树上，而DP是计算最优子问题的结果，保存在一个中间表中。</td><td>T<em>N</em>beam_size</td><td>当beam_size=N时，就是Viterbi算法</td><td>×</td><td></td><td>seq2seq，</td></tr><tr><td>贪心</td><td>greedy search</td><td></td><td></td><td>T*N</td><td></td><td>×</td><td></td></tr></tbody></table></div><h2 id="全局最优"><a href="#全局最优" class="headerlink" title="全局最优"></a>全局最优</h2><p>Viterbi算法</p><h2 id="近似算法"><a href="#近似算法" class="headerlink" title="近似算法"></a>近似算法</h2><ul><li>贪心，每一步都贪心。</li><li>束搜索（beam search）就是引入了类似贪心的策略（每一步都贪心的保留一部分当前最好的结果）</li></ul>]]></content>
      
      <categories>
          
          <category> Math </category>
          
          <category> 运筹学-动态规划 </category>
          
          <category> 常见问题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 动态规划 </tag>
            
            <tag> viterbi </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>星际争霸</title>
      <link href="/pub/af35b3a/"/>
      <url>/pub/af35b3a/</url>
      <content type="html"><![CDATA[<h1 id="游戏简介"><a href="#游戏简介" class="headerlink" title="游戏简介"></a>游戏简介</h1><p>三种种族，多兵种协同(海陆空)，包围、埋伏、<br>多地形(坡) 战争迷雾  金钱</p><h1 id="deep-mind-策略"><a href="#deep-mind-策略" class="headerlink" title="deep mind 策略"></a>deep mind 策略</h1><p>#</p><h1 id="计算机优势"><a href="#计算机优势" class="headerlink" title="计算机优势"></a>计算机优势</h1><p>apm高，即使计算机胜了，也并非表示策略更优。</p><p>所以需要在apm&lt;=人的情况下，与人公平竞争。</p><h1 id="缺陷"><a href="#缺陷" class="headerlink" title="缺陷"></a>缺陷</h1><p>现在的计算机，能耗太高。人只需要一碗饭。芯片能耗。</p>]]></content>
      
      <categories>
          
          <category> ML </category>
          
          <category> applications </category>
          
          <category> Reinforcement Learning </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>AlphaGo背后的搜索算法：蒙特卡罗树搜索</title>
      <link href="/pub/13c35f0b/"/>
      <url>/pub/13c35f0b/</url>
      <content type="html"><![CDATA[<p>深度学习 + 增强学习</p><h2 id="启发式算法"><a href="#启发式算法" class="headerlink" title="启发式算法"></a>启发式算法</h2><h2 id="蒙特卡洛树搜索"><a href="#蒙特卡洛树搜索" class="headerlink" title="蒙特卡洛树搜索"></a>蒙特卡洛树搜索</h2><p>“蒙特卡洛树搜索”是一种启发式的搜索策略，能够基于对搜索空间的随机抽样来扩大搜索树，从而分析围棋这类游戏中每一步棋应该怎么走才能够创造最好机会。</p><p>一位名叫苏椰的知乎用户举了这样一个例子，以通俗的语言进行了解释：假如筐里有100个苹果，让我每次闭眼拿1个，挑出最大的。于是我随机拿1个，再随机拿1个跟它比，留下大的，再随机拿1个……我每拿一次，留下的苹果都至少不比上次的小。拿的次数越多，挑出的苹果就越大，但我除非拿100次，否则无法肯定挑出了最大的。这个挑苹果的算法，就属于蒙特卡罗算法：尽量找好的，但不保证是最好的。</p><p>需要说明的是，蒙特卡罗树搜索并不是只有一种算法，而是一类算法。其中最流行的算法之一就是UCT（upper confidence bounds applied to trees）。</p><p>占坑</p><h2 id="alphago为什么不采用维特比算法？"><a href="#alphago为什么不采用维特比算法？" class="headerlink" title="alphago为什么不采用维特比算法？"></a>alphago为什么不采用维特比算法？</h2><p>因为alphago的路径搜索，跟markov不同。</p><p>markov有个状态转移矩阵，有限状态。围棋的状态空间太大，没办法用状态转移矩阵来衡量吧？</p><p>alpha-zero</p>]]></content>
      
      <categories>
          
          <category> ML </category>
          
          <category> applications </category>
          
          <category> Reinforcement Learning </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>肩周炎</title>
      <link href="/pub/29e204f7/"/>
      <url>/pub/29e204f7/</url>
      <content type="html"><![CDATA[<h1 id="什么是肩周炎"><a href="#什么是肩周炎" class="headerlink" title="什么是肩周炎"></a>什么是肩周炎</h1><p>又称粘连性肩关节囊炎</p><h1 id="如何鉴定肩周炎"><a href="#如何鉴定肩周炎" class="headerlink" title="如何鉴定肩周炎"></a>如何鉴定肩周炎</h1><h1 id="如何治疗"><a href="#如何治疗" class="headerlink" title="如何治疗"></a>如何治疗</h1><h1 id="如何保养"><a href="#如何保养" class="headerlink" title="如何保养"></a>如何保养</h1><p>黏连，就要解黏连。正确锻炼、拉伸</p><h1 id="最好有个打印版"><a href="#最好有个打印版" class="headerlink" title="最好有个打印版"></a>最好有个打印版</h1><h1 id="经典视频"><a href="#经典视频" class="headerlink" title="经典视频"></a>经典视频</h1><p>-</p>]]></content>
      
      <categories>
          
          <category> others </category>
          
          <category> 医疗 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>对比不同的loss funtion</title>
      <link href="/pub/8d871f23/"/>
      <url>/pub/8d871f23/</url>
      <content type="html"><![CDATA[<h1 id="分类-loss"><a href="#分类-loss" class="headerlink" title="分类 loss"></a>分类 loss</h1><p><img title="来自PRML 7.1.2" src="https://i.stack.imgur.com/MyUMt.png"></p><p><img src="http://scikit-learn.org/stable/_images/sphx_glr_plot_sgd_loss_functions_001.png"><br>参考 <a href="http://scikit-learn.org/stable/auto_examples/linear_model/plot_sgd_loss_functions.html" target="_blank" rel="noopener">http://scikit-learn.org/stable/auto_examples/linear_model/plot_sgd_loss_functions.html</a></p><h2 id="0-1-loss"><a href="#0-1-loss" class="headerlink" title="0-1 loss"></a>0-1 loss</h2><h2 id="logistic-loss"><a href="#logistic-loss" class="headerlink" title="logistic loss"></a>logistic loss</h2><h2 id="hinge-loss"><a href="#hinge-loss" class="headerlink" title="hinge-loss"></a>hinge-loss</h2><p>也叫SVM loss</p><p>max(0, 1-py)</p><p>h(x)=max(1−x,0)</p><h2 id="平滑的hinge-loss"><a href="#平滑的hinge-loss" class="headerlink" title="平滑的hinge-loss"></a>平滑的hinge-loss</h2><p>E = ln (1 + exp(−ty))</p><p>y log p</p><h1 id="回归-loss"><a href="#回归-loss" class="headerlink" title="回归 loss"></a>回归 loss</h1><h2 id="L1-对应拉普拉斯分布"><a href="#L1-对应拉普拉斯分布" class="headerlink" title="L1  对应拉普拉斯分布"></a>L1  对应拉普拉斯分布</h2><h2 id="MSE"><a href="#MSE" class="headerlink" title="MSE"></a>MSE</h2><p>L2  对应高斯分布</p><p>(p-y)^2</p><h2 id="RMSE"><a href="#RMSE" class="headerlink" title="RMSE"></a>RMSE</h2>]]></content>
      
      <categories>
          
          <category> ML </category>
          
          <category> machine learning 传统方法 </category>
          
          <category> loss function </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>反卷积 逆卷积(Deconvolution)  - CNN的逆过程</title>
      <link href="/pub/8e7b306/"/>
      <url>/pub/8e7b306/</url>
      <content type="html"><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>众所周知，神经网络分为<strong>有向网络</strong>，<strong>无向网络</strong>。典型的无向网络有CRF、Autoencoder、RBM等。由于Autoencoder和RBM是层级结构，也叫双向网络。这种是专门设计的双向网络，具有很好的理论依据(特别是RBM)。用的更多的网络，比如NN、CNN等都是单向网络。</p><h1 id="PGM"><a href="#PGM" class="headerlink" title="PGM"></a>PGM</h1><p><strong>理论好，实践弱</strong></p><p>概率图模型，又称有向图模型。<br>实际上我们是可以通过后验概率，计算图模型的反向。</p><p>但是</p><ol><li>PGM中的<strong>后验概率计算一般都很复杂</strong>，特别是对于深层PGM，要算很多层叠的微积分。没有</li><li>模型的求解难<ol><li>深层模型要用EM算法，</li><li>由于后验求不出来，大家就采用很多近似方法(比如变分)以及基于采样的方法。</li></ol></li></ol><p>得益于漂亮的理论基础，PGM也曾大放异彩，占领学术界和工业界高地。比如曾经风靡的HMM，LDA。涌现了Jordan Blei Daffni Ng一大批牛人。<br>但是PGM的深层扩展性较差，常见的比较深层的PGM就是Blei大神的LDA了。然而神经网络已经动不动上百层了。<br>随着大数据来临，PGM越来越力不从心，渐渐被神经网络取代。</p><h1 id="RBM"><a href="#RBM" class="headerlink" title="RBM"></a>RBM</h1><p><strong>理论漂亮</strong>，实践，大家还是用autoencoder，而不用RBM。</p><p>复杂性</p><h1 id="CRF"><a href="#CRF" class="headerlink" title="CRF"></a>CRF</h1><p>条件随机场，又叫概率无向图，</p><h1 id="NN"><a href="#NN" class="headerlink" title="NN"></a>NN</h1><p>首先我们来看一下，RBM和autoencoder是怎样可逆的？</p><h2 id="autoencoder"><a href="#autoencoder" class="headerlink" title="autoencoder"></a>autoencoder</h2><p><strong>强制学习双向的全连接参数W</strong>。</p><h2 id="deconv"><a href="#deconv" class="headerlink" title="deconv"></a>deconv</h2><p>神奇的CNN逆过程。</p><p>在我的世界观里，CNN是用来特征学习的，网络是单向的，特别是卷积层和pooling层是不可逆的。<br>然而竟然听说有deconv network。</p><p>实际上就是类似autoencoder的思想。</p><h3 id="反池化过程"><a href="#反池化过程" class="headerlink" title="反池化过程"></a>反池化过程</h3><h3 id="反激活"><a href="#反激活" class="headerlink" title="反激活"></a>反激活</h3><p>在Alexnet中，relu函数是用于保证每层输出的激活值都是正数，因此对于反向过程，我们同样需要保证每层的特征图为正值，也就是说这个反激活过程和激活过程没有什么差别，都是直接采用relu函数。</p><h3 id="反卷积"><a href="#反卷积" class="headerlink" title="反卷积"></a>反卷积</h3><p>信号里的卷积是不可逆的，比如高通滤波，难道还能把高频还原？显然是行不通的。</p><p>这里只是采用autoencoder的思想，<strong>强制学习双向的卷积kernel</strong>。</p><h3 id="反全连接"><a href="#反全连接" class="headerlink" title="反全连接"></a>反全连接</h3><h1 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h1><p>deconvolutional network相关文章，其实deconv的用处还挺广的，涉及到visualization/pixel-wiseprediction/unsupervised learning/image generation都会用到deconv的结构。比如Deconvolutional Network[1][2]做图片的unsupervised feature learning，ZF-Net论文中的卷积网络可视化[3]，FCN网络中的upsampling[4]，GAN中的Generative图片生成[5]。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li><a href="https://www.quora.com/How-does-a-deconvolutional-neural-network-work" target="_blank" rel="noopener">How does a deconvolutional neural network work? | Quora</a></li><li><a href="https://www.zhihu.com/question/43609045" target="_blank" rel="noopener">如何理解深度学习中的deconvolution networks？ | 知乎</a></li><li><a href="https://blog.csdn.net/hjimce/article/details/50544370" target="_blank" rel="noopener">可视化理解卷积神经网络 | CSDN</a></li></ul><p>Adaptive deconvolutional networks for mid and high level feature learning</p>]]></content>
      
      <categories>
          
          <category> ML </category>
          
          <category> deep learning </category>
          
          <category> model </category>
          
          <category> 生成模型 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 卷积 </tag>
            
            <tag> 反卷积 </tag>
            
            <tag> cnn </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>CNN网路结构可视化</title>
      <link href="/pub/4d880ede/"/>
      <url>/pub/4d880ede/</url>
      <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><h1 id="可视化方法"><a href="#可视化方法" class="headerlink" title="可视化方法"></a>可视化方法</h1><ul><li>传统CNN可视化<ul><li>对kernel可视化</li><li>对中间feature map可视化</li><li>对全连接weight可视化</li></ul></li><li>反卷积网络 可视化</li></ul><h1 id="传统CNN可视化"><a href="#传统CNN可视化" class="headerlink" title="传统CNN可视化"></a>传统CNN可视化</h1><h2 id="单层sparse-autoencoder在的可视化"><a href="#单层sparse-autoencoder在的可视化" class="headerlink" title="单层sparse autoencoder在的可视化"></a>单层sparse autoencoder在的可视化</h2><p>对autoencoder的参数W进行可视化。(训练数据STL-10)</p><p><img src="http://ufldl.stanford.edu/wiki/images/0/0f/Gabor.jpg" title="sparse autoencoder学习到的参数W" max-width="10px"></p><p>通过可视化可以看到，autoencoder学习到的参数类似边缘检测器(a set of edge detectors)<br>不同的隐藏单元学会了在图像的不同位置和方向进行边缘检测。</p><p>以上来自<a href="http://ufldl.stanford.edu/wiki/index.php/Exercise:Sparse_Autoencoder#Results" target="_blank" rel="noopener">ufldl</a></p><blockquote><p>这里sparse autoencoder是在图片8<em>8的patch上学习得到的，学到**参数W类似CNN中的8</em>8的卷积核**。因此UFLDL的教程中直接把w当做cnn的卷积核，效果也不错。</p></blockquote><h2 id="cnn的可视化"><a href="#cnn的可视化" class="headerlink" title="cnn的可视化"></a>cnn的可视化</h2><ul><li>传统CNN可视化的缺陷：<ul><li>传统CNN可视化的一个缺陷是，不能够还原图片，只能单向可视化。例如，给定一个hidden feature。</li></ul></li></ul><h1 id="反卷积网络-可视化"><a href="#反卷积网络-可视化" class="headerlink" title="反卷积网络 可视化"></a>反卷积网络 可视化</h1><p>反卷积网络与传统CNN网络采用同样的结构，只不过训练方法不同。反卷积网络采用非监督学习，类似autoencoder的思想。</p><p>这样</p><h2 id="deep-dream-详解"><a href="#deep-dream-详解" class="headerlink" title="deep dream 详解"></a>deep dream 详解</h2><p>见参考中的deep dream源码</p><p>#</p><h1 id="todo"><a href="#todo" class="headerlink" title="todo"></a>todo</h1><ul><li>可视化梯度消失、梯度爆炸</li><li>可视化ReLU对梯度消失的影响</li><li>可视化LSTM对梯度消失的影响</li></ul><p>借鉴deep-dream，可视化lstm</p><ul><li>lstm可视化 <a href="https://medium.com/asap-report/visualizing-lstm-networks-part-i-f1d3fa6aace7" target="_blank" rel="noopener">https://medium.com/asap-report/visualizing-lstm-networks-part-i-f1d3fa6aace7</a></li></ul><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>paper</p><ul><li><a href="https://arxiv.org/abs/1311.2901" target="_blank" rel="noopener">Visualizing and Understanding Convolutional Networks | 2014 Zeiler ECCV</a>  CNN领域可视化理解的开山之作<br>-</li></ul><p>博客</p><ul><li><a href="https://zhuanlan.zhihu.com/p/24833574" target="_blank" rel="noopener">Deep Visualization:可视化并理解CNN | 知乎</a></li><li><a href="https://distill.pub/2017/feature-visualization/" target="_blank" rel="noopener">feature-visualization | distill</a></li></ul><p>code</p><ul><li><a href="https://github.com/tensorflow/tensorflow/tree/master/tensorflow/examples/tutorials/deepdream" target="_blank" rel="noopener">deep-dream | tensorflow官方</a></li></ul>]]></content>
      
      <categories>
          
          <category> ML </category>
          
          <category> deep learning </category>
          
          <category> 可视化 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>图像风格迁移-Image Style Transfer</title>
      <link href="/pub/9fa270bc/"/>
      <url>/pub/9fa270bc/</url>
      <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>图片1中的内容 +  图片2中的风格 = 新图片</p><h2 id="难点"><a href="#难点" class="headerlink" title="难点"></a>难点</h2><ol><li>怎样提取出content信息？</li><li>怎样提取出style信息？</li><li>怎样融合content和style？</li></ol><p>大佬们围绕这几个点，绞尽脑汁，各显神通。</p><h2 id="核心思想"><a href="#核心思想" class="headerlink" title="核心思想"></a>核心思想</h2><h1 id="分解"><a href="#分解" class="headerlink" title="分解"></a>分解</h1><p>我们先从简单问题的入手，问题1看上去好像比较简单。</p><h2 id="怎样提取出content信息？"><a href="#怎样提取出content信息？" class="headerlink" title="怎样提取出content信息？"></a>怎样提取出content信息？</h2><h2 id="怎样提取出style信息？"><a href="#怎样提取出style信息？" class="headerlink" title="怎样提取出style信息？"></a>怎样提取出style信息？</h2><p>这几年CNN挺火，据说CNN的不同层能学习到不同级别的特征。是不是也能学习到style信息呢？带着这个疑问，我们先来看看CNN学到的是什么。</p><p><a href="https://distill.pub/2017/feature-visualization/" target="_blank" rel="noopener">https://distill.pub/2017/feature-visualization/</a></p><h2 id="细节"><a href="#细节" class="headerlink" title="细节"></a>细节</h2><p>网络的<strong>高层特征一般是关于输入图像的物体和布局等信息</strong>，<strong>低层特征一般表达输入图像的像素信息</strong>。也就是说在提取content特征时，不同层的表达效果是不一样的，本文在后面提取图像的content特征时采用高层特征。</p><h1 id="参考文献-发展史"><a href="#参考文献-发展史" class="headerlink" title="参考文献 | 发展史"></a>参考文献 | 发展史</h1><p>2015  A Neural Algorithm of Artistic Style<br>2016年的CVPR  Image Style Transfer Using Convolutional Neural Networks</p>]]></content>
      
      <categories>
          
          <category> ML </category>
          
          <category> applications </category>
          
          <category> vision </category>
          
          <category> style-transfer </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>exact inference</title>
      <link href="/pub/c9065739/"/>
      <url>/pub/c9065739/</url>
      <content type="html"><![CDATA[]]></content>
      
      <categories>
          
          <category> ML </category>
          
          <category> PGM </category>
          
          <category> bayesian-inference </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>分词</title>
      <link href="/pub/a388e785/"/>
      <url>/pub/a388e785/</url>
      <content type="html"><![CDATA[<div class="table-container"><table><thead><tr><th></th><th>简介</th><th>分句</th><th>用户词典</th><th>NER</th><th>新词识别</th><th>模型/算法</th><th>开源</th></tr></thead><tbody><tr><td>结巴分词</td><td></td><td></td><td></td><td></td><td></td><td></td><td><a href="https://github.com/fxsjy/jieba" target="_blank" rel="noopener">开源</a></td></tr><tr><td>哈工大LTP</td><td></td><td>根据中文标点里的句号、问号、感叹号、分号、省略号。</td><td></td><td></td><td></td><td></td><td><a href="https://github.com/HIT-SCIR/ltp" target="_blank" rel="noopener">C++</a></td></tr><tr><td>中科院NLPIR</td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>计算所ICTCLAS</td><td></td><td></td><td></td><td></td><td></td><td>CHMM(层叠形马尔可夫模型)。进行原子切分,然后在此基础上进行N-最短路径粗切分,找出前N个最符合的切分结果,生成二元分词表,然后生成分词结果,接着进行词性标注并完成主要分词步骤</td><td><a href="">C/C++</a></td></tr><tr><td>IKAnalyzer</td><td>轻量级</td><td></td><td></td><td></td><td></td><td>结合词典分词和文法分析算法</td><td><a href="">java</a></td></tr></tbody></table></div><p>参考</p><p><a href="https://www.zhihu.com/question/19578687" target="_blank" rel="noopener">https://www.zhihu.com/question/19578687</a></p>]]></content>
      
      <categories>
          
          <category> ML </category>
          
          <category> applications </category>
          
          <category> nlp </category>
          
          <category> 分词 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>mean field</title>
      <link href="/pub/8cd403b3/"/>
      <url>/pub/8cd403b3/</url>
      <content type="html"><![CDATA[<p>mean field method，一句话，就是后验概率用fully factorized approximation，即后验概率的每个维度都相互独立。见图MLAPP  P740</p><p>但是这一个假设太强，很多时候近似效果不好，因此采用structured mean field</p>]]></content>
      
      <categories>
          
          <category> ML </category>
          
          <category> PGM </category>
          
          <category> bayesian-inference </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>【数据分析篇】SemEval-2018-阅读理解</title>
      <link href="/pub/fdc2b2a8/"/>
      <url>/pub/fdc2b2a8/</url>
      <content type="html"><![CDATA[<p><a href="https://competitions.codalab.org/competitions/17184" target="_blank" rel="noopener">https://competitions.codalab.org/competitions/17184</a></p>]]></content>
      
      <categories>
          
          <category> ML </category>
          
          <category> applications </category>
          
          <category> nlp </category>
          
          <category> 阅读理解 </category>
          
          <category> dataset </category>
          
      </categories>
      
      
        <tags>
            
            <tag> dataset </tag>
            
            <tag> 数据分析 </tag>
            
            <tag> 阅读理解 </tag>
            
            <tag> SemEval </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>【数据分析篇】SNLI数据集</title>
      <link href="/pub/a1c27ad7/"/>
      <url>/pub/a1c27ad7/</url>
      <content type="html"><![CDATA[<link rel="stylesheet" href="/css/tag-chat.css"><p>Stanford自然语言推理(SNLI)数据集，全称The Stanford Natural Language Inference (SNLI) Corpus。</p><p><a href="https://nlp.stanford.edu/projects/snli/" target="_blank" rel="noopener">https://nlp.stanford.edu/projects/snli/</a></p><h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>SNLI1.0包含570，000的人工手写英文句子对。<br>针对 <code>推理前提</code>(premise)与<code>推理假设</code>(hypothesis)之间是否存在逻辑关系，人工标注了以下三种标签：</p><ul><li><a href="https://en.wikipedia.org/wiki/Entailment_(linguistics" target="_blank" rel="noopener"><strong>entailment</strong></a>) 蕴含、推理 \(p \Rightarrow h \)</li><li><a href="https://en.wikipedia.org/wiki/Contradiction" target="_blank" rel="noopener"><strong>contradiction</strong></a> 矛盾、对立   \(p \bot h \)</li><li><strong>neutral</strong> 中立、无关 \(p \nLeftrightarrow h \)</li></ul><p>用于自然语言推理 (Natural language inference,NLI), 也称为 (recognizing textual entailment, RTE)。</p><h1 id="数据"><a href="#数据" class="headerlink" title="数据"></a>数据</h1><h2 id="示例数据"><a href="#示例数据" class="headerlink" title="示例数据"></a>示例数据</h2><div class="table-container"><table><thead><tr><th>Text</th><th>Judgments</th><th>Hypothesis</th></tr></thead><tbody><tr><td>A man inspects the uniform of a figure in some East Asian country.</td><td>contradiction<br>C C C C C</td><td>The man is sleeping</td></tr><tr><td>An older and younger man smiling.</td><td>neutral<br>N N E N N</td><td>Two men are smiling and laughing at the cats playing on the floor.</td></tr><tr><td>A black race car starts up in front of a crowd of people.</td><td>contradiction<br>C C C C C</td><td>A man is driving down a lonely road.</td></tr><tr><td>A soccer game with multiple males playing.</td><td>entailment<br>E E E E E</td><td>Some men are playing a sport.</td></tr><tr><td>A smiling costumed woman is holding an umbrella.</td><td>neutral<br>N N E C N</td><td>A happy woman in a fairy costume holds an umbrella.</td></tr></tbody></table></div><p><code>snli_1.0/snli_1.0_train.jsonl</code>的第一行</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">   <span class="attr">"annotator_labels"</span>:[</span><br><span class="line">      <span class="string">"neutral"</span></span><br><span class="line">   ],</span><br><span class="line">   <span class="attr">"captionID"</span>:<span class="string">"3416050480.jpg#4"</span>,</span><br><span class="line">   <span class="attr">"gold_label"</span>:<span class="string">"neutral"</span>,</span><br><span class="line">   <span class="attr">"pairID"</span>:<span class="string">"3416050480.jpg#4r1n"</span>,</span><br><span class="line">   <span class="attr">"sentence1"</span>:<span class="string">"A person on a horse jumps over a broken down airplane."</span>,</span><br><span class="line">   <span class="attr">"sentence1_binary_parse"</span>:<span class="string">"( ( ( A person ) ( on ( a horse ) ) ) ( ( jumps ( over ( a ( broken ( down airplane ) ) ) ) ) . ) )"</span>,</span><br><span class="line">   <span class="attr">"sentence1_parse"</span>:<span class="string">"(ROOT (S (NP (NP (DT A) (NN person)) (PP (IN on) (NP (DT a) (NN horse)))) (VP (VBZ jumps) (PP (IN over) (NP (DT a) (JJ broken) (JJ down) (NN airplane)))) (. .)))"</span>,</span><br><span class="line">   <span class="attr">"sentence2"</span>:<span class="string">"A person is training his horse for a competition."</span>,</span><br><span class="line">   <span class="attr">"sentence2_binary_parse"</span>:<span class="string">"( ( A person ) ( ( is ( ( training ( his horse ) ) ( for ( a competition ) ) ) ) . ) )"</span>,</span><br><span class="line">   <span class="attr">"sentence2_parse"</span>:<span class="string">"(ROOT (S (NP (DT A) (NN person)) (VP (VBZ is) (VP (VBG training) (NP (PRP$ his) (NN horse)) (PP (IN for) (NP (DT a) (NN competition))))) (. .)))"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="疑问"><a href="#疑问" class="headerlink" title="疑问"></a>疑问</h2><div class="chatContent" id="chatContent"><div class="clearfix">  <div class="message others"> <div class="avatar" data-author-id="lj"> <img src="http://c1.mifile.cn/f/i/hd/2016051101/a-lj.png" alt="雷军"> </div> <div class="content"> <div class="bubble  bubble_default left"> <div class="bubble_cont"> <div class="plain"> <pre>为什么有好几个judgement？</pre> </div> </div> </div>  </div> </div>  </div><div class="clearfix">  <div class="message others"> <div class="avatar" data-author-id="lj"> <img src="http://c1.mifile.cn/f/i/hd/2016051101/a-lj.png" alt="雷军"> </div> <div class="content"> <div class="bubble  bubble_default left"> <div class="bubble_cont"> <div class="plain"> <pre>最终标签是综合了5个专家的意见，根据少数服从多数的原则得到的。</pre> </div> </div> </div>  </div> </div>  </div></div><p>还额外提供了句子的<strong>两种解析树</strong>表示。</p><p>自然语言推理（NLI）数据在构造的过程中存在一系列的人工模式，这种模式的直接后果是模型可以在不需要知道推理前提（premise）的条件下就可以以 67%的准确率判断推理假设（hypothesis）是否是蕴含（entailment）中立（neural）或对立（contradiction）</p><h1 id="数据统计-amp-分析"><a href="#数据统计-amp-分析" class="headerlink" title="数据统计 &amp;分析"></a>数据统计 &amp;分析</h1><div class="table-container"><table><thead><tr><th>premise</th><th>hypothesis</th><th>label</th><th></th></tr></thead><tbody><tr><td>a person on a horse jumps over a broken down airplane.</td><td>a person is <strong>training</strong> his horse for a <strong>competition</strong>.</td><td>neutral</td><td>原句没有体现training和competition</td></tr><tr><td>a person on a horse <strong>jumps</strong> over a broken down airplane.</td><td>a person is <strong>at a diner</strong>, ordering an omelette.</td><td>contradiction</td><td>这种关系，是否要借助外界数据？</td></tr><tr><td>a person on a horse jumps over a broken down airplane.</td><td>a person is <strong>outdoors</strong>, on a horse.</td><td>entailment</td><td></td></tr><tr><td>children smiling and waving at camera</td><td>they are smiling at their <strong>parents</strong></td><td>neutral</td><td></td></tr><tr><td>children smiling and waving at camera</td><td><strong>there are</strong> children present</td><td>entailment</td><td>there are属于stop word，最好。但是又要和there are not相反</td></tr><tr><td>children <strong>smiling</strong> and waving at camera</td><td>the kids are <strong>frowning</strong></td><td>contradiction</td><td></td></tr><tr><td>a boy is jumping <strong>on</strong> skateboard in the <strong>middle of a red bridge</strong>.</td><td>the boy skates <strong>down</strong> the sidewalk.</td><td>contradiction</td><td></td></tr><tr><td>a boy is jumping on skateboard in the middle of a red bridge.</td><td>the boy does a skateboarding trick.</td><td>entailment</td><td></td></tr><tr><td>a boy is jumping on skateboard in the middle of a red bridge.</td><td>the boy is wearing safety equipment.</td><td>neutral</td><td></td></tr><tr><td>an older man sits with his orange juice at a small table in a coffee shop while employees in bright colored shirts smile in the background.</td><td>an older man drinks his juice as he waits for his daughter to get off work.</td><td>neutral</td><td></td></tr><tr><td>an older man sits with his orange juice at a small table in a coffee shop while employees in bright colored shirts smile in the background.</td><td>a boy flips a burger.</td><td>contradiction</td><td></td></tr><tr><td>an older man sits with his orange juice at a small table in a coffee shop while employees in bright colored shirts smile in the background.</td><td>an elderly man sits in a small shop.</td><td>neutral</td><td></td></tr><tr><td>two blond women are hugging one another.</td><td>some women are hugging on vacation.</td><td>neutral</td><td></td></tr><tr><td>two blond women are hugging one another.</td><td>the women are sleeping.</td><td>contradiction</td><td></td></tr><tr><td>two blond women are hugging one another.</td><td>there are women showing affection.</td><td>entailment</td><td></td></tr><tr><td>a few people in a restaurant setting, one of them is drinking orange juice.</td><td>the people are eating omelettes.</td><td>neutral</td><td></td></tr><tr><td>a few people in a restaurant setting, one of them is drinking orange juice.</td><td>the people are sitting at desks in school.</td><td>contradiction</td><td></td></tr><tr><td>a few people in a restaurant setting, one of them is drinking orange juice.</td><td>the diners are at a restaurant.</td><td>entailment</td><td></td></tr><tr><td>an older man is drinking orange juice at a restaurant.</td><td>a man is drinking juice.</td><td>entailment</td><td></td></tr><tr><td>an older man is drinking orange juice at a restaurant.</td><td>two women are at a restaurant drinking wine.</td><td>contradiction</td></tr></tbody></table></div><ul><li>premis比较具体，hyposies 简洁，抽象(比如male抽象成man，苹果抽象成苹果)</li><li>contradiction通常有反义词，比如 up down</li></ul><h1 id="数据读取"><a href="#数据读取" class="headerlink" title="数据读取"></a>数据读取</h1>]]></content>
      
      <categories>
          
          <category> ML </category>
          
          <category> applications </category>
          
          <category> nlp </category>
          
          <category> entailment </category>
          
          <category> dataset </category>
          
      </categories>
      
      
        <tags>
            
            <tag> dataset </tag>
            
            <tag> 数据分析 </tag>
            
            <tag> entailment </tag>
            
            <tag> 自然语言推理 </tag>
            
            <tag> SNLI </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>前后端渲染之争</title>
      <link href="/pub/5a71ae7b/"/>
      <url>/pub/5a71ae7b/</url>
      <content type="html"><![CDATA[<h1 id="前台渲染"><a href="#前台渲染" class="headerlink" title="前台渲染"></a>前台渲染</h1><ul><li>mathjax.js</li><li>angualr</li><li>vue<br>-</li></ul><h1 id="后台渲染"><a href="#后台渲染" class="headerlink" title="后台渲染"></a>后台渲染</h1><ul><li>python flask，django</li><li>java jsp<br>-</li></ul><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li>[精读前后端渲染之争 | 知乎]<a href="https://zhuanlan.zhihu.com/p/26366128" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/26366128</a></li><li><a href="https://medium.freecodecamp.org/heres-why-client-side-rendering-won-46a349fadb52" target="_blank" rel="noopener">Here’s Why Client-side Rendering Won | freecodecamp</a> | <a href="https://zhuanlan.zhihu.com/p/26252147" target="_blank" rel="noopener">中文翻译</a></li><li><a href="https://github.com/dt-fe/weekly/issues/5" target="_blank" rel="noopener">前后端渲染之争</a></li><li><a href="https://www.zhihu.com/question/28725977" target="_blank" rel="noopener">后端渲染html、前端模板渲染html，jquery的html，各有什么区别？</a></li></ul>]]></content>
      
      <categories>
          
          <category> CS </category>
          
          <category> web </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>【数据分析篇】百度竞赛 - 2018 - 阅读理解</title>
      <link href="/pub/2c3a2229/"/>
      <url>/pub/2c3a2229/</url>
      <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><ul><li><a href="http://mrc2018.cipsc.org.cn/" target="_blank" rel="noopener">竞赛主页 http://mrc2018.cipsc.org.cn</a></li><li><a href="http://ai.baidu.com/broad/introduction?dataset=dureader" target="_blank" rel="noopener">数据下载</a></li></ul><p>百度阅读理解数据集 DuReader是迄今为止规模最大的中文公开领域阅读理解数据集。数据集基于真实应用需求，所有问题都来源于百度搜索用户的真实问题，文档来自全网真实采样的网页文档和百度知道 UGC 文档，答案基于问题与文档由人工撰写生成。数据集标注了问题类型、实体和观点等丰富信息，弥补了现有主流数据集对于观点类问题覆盖不足的问题。首批发布的阅读理解数据集包含20万问题、100万文档及42万人工撰写的优质答案，并提供开源基线系统。DuReader 将为阅读理解技术研究提供有力支撑，希望加速相关技术和应用的发展。</p><ul><li><p>室外场景理解数据集是世界范围内第一个带像素级语义标签的室外3D图像数据，来源于百度自动驾驶事业部。该数据集试图将感知能力从物体级感知升级到像素级感知，进而了解图片中所有像素的属性和来源，目标实现更精准、安全的自动驾驶。</p></li><li><p>视频精彩片段数据集主要来源于爱奇艺。视频类型为综艺节目，目前囊括近1500个长视频，视频总时长约1200小时，还从中手动收取出18000个精彩小视频，同时能够提供视频帧的图片特征序列，是全球首创的公开精彩片段标注数据集。</p></li></ul><h2 id="数据样例-1"><a href="#数据样例-1" class="headerlink" title="数据样例 1"></a>数据样例 1</h2><p><code>raw/trainset/zhidao.train.json</code></p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#123;</span></span><br><span class="line"><span class="attr">"documents":</span> <span class="string">[</span></span><br><span class="line">  <span class="string">&#123;</span></span><br><span class="line"><span class="attr">    "bs_rank_pos":</span> <span class="number">1</span><span class="string">,</span></span><br><span class="line"><span class="attr">    "is_selected":</span> <span class="literal">false</span><span class="string">,</span></span><br><span class="line"><span class="attr">    "paragraphs":</span> <span class="string">[</span></span><br><span class="line">      <span class="string">"VPN技术对机构和很多远程用户来说，是极端有用的，但在设定上，它可能有些复杂。下面的指南将手把手的教你如何建立VPN，它包含各个步骤详细的操作流程。    第一步：系统需求    VPN分为两种，一种是硬件解决方案，一种是软件解决方案，在这个手把手的指南中，我将介绍一种软件解决方案，即使用Microsoft产品建立VPN.    为了架设VPN，你将需要三个独立的Windows 2003服务器和至少一个远程用户，远程用户的机器上需要运行Windows XP操作系统。    你的VPN需要的第一台Windows 2003服务器是一台基本的基础设施服务器，它必须作为一台域控制器（domain controller），DHCP服务器（DHCP server），DNS服务器（DNS Server）和认证中心（certificate authority）。如果你的网络中已经有一台Windows 2003服务器，你就不需要去购买一台服务器担当此角色。    任何Windows 2003域都至少有一台域控制器和一台作为DNS的服务器，多数Windows 2003网络同时运行DHCP服务。如果你所有的这些服务已经到位，你所关心的唯一的事情就是设置一个认证中心（我将在第三步为你说明如何做这件事情）。下载，你只需知道作为认证中心的那台服务器必需运行Windows Server 2003 Enterprise Edition操作系统。    你需要的第二台服务器将是VPN服务器（VPN server），Windows Server 2003 Standard Edition和Enterprise Edition都提供了VPN服务器的必要软件，因此，你不需要在这台服务器上安装任何特别的软件。唯一特别的是硬件上，这台服务器需要双网卡，一块网卡连接Internet，另一块网卡则连接你的专用企业网络。   第二步：实施DHCP服务    1.打开服务器的控制面板，选择“添加或删除程序”。    2.当“添加或删除程序”对话框出现时，点击“添加/删除Windows组件”按钮。    3.在弹出的窗口中，选择“网络服务”，按下“详细信息”。    4.现在从网络服务列表中选择“动态主机配置协议（DHCP）”，然后单击“确定”，进行下一步操作。    Windows现在将安装DHCP服务，安装结束后，你将要创建一个地址范围，并且启动DHCP服务器，在你的网络上运行。    5.为了做到这些，请在控制面板――管理工具中选择动态主机配置协议（DHCP）配置，打开DHCP管理器。    6.在DHCP管理器中你的服务器上单击右键，选择启动（Authorize）。    7.启动DHCP服务器后，在DHCP管理器的服务器列表窗口中单击右键，选择“新建作用域（New Scope）”，这将启动新建作用域向导。    8.点击下一步略过向导的欢迎界面。    9.输入你正在创建的作用域的名称，并且点击下一步。（你可以输入任何你想到的名称，但在这个教程中，我将命名此作用域为“Corporate Network”。）    10.现在你将需要填入IP地址范围。在这里只需输入你已经使用的起始IP地址和结束IP地址，但注意不要与已经存在的IP地址冲突。长度和子网掩码部分则会自动输入，不需要你的干涉，当然，你也可以手动调节这两者的值。    11.接下来的三个画面包括一些你不必关心的设置，连续三次点击下一步，直到你进入“路由（默认网关）（Router （Default Gateway））”界面。    12.输入你网络网关的IP地址，点击添加，然后下一步。    13.输入你的域的名称和你的DHCP服务器的IP地址（IP address of your DHCP server），然后点击下一步。    14.单击下一步略过WINS配置窗口。    15.最后，根据提示选“是，我想激活作用域（Yes， I Want To Activate The Scope Now）”再点击“完成”即可结束最后设置。        第三步：创建一个企业认证中心    在我向你讲述如何创建一个企业认证中心之前，我将告诉你几个必需注意的事项。安装认证中心并不是一个轻松的过程，如果一个未经授权的用户进入了你的认证中心，他将几乎控制你的所有网络。同样，如果认证中心服务器当机，它可能对给你的网络带来毁灭性的破坏。    所以，一定要像保护原子弹一样保护你的认证中心，确保认证中心尽可能的安全，并频繁的做好全系统的备份，你还需要保护这些备份，以防止它们偶然地出现问题。下面是创建企业认证中心的具体过程。"</span></span><br><span class="line">    <span class="string">],</span></span><br><span class="line"><span class="attr">    "title":</span> <span class="string">"如何架设vpn服务器"</span></span><br><span class="line">  <span class="string">&#125;,</span></span><br><span class="line">  <span class="string">&#123;</span></span><br><span class="line"><span class="attr">    "bs_rank_pos":</span> <span class="number">2</span><span class="string">,</span></span><br><span class="line"><span class="attr">    "is_selected":</span> <span class="literal">true</span><span class="string">,</span></span><br><span class="line"><span class="attr">    "paragraphs":</span> <span class="string">[</span></span><br><span class="line">      <span class="string">"步骤：1、点击开始，依次点击程序、管理工具、路由和远程访问，打开后右键你的主机名，选择\"配置和启用。2、选择\"自定义配置，下一步，选上\"VPN访问，下一步、完成、然后启动服务3、打开IP路由选择，在常规上面按右键选择\"新增路由协议，选择\"NAT/基本防火墙。4、在新显示的NAT/基本防火墙上面按右键，选择\"新增接口\"，然后选择你的网络连接(一般是\"本地连接\")连接的属性里面选择\"公用接口连接到INTERNET\".选上\"在此接口启用NAT\".然后确定。5、设置用户部分在WINDOWS的用户和组里面新建用户，给新用户配置远程拨入的权限，(在用户的属性里面默认是按策略设置，改为\"允许访问\")、建立完成。"</span><span class="string">,</span></span><br><span class="line">      <span class="string">"占坑关注"</span><span class="string">,</span></span><br><span class="line">      <span class="string">"你说的PC Anywhere只是一个远程监控软件啊！我不知道你是想远程控制家里的机器还是想将公司的机器和家里的机器连成一个局域网的类型？VPN是个虚拟专网，可以用windows server 系统来直接完成不需要装别的软件！这个阿~我先写吧，太复杂了！不是一句两句能说清楚的！你看一下这个，很详细，而且图文并茂~http://blog.sina.com.cn/u/494f9a6b0100052l"</span><span class="string">,</span></span><br><span class="line">      <span class="string">"&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; Windows 7下架设VPN服务器的5大步骤：&lt;/p&gt;&lt;p&gt;&amp;nbsp;&lt;/p&gt;&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; 1、打开“网络和共享中心”，选择“更改适配器设置”&lt;/p&gt;&lt;p&gt;&lt;img src=\"28765673001\" /&gt;&lt;/p&gt;&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; 这里快速打开网络和共享中心&lt;/p&gt;&lt;p&gt;&lt;img src=\"28765660417\" /&gt;&lt;/p&gt;&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; 2、在“菜单栏”点击“文件”，然后选择“新建传入连接”&lt;/p&gt;&lt;p&gt;&lt;img src=\"28765674840\" /&gt;&lt;/p&gt;&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; 3、选择允许使用VPN连接到本机的帐户，可以从列表中勾选，也可以“添加用户”&lt;/p&gt;&lt;p&gt;&lt;img src=\"28765665635\" /&gt;&lt;/p&gt;&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; 选择允许VPN连接到本机的账户&lt;/p&gt;&lt;p&gt;&lt;img src=\"28765699912\" /&gt;&lt;/p&gt;&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; 接下来选择其他用户连接VPN的方式，一般来说是选择“通过Internet”。当然，如果显示的连接方式是多项的话，那么请根据需要请选择正确的方式。&lt;/p&gt;&lt;p&gt;&amp;nbsp;&lt;/p&gt;&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; 4、这一步就到了设置网络参数环节了，如果对方连接后可以使用本地网络的DHCP服务器，那么可以跳过此设置。如果本地网络没有DHCP服务器的话就要先进行一下设置了，具体步骤如下：&lt;/p&gt;&lt;p&gt;&lt;img src=\"28765716220\" /&gt;&lt;/p&gt;&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; 选中“Internet 协议版本 4(TCP/IP)”， 点击“属性”按钮，选择“指定IP地址”（这里是根据用户自身的IP地址而设定，设置一个没有被使用的IP段即可），设置后请按确定， 然后点击“允许访问”就大功告成了。&lt;/p&gt;&lt;p&gt;&amp;nbsp;&lt;/p&gt;&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; 5、到这里VPN服务器已经架设完毕了，其他用户已经可以利用上面的帐号以及设置的IP地址通过VPN连接到网络了。&lt;/p&gt;&lt;p&gt;&amp;nbsp;&lt;/p&gt;&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; 关于防火墙和内网用户的两点特别说明：&lt;/p&gt;&lt;p&gt;&amp;nbsp;&lt;/p&gt;&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; 1、如果你有防火墙请允许1723和1701端口。&lt;/p&gt;&lt;p&gt;&amp;nbsp;&lt;/p&gt;&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; 2、如果是内网用户请在路由器上做1723和1701端口的映射，一般做1723就行了。&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;/p&gt;"</span></span><br><span class="line">    <span class="string">],</span></span><br><span class="line"><span class="attr">    "title":</span> <span class="string">"vpn服务器如何建立"</span></span><br><span class="line">  <span class="string">&#125;,</span></span><br><span class="line">  <span class="string">&#123;</span></span><br><span class="line"><span class="attr">    "bs_rank_pos":</span> <span class="number">3</span><span class="string">,</span></span><br><span class="line"><span class="attr">    "is_selected":</span> <span class="literal">false</span><span class="string">,</span></span><br><span class="line"><span class="attr">    "paragraphs":</span> <span class="string">[</span></span><br><span class="line">      <span class="string">"在Windows服务器上架设VPN可以如下操作：第一步，打开控制面板-&gt;管理工具-&gt;服务项目，禁用Windows防火墙服务。第二步，打开控制面板-&gt;管理工具，双击“路由和远程访问”。然后右键点击服务器图标，再点击“配置并启用路由和远程访问”。第三步，在“路由和远程服务器安装向导”中，选择“自定义配置”。第四步，勾选“VPN访问”和“NAT和基本防火墙”。第五步， 点击“完成”。系统提示“要开始服务吗？”，选择“是”。第六步，接下来开始配置路由和远程访问，我们先点击本地服务旁边的+按钮，把左侧菜单展开，再点击IP路由选择旁边的+按钮。第七步，下面配置静态IP地址。右键点击本地服务，点击属性，再点击IP选项卡。第八步，点选“静态地址池”，点击“添加”。输入一个起始IP地址和结束IP地址范围，推荐输入192.168.1.100到192.168.1.254这个范围，因为192.168段属于本地保留IP段。最后点击“确定”。第九步，右键点击“静态路由”，再点击“新建静态路由”。第十步，目标和网络掩码都输入0，网关请和TCP/IP属性中的默认网关保持一致。第十一步，删除“DHCP中继代理程序”中的“内部”项目。第十二步，然后右键点击“DHCP中继代理程序”，再点击“新增接口”。第十三步，选择“本地连接”，再点击“确定”，然后在弹出的对话框中点击“确定”。第十四步，右键点击“NAT/基本防火墙”，再点击“新增接口”，然后选择“本地连接”，点击“确定”。第十五步，在弹出的对话框中先点选“公共接口连接到Internet”，再勾选“在此接口上启用NAT”，最后点击“确定”。第十六步，至此在路由和远程访问中的配置就完成了。下面是添加VPN用户的步骤，到计算机管理中添加一个用户，作为VPN连接的用户，把这个用户放到Guest组下面，并在用户属性-&gt;拨入-&gt;远程访问权限中设置成“允许访问”。 然后就是在你自己电脑上新建VPN连接，进行拨号测试了。要确定是否连接成功，请访问IP查询网站，看是否显示的是国外服务器的IP即可。"</span><span class="string">,</span></span><br><span class="line">      <span class="string">"详细设置方法你可以参考酷盛帮助中心里面的图文攻略。"</span></span><br><span class="line">    <span class="string">],</span></span><br><span class="line"><span class="attr">    "title":</span> <span class="string">"如何在自己电脑上搭建vpn服务器"</span></span><br><span class="line">  <span class="string">&#125;,</span></span><br><span class="line">  <span class="string">&#123;</span></span><br><span class="line"><span class="attr">    "bs_rank_pos":</span> <span class="number">4</span><span class="string">,</span></span><br><span class="line"><span class="attr">    "is_selected":</span> <span class="literal">true</span><span class="string">,</span></span><br><span class="line"><span class="attr">    "paragraphs":</span> <span class="string">[</span></span><br><span class="line">      <span class="string">"1、看路由器里面带不带VPN功能，如果有可以直接在路由器里面设置VPN，当然你可以去买一个带有VPN功能的路由器；2、用windows server系统架构一个VPN！不过家里需要是静态IP地址！"</span></span><br><span class="line">    <span class="string">],</span></span><br><span class="line"><span class="attr">    "title":</span> <span class="string">"公司要建vpn服务器,该怎么搭建"</span></span><br><span class="line">  <span class="string">&#125;,</span></span><br><span class="line">  <span class="string">&#123;</span></span><br><span class="line"><span class="attr">    "bs_rank_pos":</span> <span class="number">5</span><span class="string">,</span></span><br><span class="line"><span class="attr">    "is_selected":</span> <span class="literal">true</span><span class="string">,</span></span><br><span class="line"><span class="attr">    "paragraphs":</span> <span class="string">[</span></span><br><span class="line">      <span class="string">"XP本身就可以做VPN的 不过只能支持一个用户。"</span><span class="string">,</span></span><br><span class="line">      <span class="string">"第一，申请ddns，比如3322.org、花生壳什么的，让其他人能够通过动态域名找到你，因为使用adsl等拨号软件时，每次拨号ip地址都会变动，总不能每次都人工通知人家你ip地址是什么吧；第二，路由器中配ddns账号、域名等信息，让路由器自动通知整个互联网，你申请的域名现在的ip地址是多少；第三，路由器中配端口转发，你vpn要使用哪个端口就设定进去，这样当别人访问路由器这个端口时，你在路由器中就可以指定转发到那台机器，例如80端口指定到192.168.1.2（你在上面放www网站），3389端口指定到192.168.1.10（例如做为管理机器）上，你就可以用远程桌面连接到这台机器，8080端口指定到192.168.1.5（例如放BBS论坛），你就通过你申请的域名http://sdf.3322.org:8080访问到BBS论坛了。你家里面路由器后面的VPN想开什么服务，把端口转发设定一下即可。"</span><span class="string">,</span></span><br><span class="line">      <span class="string">"上面不是有XP的教程么，我就把Win7的教程给你写一份，你都可以试试。 1.右键点击桌面的“网络”-&gt;“属性”后出现  2.单击“设置新的连接或网络”出现 3.选种“连接到工作区”点下一步。 4.单击“使用我的Internet连接（VPN）”，马上就转跳到5.在“Internet 地址（I）”填上VPN提供的IP地址，再下一步6.这里是填VPN的用户名和密码，点“连接”7.到这里就完成的连接设置导向。点击“关闭”。8.回到桌面右键点击“网络”-&gt;“属性” 9.点击一下左边的“更改适配器设置”。10.找到我们刚才建好的“VPN 连接”双击打开。11.填上VPN提供的VPN用户名和密码，“域”可以不用填写。12.整个Windows7 VPN过程都设置完成了。现在点击“连接（C）”就可以上游戏、上网冲浪了、浏览网页了  还有不明白的可以联系幺五幺二五零八四试试，这个网站的教程比较全面"</span><span class="string">,</span></span><br><span class="line">      <span class="string">"&lt;p&gt;&lt;img src=\"37250702446\" /&gt;&lt;/p&gt;"</span></span><br><span class="line">    <span class="string">],</span></span><br><span class="line"><span class="attr">    "title":</span> <span class="string">"家用vpn服务器如何搭建"</span></span><br><span class="line">  <span class="string">&#125;</span></span><br><span class="line"><span class="string">],</span></span><br><span class="line"><span class="attr">"question":</span> <span class="string">"如何搭建vpn服务器"</span><span class="string">,</span></span><br><span class="line"><span class="attr">"answers":</span> <span class="string">[</span></span><br><span class="line">  <span class="string">"1、打开“网络和共享中心”，选择“更改适配器设置”2、在“菜单栏”点击“文件”，然后选择“新建传入连接”3、选择允许使用VPN连接到本机的帐户，可以从列表中勾选，也可以“添加用户”4、这一步就到了设置网络参数环节了，如果对方连接后可以使用本地网络的DHCP服务器，那么可以跳过此设置。如果本地网络没有DHCP服务器的话就要先进行一下设置了。5、到这里VPN服务器已经架设完毕了，其他用户已经可以利用上面的帐号以及设置的IP地址通过VPN连接到网络了。"</span><span class="string">,</span></span><br><span class="line">  <span class="string">"1、看路由器里面带不带VPN功能，如果可以就直接在路由器里面设置VPN，也可以买带VPN功能路由器；2、用windows server系统架构一个VPN。"</span><span class="string">,</span></span><br><span class="line">  <span class="string">"家用：第一，申请ddns，比如3322.org、花生壳什么的，让其他人能够通过动态域名找到；第二，路由器中配ddns账号、域名等信息，让路由器自动通知整个互联网，申请的域名现在的ip地址是多少；第三，路由器中配端口转发，vpn要使用哪个端口就设定进去，这样当别人访问路由器这个端口时，在路由器中就可以指定转发到那台机器，最后路由器后面的VPN想开什么服务，把端口转发设定一下即可。"</span></span><br><span class="line"><span class="string">],</span></span><br><span class="line"><span class="attr">"question_type":</span> <span class="string">"DESCRIPTION"</span><span class="string">,</span></span><br><span class="line"><span class="attr">"fact_or_opinion":</span> <span class="string">"FACT"</span><span class="string">,</span></span><br><span class="line"><span class="attr">"question_id":</span> <span class="number">91210</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure><h2 id="数据样例2"><a href="#数据样例2" class="headerlink" title="数据样例2"></a>数据样例2</h2><p><code>raw/trainset/search.train.json</code><br><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#123;</span></span><br><span class="line"><span class="attr">"documents":</span> <span class="string">[</span></span><br><span class="line">  <span class="string">&#123;</span></span><br><span class="line"><span class="attr">    "bs_rank_pos":</span> <span class="number">0</span><span class="string">,</span></span><br><span class="line"><span class="attr">    "is_selected":</span> <span class="literal">true</span><span class="string">,</span></span><br><span class="line"><span class="attr">    "paragraphs":</span> <span class="string">[</span></span><br><span class="line">      <span class="string">"导读:绣眉有哪几种方法?小编带来绣眉的基本方法,喜欢绣眉的MM看看吧。"</span><span class="string">,</span></span><br><span class="line">      <span class="string">"绣眉可以让MM的五官看起来更加的清秀有立体感,绣眉有哪几种方法?绣眉的基本方法分享给大家。"</span><span class="string">,</span></span><br><span class="line">      <span class="string">"绣眉有哪几种方法?"</span><span class="string">,</span></span><br><span class="line">      <span class="string">"绣眉的五种基本方法:"</span><span class="string">,</span></span><br><span class="line">      <span class="string">"1、雕润眉 2、平面绣眉 3、点状绣眉 4、立体绣眉"</span><span class="string">,</span></span><br><span class="line">      <span class="string">"5、仿真立体绣眉"</span><span class="string">,</span></span><br><span class="line">      <span class="string">"绣眉的基本方法:"</span><span class="string">,</span></span><br><span class="line">      <span class="string">"1、雕润眉 雕润眉是完美医学纹绣为载体,根据人的眉毛生长而雕刻出来的眉形,根据肤色来选料,这样的眉形看起来很靓丽好看,与传统的绣眉方法相比,雕润眉是如丝发般的精细雕刻眉毛,具有三维立体感,而且纹眉后不痛不肿,不脱色,不变色,不晕色,一般半个小时就能完成的绣眉。》》》99.99%人都关注的绣眉结痂问题 2、平面绣眉 平面绣眉是传统的绣眉方式,是通过过将复合自身形象的图案纹绘在眉毛上,经过改良而形成的平面绣眉,是标准眉型图案,颜色深浅平均,跟一般的眉形没太大区别。 3、点状绣眉 点状绣眉是独具设计性的绣眉,是一种改良的损伤最小的平面绣眉,需要用针点上药水刺其眉毛的毛囊口着色,稍微比较痛,看上去的眉毛比较粗,适合眉形好,眉毛少的女生。 4、立体绣眉 立体绣眉是利用排针,一排12只,运用不同的针法衔接在眉毛上,绣出二种深浅不一的咖啡色,这样的眉形看起来很自然立体,具有长短不齐、粗细不一的毛发线条特点,,让MM看起来更秀气漂亮。 5、仿真立体绣眉 仿真立体绣眉是比较流行的绣眉方式哦,是利用排针,一排12只,运用不同的针法进行绣眉,以咖啡色为基础,这样的眉形看起来很自然动态美。"</span><span class="string">,</span></span><br><span class="line">      <span class="string">"绣眉的五种基本方法,选择适合自己的绣眉方法,打造出秀气漂亮的眉形哦。"</span><span class="string">,</span></span><br><span class="line">      <span class="string">"(想知道自己适合什么发型吗?微信添加公众号爱靓网,发型师为您解答!)"</span></span><br><span class="line">    <span class="string">],</span></span><br><span class="line"><span class="attr">    "title":</span> <span class="string">"绣眉有哪几种方法?绣眉的基本方法_绣眉_妆美扮靓_爱靓网"</span></span><br><span class="line">  <span class="string">&#125;,</span></span><br><span class="line">  <span class="string">&#123;</span></span><br><span class="line"><span class="attr">    "bs_rank_pos":</span> <span class="number">1</span><span class="string">,</span></span><br><span class="line"><span class="attr">    "is_selected":</span> <span class="literal">false</span><span class="string">,</span></span><br><span class="line"><span class="attr">    "paragraphs":</span> <span class="string">[</span></span><br><span class="line">      <span class="string">"2016-09-30 10:04"</span><span class="string">,</span></span><br><span class="line">      <span class="string">"对于美的追求是很多人的天性,对于爱美的女生来说好看的眉型不但能提升气质,还能修饰脸型,绣眉也早已成为女生完善美化眉形的一种方式。绣眉有哪几种常见方法?一般绣眉得花多少钱?一起和小编了解一种吧。"</span><span class="string">,</span></span><br><span class="line">      <span class="string">"绣眉有哪几种常见方法?一起来了解下:"</span><span class="string">,</span></span><br><span class="line">      <span class="string">"A、平面绣眉:这是一款传统的绣眉方式,是以标准的眉型为图案,通过绣眉技术纹绘在眉毛上,色泽均匀上色,给人的感觉就好像刚刚画完眉毛一样。 B、点状绣眉:点状绣眉相对来说,会更有设计性。通过药水的渗透,将有色的染料对这眉毛的毛囊口进行点刺上色,还能按照眉毛的整体轮廓勾勒出眉型,不过眉毛过粗的美眉们则不适合点状绣眉喔! C、仿真立体绣眉:这种绣眉方式是利用排针和不同的针法衔接在眉毛上,出来的眉形效果是一把一把的形状,而且常用的色料是深浅不一的咖啡色来呈现,在着色上后的眉形效果就会像自己长出来的眉毛一样自然好看。 D、立体绣眉:立体绣眉也是利用排针来进行纹绣,采取了由浅至深的形式绣出眉形,而整体的效果会呈现出雾状,非常地有立体感。"</span><span class="string">,</span></span><br><span class="line">      <span class="string">"绣眉一般要多少钱?"</span><span class="string">,</span></span><br><span class="line">      <span class="string">"一般来说,绣眉的价钱在800到5000元之间,每家的医美诊所价格都是不同,会因规模以及技术相互关联。绣眉使用的材料也是决定价格的高低,一般分为有机色料及无机色料,以及绣眉的方式也是能决定价格的关键喔!由于绣上的眉型都是因人而异的,也会导致绣眉价格的差异。"</span><span class="string">,</span></span><br><span class="line">      <span class="string">"想必经过了小编的介绍,大家都对绣眉有哪几种常见方法?以及其价格有了一定的了解!如果你也想眉形好看也不妨尝试一下绣眉,选择好的技术以及医美医院才能保证绣眉的完美效果喔!(图片来源:视觉中国)"</span><span class="string">,</span></span><br><span class="line">      <span class="string">"(责任编辑:陆薇)"</span><span class="string">,</span></span><br><span class="line">      <span class="string">"全世界都在安利的“举重妖精”李圣经,凭什么成为男神收割机? 同是新疆美女 为啥迪丽热巴观众缘最好? 从晴儿到楚乔 赵丽颖是怎么越来越美的? 滨崎步发福or水肿?3分钟快速消水肿  学刘诗诗掀起刘海 气场2米8一点也不难"</span><span class="string">,</span></span><br><span class="line">      <span class="string">"梦幻的粉嫩无瑕肌 怎能不被吸引? 怀疑自己画了个假妆?那是用错了气垫  水润透亮 让肌肤呼吸一整天  伊夫黎雪植物焕颜抚纹系列  倒春寒 给肌肤加个完整的保湿屏障"</span><span class="string">,</span></span><br><span class="line">      <span class="string">"周末好心情 慵懒  露天趴音乐节妆容"</span><span class="string">,</span></span><br><span class="line">      <span class="string">"六月护肤爱用品 春季护肤五款高颜值萌物 开启焕肤撩春模式 实用百搭口罩妆容"</span><span class="string">,</span></span><br><span class="line">      <span class="string">"包贝尔新剧曝光表情冷 姜至鹏出轨被曝私密图 咘咘公园跳钢管舞萌翻 白百何学龅牙兔神表情 黄晓明胖了一圈曝真相 周冬雨再出表情包搞笑"</span></span><br><span class="line">    <span class="string">],</span></span><br><span class="line"><span class="attr">    "title":</span> <span class="string">"绣眉有哪几种常见方法?绣眉一般要多少钱【图】_彩妆资讯百科_美容_"</span></span><br><span class="line">  <span class="string">&#125;,</span></span><br><span class="line">  <span class="string">&#123;</span></span><br><span class="line"><span class="attr">    "bs_rank_pos":</span> <span class="number">2</span><span class="string">,</span></span><br><span class="line"><span class="attr">    "is_selected":</span> <span class="literal">false</span><span class="string">,</span></span><br><span class="line"><span class="attr">    "paragraphs":</span> <span class="string">[</span></span><br><span class="line">      <span class="string">"平面绣眉 平面绣眉是最为传统的绣眉方法。这种方法起源于古代,古时候人们将符合自身形象的图案描绘在眉毛和额头之间,最为有名的就是杨贵妃在眉毛和额头之间绘上了花朵。平面绣眉就是采用的这种方法。经过现代人的改良之后,平面绣眉出来的效果就像是刚刚画好的眉毛,还是比较逼真的。 点状绣眉 相对于平面绣眉来说,点状绣眉是比较疼的,不过这种方式更具有独特的设计性。点状绣眉适合眉毛细而且淡的人选择,它是采用针沾上药水有粗有细的对毛囊进行着色。采用这种方法能够绣出更加自然逼真的眉毛。 仿真立体绣眉 这种绣眉方法有点类似于点状绣眉,不过这种方法使用的是排针。目前比较常见的是使用一排十二根针。由于针的排布原因,使用这种方法绣出来的眉毛是一把一把的。而且美容院会采用深浅不同的颜色来表现眉毛的特点,因此,绣"</span><span class="string">,</span></span><br><span class="line">      <span class="string">"有平面绣眉,点状绣眉,仿真立体绣眉,立体绣眉"</span></span><br><span class="line">    <span class="string">],</span></span><br><span class="line"><span class="attr">    "title":</span> <span class="string">"绣眉有哪几种_百度知道"</span></span><br><span class="line">  <span class="string">&#125;,</span></span><br><span class="line">  <span class="string">&#123;</span></span><br><span class="line"><span class="attr">    "bs_rank_pos":</span> <span class="number">3</span><span class="string">,</span></span><br><span class="line"><span class="attr">    "is_selected":</span> <span class="literal">false</span><span class="string">,</span></span><br><span class="line"><span class="attr">    "paragraphs":</span> <span class="string">[</span></span><br><span class="line">      <span class="string">"有平面绣眉,点状绣眉,仿真立体绣眉,立体绣眉"</span></span><br><span class="line">    <span class="string">],</span></span><br><span class="line"><span class="attr">    "title":</span> <span class="string">"绣眉有几种,哪种比较好看?_百度知道"</span></span><br><span class="line">  <span class="string">&#125;,</span></span><br><span class="line">  <span class="string">&#123;</span></span><br><span class="line"><span class="attr">    "bs_rank_pos":</span> <span class="number">4</span><span class="string">,</span></span><br><span class="line"><span class="attr">    "is_selected":</span> <span class="literal">false</span><span class="string">,</span></span><br><span class="line"><span class="attr">    "paragraphs":</span> <span class="string">[</span></span><br><span class="line">      <span class="string">"有线条眉,就是跟真的眉毛很像,一根一根的;还有那种雾状眉,像化妆了一样;还有一种就是线条加雾的感觉。"</span><span class="string">,</span></span><br><span class="line">      <span class="string">"1、平面绣眉:传统的绣眉方式。在古代,绣眉技术是通过将复合自身形象的图案纹绘在眉额之间。后经过现代美容师的改良而形成如今的平面绣眉。以标准的眉型为图案,色泽均匀,宛如刚刚画完眉。 2、点状绣眉:此种方法相对于平面绣眉更加具有设计性,但是人体疼痛感要稍微强烈一点。在针点上通过药水的浸透,再对眉毛的毛囊口进行点刺并着色。可以按照眉毛的粗细变化,从而勾勒出漂亮的眉型。但是对于眉毛相对比较粗、浓者来说,是不适合进行点状绣眉的。 3、仿真立体绣眉:这种绣眉的方法利用排针,一排12只,运用不同的针法衔接在眉毛上,所绣出来的眉型现出一把一把的,而且须用二种深浅不一的咖啡色来表现色差,就像自己长的眉毛一样立体自然。 4、立体绣眉:这种绣眉的方法利用排针单一颜色由浅至深,绣出雾状,表现出立体"</span></span><br><span class="line">    <span class="string">],</span></span><br><span class="line"><span class="attr">    "title":</span> <span class="string">"绣眉分哪几种_百度知道"</span></span><br><span class="line">  <span class="string">&#125;</span></span><br><span class="line"><span class="string">],</span></span><br><span class="line"><span class="attr">"question":</span> <span class="string">"绣眉有哪几种"</span><span class="string">,</span></span><br><span class="line"><span class="attr">"answers":</span> <span class="string">[</span></span><br><span class="line">  <span class="string">"绣眉的五种基本方法：1、雕润眉；2、平面绣眉；3、点状绣眉；4、立体绣眉；5、仿真立体绣眉。"</span></span><br><span class="line"><span class="string">],</span></span><br><span class="line"><span class="attr">"entity_answers":</span> <span class="string">[</span></span><br><span class="line">  <span class="string">[</span></span><br><span class="line">    <span class="string">"雕润眉"</span><span class="string">,</span></span><br><span class="line">    <span class="string">"平面绣眉"</span><span class="string">,</span></span><br><span class="line">    <span class="string">"点状绣眉"</span><span class="string">,</span></span><br><span class="line">    <span class="string">"立体绣眉"</span><span class="string">,</span></span><br><span class="line">    <span class="string">"仿真立体绣眉"</span></span><br><span class="line">  <span class="string">]</span></span><br><span class="line"><span class="string">],</span></span><br><span class="line"><span class="attr">"question_type":</span> <span class="string">"ENTITY"</span><span class="string">,</span></span><br><span class="line"><span class="attr">"fact_or_opinion":</span> <span class="string">"FACT"</span><span class="string">,</span></span><br><span class="line"><span class="attr">"question_id":</span> <span class="number">0</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure></p>]]></content>
      
      <categories>
          
          <category> ML </category>
          
          <category> applications </category>
          
          <category> nlp </category>
          
          <category> 阅读理解 </category>
          
          <category> dataset </category>
          
      </categories>
      
      
        <tags>
            
            <tag> dataset </tag>
            
            <tag> 数据分析 </tag>
            
            <tag> 阅读理解 </tag>
            
            <tag> baidu </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>java的正则表达式</title>
      <link href="/pub/31a07523/"/>
      <url>/pub/31a07523/</url>
      <content type="html"><![CDATA[<h1 id="正则表达式实例"><a href="#正则表达式实例" class="headerlink" title="正则表达式实例"></a>正则表达式实例</h1><p>Java 正则表达式和 Perl 的是最为相似的。</p><p>java.util.regex 包主要包括以下三个类：</p><h2 id="Pattern-类"><a href="#Pattern-类" class="headerlink" title="Pattern 类"></a>Pattern 类</h2><p>pattern 对象是一个正则表达式的编译表示。Pattern 类没有公共构造方法。要创建一个 Pattern 对象，你必须首先调用其公共静态编译方法，它返回一个 Pattern 对象。该方法接受一个正则表达式作为它的第一个参数。</p><h2 id="Matcher-类"><a href="#Matcher-类" class="headerlink" title="Matcher 类"></a>Matcher 类</h2><p>Matcher 对象是对输入字符串进行解释和匹配操作的引擎。与Pattern 类一样，Matcher 也没有公共构造方法。你需要调用 Pattern 对象的 matcher 方法来获得一个 Matcher 对象。</p><p>PatternSyntaxException：<br>PatternSyntaxException 是一个非强制异常类，它表示一个正则表达式模式中的语法错误。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li><a href="http://www.runoob.com/java/java-regular-expressions.html" target="_blank" rel="noopener">菜鸟教程</a></li></ul>]]></content>
      
      <categories>
          
          <category> CS </category>
          
          <category> programing </category>
          
          <category> lan </category>
          
          <category> java </category>
          
          <category> jdk </category>
          
          <category> rt </category>
          
          <category> util </category>
          
          <category> regex </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 正则表达式 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>hexo中如何支持公式 mathjax</title>
      <link href="/pub/6aa77778/"/>
      <url>/pub/6aa77778/</url>
      <content type="html"><![CDATA[<link rel="stylesheet" href="/css/tag-chat.css"><h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p><a href="https://www.mathjax.org/" target="_blank" rel="noopener">MathJax</a> 和 <a href="https://khan.github.io/KaTeX/" target="_blank" rel="noopener">Katex</a></p><h1 id="mathjax"><a href="#mathjax" class="headerlink" title="mathjax"></a>mathjax</h1><blockquote><p>Beautiful math in all browsers<br><br>A <strong>JavaScript display engine</strong> for mathematics that works in all browsers.<br><br> —— 来自www.mathjax.org</p></blockquote><p>MathJax是一款运行在浏览器中的开源的数学符号渲染引擎，使用MathJax可以方便的在浏览器中显示数学公式，不需要使用图片。目前，MathJax可以解析Latex、MathML和ASCIIMathML的标记语言。 MathJax项目于2009年开始，发起人有American Mathematical Society, Design Science等，还有众多的支持者。</p><ul><li>无损缩放，支持多种方式的公式渲染(math-render)。(不采用图片、Flash)<ul><li><strong>CSS引擎</strong>：采用CSS生成数学公式</li><li><strong>SVG引擎</strong>：采用SVG生成数学公式</li><li><strong>MathML引擎</strong>：</li></ul></li><li>源码拷贝。可以拷贝LaTeX、wiki等；</li><li>输入形式可以是MathML、TeX或者ASCIImath</li></ul><h1 id="html中使用mathjax"><a href="#html中使用mathjax" class="headerlink" title="html中使用mathjax"></a>html中使用mathjax</h1><p>mathjax就是个<strong>前端渲染引擎</strong>。<br><!--angular，等--></p><script async src="//jsfiddle.net/xusong/npc3gu8v/embed/html,result/"></script><p>或者拷贝以上代码，保存为<code>math.html</code>，双击打开就能看到渲染好的公式。</p><h1 id="hexo中使用mathjax"><a href="#hexo中使用mathjax" class="headerlink" title="hexo中使用mathjax"></a>hexo中使用mathjax</h1><p>同样很简单，仅需两步。</p><ol><li>加载mathjax的cdn</li><li>博客中按照<code>tex</code>语法写公式即可</li></ol><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p>markdown中书写：<br><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="formula">$$x = &#123;-b <span class="tag">\<span class="name">pm</span></span> <span class="tag">\<span class="name">sqrt</span><span class="string">&#123;b^2-4ac&#125;</span></span> <span class="tag">\<span class="name">over</span></span> 2a&#125;.$$</span></span><br></pre></td></tr></table></figure></p><p>或<br><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">\<span class="name">[</span></span>x = &#123;-b <span class="tag">\<span class="name">pm</span></span> <span class="tag">\<span class="name">sqrt</span><span class="string">&#123;b^2-4ac&#125;</span></span> <span class="tag">\<span class="name">over</span></span> 2a&#125;.<span class="tag">\<span class="name">]</span></span></span><br></pre></td></tr></table></figure></p><p>会被自动渲染成以下$x = {-b \pm \sqrt{b^2-4ac} \over 2a}.$公式：</p><p>方式一</p><script type="math/tex; mode=display">x = {-b \pm \sqrt{b^2-4ac} \over 2a}.</script><p>方式二</p><p>[x = {-b \pm \sqrt{b^2-4ac} \over 2a}.]</p><p>方式三<br>\[x = {-b \pm \sqrt{b^2-4ac} \over 2a}.\]</p><p>方式四：$\sqrt{3x-1}+(1+x)^2$ 。 jupyter支持这种，google colab采用的<code>marked.js</code>作为渲染引擎。</p><h1 id="存在的问题"><a href="#存在的问题" class="headerlink" title="存在的问题"></a>存在的问题</h1><p>hexo默认的markdown渲染插件是<a href="https://github.com/hexojs/hexo-renderer-marked" target="_blank" rel="noopener">hexo-renderer-marked</a>，其调用的<a href="https://github.com/chjj/marked" target="_blank" rel="noopener">marked.js渲染引擎</a>。</p><h2 id="markdow引擎的转义问题"><a href="#markdow引擎的转义问题" class="headerlink" title="markdow引擎的转义问题"></a>markdow引擎的转义问题</h2><figure class="highlight md"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"># marked demo</span></span><br><span class="line">\[ x=1 \]</span><br><span class="line"></span><br><span class="line">\\[ x=1 \\]</span><br></pre></td></tr></table></figure><p>经过<code>marked</code>引擎解析成以下html。<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">h1</span> <span class="attr">id</span>=<span class="string">"marked-demo"</span>&gt;</span>marked demo<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>[ x=1 ]<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>\[ x=1 \]<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure></p><ul><li><code>marked</code> 轻量级 转换demo，<a href="https://marked.js.org/demo/?text=%23%20good%0A%24%24x%2B1%5Cover%5Csqrt%7B1-x%5E2%7D%24%24%0A%0A%23%20bad%0A%5C%5Bx%2B1%5Cover%5Csqrt%7B1-x%5E2%7D%5C%5D%0A%5C(x%2B1%5Cover%5Csqrt%7B1-x%5E2%7D%5C" target="_blank" rel="noopener">点此</a>)</li><li><code>pandoc</code> 重量级 也存在同样的问题，<a href="http://pandoc.org/try/?text=%23+good%0A%24%24x%2B1%5Cover%5Csqrt%7B1-x%5E2%7D%24%24%0A%0A%23+bad%0A%5C%5Bx%2B1%5Cover%5Csqrt%7B1-x%5E2%7D%5C%5D%0A%5C(x%2B1%5Cover%5Csqrt%7B1-x%5E2%7D%5C" target="_blank" rel="noopener">示例</a>&amp;from=markdown&amp;to=)<ul><li>pandoc -f markdown+tex_math_single_backslash —mathjax test.md -o test.html</li><li>以上参数的命令可以解决问题</li></ul></li><li><code>kramdown</code>也存在同样的问题，<a href="http://kramdown-sandbox.herokuapp.com/" target="_blank" rel="noopener">示例</a></li></ul><p>这里我们发现<code>\[</code>会被转义成<code>[</code>，因此需要将公式写成<code>\\[</code>才能够正确渲染，比较麻烦。<br>解决办法</p><ol><li>我们写公式的时候，自己手动多加个转义，比如<code>\[</code>要写成<code>\\[</code>   <strong>麻烦</strong></li><li>修改marked源码，取消了对<code>\\</code>,<code>\{</code>,<code>\}</code>的转义(escape)   <strong>麻烦</strong></li><li>采用其他markdown引擎，比如kramdown (比如<a href="https://github.com/cs231n/cs231n.github.io/blob/master/_config.yml#L11" target="_blank" rel="noopener">cs231n</a>就采用的kramdown)   <strong>发现也不work</strong></li><li>把所有<code>\[</code>替换成$$$$  <strong>我目前是这样做的</strong></li></ol><h1 id="hexo-math插件"><a href="#hexo-math插件" class="headerlink" title="hexo-math插件"></a>hexo-math插件</h1><p>不推荐，竟然还支持<code>math</code> 的标签，我觉得多此一举。</p><h1 id="疑问"><a href="#疑问" class="headerlink" title="疑问"></a>疑问</h1><div class="chatContent" id="chatContent"><div class="clearfix">  <div class="message others"> <div class="avatar" data-author-id="lj"> <img src="http://c1.mifile.cn/f/i/hd/2016051101/a-lj.png" alt="雷军"> </div> <div class="content"> <div class="bubble  bubble_default left"> <div class="bubble_cont"> <div class="plain"> <pre>`theme-next`为什么要限定markdown引擎？不应该和markdown引擎无关吗？</pre> </div> </div> </div>  </div> </div>  </div><div class="clearfix">  <div class="message others"> <div class="avatar" data-author-id="lj"> <img src="http://c1.mifile.cn/f/i/hd/2016051101/a-lj.png" alt="雷军"> </div> <div class="content"> <div class="bubble  bubble_default left"> <div class="bubble_cont"> <div class="plain"> <pre>...</pre> </div> </div> </div>  </div> </div>  </div></div><h1 id="常用的公式"><a href="#常用的公式" class="headerlink" title="常用的公式"></a>常用的公式</h1><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li><a href="https://github.com/theme-next/hexo-theme-next/blob/master/docs/MATH.md" target="_blank" rel="noopener">theme-next中使用mathjax</a></li><li><a href="http://shomy.top/2016/10/22/hexo-markdown-mathjax/" target="_blank" rel="noopener">Hexo下mathjax的转义问题</a></li><li><a href="https://blog.csdn.net/emptyset110/article/details/50123231" target="_blank" rel="noopener">使Marked.js与MathJax共存</a></li></ul>]]></content>
      
      <categories>
          
          <category> demo </category>
          
          <category> hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端渲染 </tag>
            
            <tag> mathjax </tag>
            
            <tag> 公式 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>推荐系统架构</title>
      <link href="/pub/7e199c30/"/>
      <url>/pub/7e199c30/</url>
      <content type="html"><![CDATA[<p>推荐系统需要由多个推荐引擎组成，每个推荐引擎负责一类特征和一种任务，而推荐系统的任务只是将推荐引擎的结果按照一定权重或者优先级合并、排序然后返回。</p><image title="推荐系统的架构图" src="/images/raw/ML - 推荐系统 - 架构 - 推荐系统实践.jpg"><ul><li>可以方便地增加/删除引擎，控制不同引擎对推荐结果的影响。对于绝大多数需求，只需要通过不同的引擎组合实现。</li><li>可以实现推荐引擎级别的用户反馈</li></ul><p><a href="https://www.zhihu.com/question/25144005" target="_blank" rel="noopener">推荐系统架构 | 知乎</a></p><p><a href="https://www.cnblogs.com/kobedeshow/p/3569525.html" target="_blank" rel="noopener">https://www.cnblogs.com/kobedeshow/p/3569525.html</a></p><p>推荐引擎的构建来源于不同的数据源(也就是用户的特征有很多种类，例如统计的、行为的、主题的)+不同的推荐模型算法，推荐引擎的架构可以试多样化的(实时推荐的+离线推荐的)，然后融合推荐结果（人工规则+模型结果），融合方式多样的，有线性加权的或者切换式的等</p><h2 id="推荐系统有哪些坑？-知乎"><a href="#推荐系统有哪些坑？-知乎" class="headerlink" title="推荐系统有哪些坑？ | 知乎"></a><a href="https://www.zhihu.com/question/28247353" target="_blank" rel="noopener">推荐系统有哪些坑？ | 知乎</a></h2><ul><li><p>将“推荐”理解为“推送</p></li><li><p>高估算法作用</p><ul><li>推荐系统中，按照影响效果：用户交互界面(UI) &gt; 数据 &gt; 算法。</li></ul></li></ul></image>]]></content>
      
      <categories>
          
          <category> ML </category>
          
          <category> recommender-system </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 推荐系统 </tag>
            
            <tag> 架构 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>【机器翻译】transformer</title>
      <link href="/pub/664e9bad/"/>
      <url>/pub/664e9bad/</url>
      <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>在2017年5月Facebook发布了<code>ConvSeq2Seq</code>模型吊打了GNMT一个月之后，Google发出了最强有力的反击，发表了一篇论文Attention is all you need，文中提出了一种新的架构叫做<code>Transformer</code>，用以来实现机器翻译。它<strong>抛弃了传统的CNN、RNN，只采用attention</strong>，取得了很好的效果，激起了工业界和学术界的广泛讨论。</p><h1 id="背景，motivation"><a href="#背景，motivation" class="headerlink" title="背景，motivation"></a>背景，motivation</h1><h2 id="如何获取context信息"><a href="#如何获取context信息" class="headerlink" title="如何获取context信息"></a>如何获取context信息</h2><p>常用的方法有RNN、CNN。</p><p>见 related work</p><p><img alt="transformer" title="transformer - data flow" src="https://3.bp.blogspot.com/-aZ3zvPiCoXM/WaiKQO7KRnI/AAAAAAAAB_8/7a1CYjp40nUg4lKpW7covGZJQAySxlg8QCLcBGAs/s640/transform20fps.gif"></p><h3 id="transformer横空出世"><a href="#transformer横空出世" class="headerlink" title="transformer横空出世"></a>transformer横空出世</h3><p>Transformer避开了recurrence，只用attention，便可以刻画出输入和输出的依赖关系。</p><p>对比RNN的决策步骤太长问题，transformer可<strong>单步决策</strong>。通过一层self-attention，bank能够直接attend到river上。</p><p>ConvS2S是线性时间复杂度，ByteNet是log时间复杂度。而Transformer则是常数时间复杂度(前提是the cost of reduced effective resolution due to averaging attention-weighted positions, an effect we counteract with Multi-Head Attention)。</p><h1 id="核心点-创新点-亮点-trick"><a href="#核心点-创新点-亮点-trick" class="headerlink" title="核心点 创新点 亮点 trick"></a>核心点 创新点 亮点 trick</h1><h2 id="对attention的抽象"><a href="#对attention的抽象" class="headerlink" title="对attention的抽象"></a>对attention的抽象</h2><p>对attention的抽象 q k v</p><p><img alt="Scaled Dot Product Attention" title="Scaled Dot Product Attention" src="/images/raw/NN - transformer - scaled dot product attention.jpg"></p><p>When $a \ne 0$, there are two solutions to $ax^2 + bx + c = 0$ and they are</p><script type="math/tex; mode=display">x = {-b \pm \sqrt{b^2-4ac} \over 2a}.</script><p>前面给出的是一般化的框架形式的描述，事实上Google给出的方案是很具体的。首先，它先把Attention的定义给了出来：</p><script type="math/tex; mode=display">Attention(\boldsymbol{Q},\boldsymbol{K},\boldsymbol{V}) = softmax\left(\frac{\boldsymbol{Q}\boldsymbol{K}^{\top}}{\sqrt{d_k}}\right)\boldsymbol{V}</script><p>这里用的是跟Google的论文一致的符号，其中$ \boldsymbol{Q}\in\mathbb{R}^{n\times d_k}, \boldsymbol{K}\in\mathbb{R}^{m\times d_k}, \boldsymbol{V}\in\mathbb{R}^{m\times d_v} $。如果忽略激活函数softmax的话，那么事实上它就是三个$ n\times d_k,d_k\times m, m\times d_v $的矩阵相乘，最后的结果就是一个$ n\times d_v $的矩阵。于是我们可以认为：这是一个Attention层，将n$ n\times d_k $的序列Q编码成了一个新的$ n\times d_v $的序列。</p><p>并行其实就是encoder的时候可以，速度上来说transformer并不占优势</p><p>这里将attention抽象成 q k v</p><ol><li>attention 可以不只是用于 decoder 里每步输入一个符号，而是可以用在网络中的任意一层，把一个序列转换成另一个序列。这个作用与 convolutional layer、recurrent layer 等是类似的，但有一个好处就是不再局限于局域性。attention是直接去capture dependency structure，摆脱了局限性魔咒</li><li>attention 可以一般地描述为在一个 key-value mapping 中进行检索，只不过 query 跟 key 可以进行模糊匹配，检索结果是各个 key 对应的 value 的加权平均。</li></ol><p>Query, key, value 其实并不是专门针对翻译的概念。不过可以举一些翻译中的例子。例如，当刚刚翻译完主语之后，attention 的内部状态就会想要去找谓语，这时它就把「想找谓语」这件事编码成 query。然后句子里本身是谓语的地方，会有一个 key，表明「我这里可以提供谓语」，它跟 query 一拍即合。这个 key 对应的 value 就是谓语本身的 embedding。</p><p>Q: 在LSTM+attention模型里，query就是上一个时间单元的隐状态，容易理解，即你所谓的对[想找谓语]编码，但是all attention模型不再使用LSTM，这个query编码是什么？谢谢<br>A: all attention model 只不过不再用 lstm 计算隐状态，而是用 attention 计算得出。一层 attention 计算出的结果就是下一层的 query</p><h2 id="Multi-Head-Attention"><a href="#Multi-Head-Attention" class="headerlink" title="Multi-Head Attention"></a>Multi-Head Attention</h2><p>以Q为例，单个head的计算</p><p><img alt="Multi-Head Attention" title="Multi-Head Attention" src="/images/raw/NN - transformer - multi head attention.jpg"></p><ul><li><a href="https://github.com/tensorflow/tensor2tensor/blob/master/tensor2tensor/layers/common_attention.py#L2646" target="_blank" rel="noopener">code-t2t</a></li><li><a href="https://github.com/Kyubyong/transformer/blob/master/modules.py#L169" target="_blank" rel="noopener">code-Kyubyong</a></li><li><a href="https://github.com/bojone/attention/blob/master/attention_keras.py" target="_blank" rel="noopener">code-keras</a></li></ul><p>将输入向量切成8份，这每一<br>份可以看成一个local partial，然后再分别attnetion最终再concat成一个context向量。如果将本文multi-head attention的V输入切成八份后的<br>向量类比关注不同local paritial的卷积核的话，我们可以看到CNN和这里multi-head attention异曲同工</p><p><strong>优势</strong>：能在encode的时候并行化，(convS2S同样可以，但是transformer只用attention）</p><h2 id="FFN层：positionwise-fully-connected-feed-forward-network"><a href="#FFN层：positionwise-fully-connected-feed-forward-network" class="headerlink" title="FFN层：positionwise fully connected feed-forward network"></a>FFN层：positionwise fully connected feed-forward network</h2><p>为什么叫FFN层：positionwise?</p><p>applied to each position separately and identically</p><h2 id="Positional-Encoding"><a href="#Positional-Encoding" class="headerlink" title="Positional Encoding"></a>Positional Encoding</h2><p>Sinusoid Positional Encoding</p><p><a href="https://github.com/Kyubyong/transformer/blob/master/modules.py#L120" target="_blank" rel="noopener">code</a></p><p><a href="">more detail</a></p><h1 id="trick"><a href="#trick" class="headerlink" title="trick"></a>trick</h1><p>LayerNorm(x + Sublayer(x)),</p><h2 id="residual-connection"><a href="#residual-connection" class="headerlink" title="residual connection"></a>residual connection</h2><h2 id="layer-normalization"><a href="#layer-normalization" class="headerlink" title="layer normalization"></a>layer normalization</h2><p>residual之后加的LN</p><h1 id="Result"><a href="#Result" class="headerlink" title="Result"></a>Result</h1><h1 id=""><a href="#" class="headerlink" title="#"></a>#</h1><h2 id="可视化"><a href="#可视化" class="headerlink" title="可视化"></a>可视化</h2><p>经过测试，列了以下可视化结果。</p><p><img src="/images/raw/NN - transformer - attention visualization 1.png"></p><p><img src="/images/raw/NN - transformer - attention visualization 2.png"></p><p><img src="/images/raw/NN - transformer - attention visualization 3.png"></p><h1 id="code"><a href="#code" class="headerlink" title="code"></a>code</h1><ul><li>TensorFlow<ul><li><a href="https://github.com/Kyubyong/transformer" target="_blank" rel="noopener">https://github.com/Kyubyong/transformer</a>  简易版，bucket， lr decay都没有实现，训起来效果应该没那好</li><li><a href="https://github.com/tensorflow/tensor2tensor#translation" target="_blank" rel="noopener">https://github.com/tensorflow/tensor2tensor#translation</a>  产品级，最官方，有中英文翻译数据库</li><li>代码解析： <a href="https://blog.csdn.net/mijiaoxiaosan/article/details/74909076" target="_blank" rel="noopener">https://blog.csdn.net/mijiaoxiaosan/article/details/74909076</a></li></ul></li><li>Pytorch</li></ul><h1 id="扩展阅读"><a href="#扩展阅读" class="headerlink" title="扩展阅读"></a>扩展阅读</h1><ul><li><a href="https://ai.googleblog.com/2017/08/transformer-novel-neural-network.html" target="_blank" rel="noopener">Transformer | Google-blog</a></li><li><a href="https://kexue.fm/archives/4765" target="_blank" rel="noopener">《Attention is All You Need》浅读（简介+代码）| kexue.fm</a></li><li><a href="https://zhuanlan.zhihu.com/p/27464080" target="_blank" rel="noopener">从convS2S到transformer | 知乎</a></li></ul>]]></content>
      
      <categories>
          
          <category> -machine translation </category>
          
          <category> 2. 主流model-研究现状 </category>
          
          <category> 2. 神经网络机器翻译 NMT </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 机器翻译 </tag>
            
            <tag> seq2seq </tag>
            
            <tag> attention </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>深度学习中的注意力机制 原理 及 代码</title>
      <link href="/pub/c47c5082/"/>
      <url>/pub/c47c5082/</url>
      <content type="html"><![CDATA[<p>seq2seq缺陷：无论之前的context有多长，包含多少信息量，最终都要被压缩成一个几百维的vector。这意味着context越大，最终的state vector会丢失越多的信息。</p><p>Attention based model的核心思想: 一个模型完全可以在decode的过程中利用<strong>context的全部信息</strong>，而不仅仅是最后一个state。</p><ol><li>ss<ul><li>global attention</li><li>local attention</li></ul></li><li>ewrw<ul><li>soft</li><li>hard</li></ul></li></ol><h1 id="各种各样的attention"><a href="#各种各样的attention" class="headerlink" title="各种各样的attention"></a>各种各样的attention</h1><ul><li>2014年google mind团队的这篇论文《Recurrent Models of Visual Attention》，他们在RNN模型上使用了attention机制来进行图像分类。</li><li>Bahdanau等人在论文《Neural Machine Translation by Jointly Learning to Align and Translate》中，使用类似attention的机制在机器翻译任务上将翻译和对齐同时进行，他们的工作算是第一个将attention机制应用到NLP领域中。</li><li>接着attention机制被广泛应用在基于RNN/CNN等神经网络模型的各种NLP任务中。</li><li>2017年，google机器翻译团队发表的《Attention is all you need》中大量使用了自注意力（self-attention）机制来学习文本表示。</li></ul><h2 id="什么是attention，attention的起源"><a href="#什么是attention，attention的起源" class="headerlink" title="什么是attention，attention的起源"></a>什么是attention，attention的起源</h2><h2 id="广义的attention"><a href="#广义的attention" class="headerlink" title="广义的attention"></a>广义的attention</h2><p>见google得transformer。</p><p>Attention函数的本质可以被描述为一个查询（query）到一系列（键key-值value）对的映射，</p><h2 id="self-attention"><a href="#self-attention" class="headerlink" title="self attention"></a>self attention</h2><p>什么是self-attention，下面这个图就是self-attention。</p><p><img src="/images/raw/NN - transformer - self attention - visualization.png"></p><p>可以理解为没有target的attention，也可以理解为自己把自己当做target进行attention。</p><h2 id="Multi-Head-Attention"><a href="#Multi-Head-Attention" class="headerlink" title="Multi-Head Attention"></a>Multi-Head Attention</h2><h2 id="Structured-Self-attention"><a href="#Structured-Self-attention" class="headerlink" title="Structured Self-attention"></a>Structured Self-attention</h2><p>参考 A Structured Self-attentive Sentence Embedding</p><h2 id="Self-Attention-with-Relative-Position-Representations-google-brain-2018"><a href="#Self-Attention-with-Relative-Position-Representations-google-brain-2018" class="headerlink" title="Self-Attention with Relative Position Representations - google brain 2018"></a>Self-Attention with Relative Position Representations - google brain 2018</h2><p>Self-Attention with Relative Position Representations（基于相对位置表示的子注意力模型）</p><h2 id="Reinforced-Self-Attention"><a href="#Reinforced-Self-Attention" class="headerlink" title="Reinforced Self-Attention"></a>Reinforced Self-Attention</h2><p>Reinforced Self-Attention Network: a Hybrid of Hard and Soft Attention for Sequence Modeling（增强的自注意力网络:一种对序列建模的硬和软注意力的混合）</p><h2 id="Distance-based-Self-Attention-Network"><a href="#Distance-based-Self-Attention-Network" class="headerlink" title="Distance-based Self-Attention Network"></a>Distance-based Self-Attention Network</h2><p>Distance-based Self-Attention Network for Natural Language Inference（基于距离的自注意力网络的自然语言推理）</p><h2 id="sparse-attention"><a href="#sparse-attention" class="headerlink" title="sparse attention"></a>sparse attention</h2><h2 id="hierarchical-attentioin"><a href="#hierarchical-attentioin" class="headerlink" title="hierarchical attentioin"></a>hierarchical attentioin</h2><p><a href="http://www.cs.cmu.edu/~./hovy/papers/16HLT-hierarchical-attention-networks.pdf" target="_blank" rel="noopener">Hierarchical Attention Networks for Document Classification</a></p><p><img alt="Hierarchical Attention Network" src="/images/raw/NN - attentioin - hierarchical attention.jpg" title="Hierarchical Attention Network"></p><p>采用了word-level和sentent-level的attention。</p><ol><li>a word sequence encoder<ul><li>采用的GRU。<a href="http://www.aclweb.org/anthology/D15-1167" target="_blank" rel="noopener">Document Modeling with Gated Recurrent Neural Network…</a> 这篇文章提到，在文本分类领域 GRU比LSTM效果好。</li><li>也可以采用CNN</li></ul></li><li>a word-level attention layer</li><li>a sentence encoder</li><li>a sentence-level attention layer</li></ol><p>可视化分析</p><p><img alt="Hierarchical Attention Network" src="/images/raw/NN - attentioin - hierarchical attention - result.jpg" title="Hierarchical Attention Network"></p><h1 id=""><a href="#" class="headerlink" title="#"></a>#</h1><h1 id="-1"><a href="#-1" class="headerlink" title="#"></a>#</h1><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li><a href="https://distill.pub/2016/augmented-rnns/" target="_blank" rel="noopener">Attention and Augmented Recurrent Neural Networks | Distill</a><br>-</li><li><a href="https://mp.weixin.qq.com/s/swLwla75RIQfyDDCPYynaw" target="_blank" rel="noopener">深度学习中的注意力机制 | 张俊林 2017</a></li><li><a href="http://www.cnblogs.com/robert-dlut/p/8638283.html" target="_blank" rel="noopener">自然语言处理中的自注意力机制（Self-attention）| cnblogs</a></li><li><a href="https://www.zhihu.com/question/36591394" target="_blank" rel="noopener">知乎</a></li><li><a href="https://plmsmile.github.io/2017/10/12/Attention-based-NMT/" target="_blank" rel="noopener">注意力机制和PyTorch实现机器翻译</a></li><li><a href="https://cloud.tencent.com/developer/article/1086575" target="_blank" rel="noopener">【论文推荐】最新七篇自注意力机制(Self-attention)相关论文</a></li><li><a href="https://kexue.fm/archives/4765" target="_blank" rel="noopener">《Attention is All You Need》浅读（简介+代码）| kexue.fm</a></li></ul>]]></content>
      
      <categories>
          
          <category> ML </category>
          
          <category> deep learning </category>
          
          <category> model </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>【读图识政治】中国最高领导人</title>
      <link href="/pub/75bd2e9b/"/>
      <url>/pub/75bd2e9b/</url>
      <content type="html"><![CDATA[<h1 id="最高领导人"><a href="#最高领导人" class="headerlink" title="最高领导人"></a>最高领导人</h1><p><code>中华人民共和国最高领导人</code>是指中华人民共和国政治中具有最终决定和最高地位的政治领导人，是一个“非官方”的称谓。最高领导人在中国共产党和中华人民共和国的权力机构中<strong>不一定拥有最高职衔</strong>，但<strong>均曾担任中共中央军委主席</strong>，能有效控制其三大党政军机构——中国共产党、政府和解放军等武装力量。</p><p>目前中国官方称呼毛泽东、邓小平、江泽民、习近平为第一、二、三、五代中央领导集体的核心，称呼第四代胡锦涛为以他为总书记的党中央。党主席兼总理华国锋则是<code>过渡时期</code>的领导人。</p><p>2017年中共十九大之后，中共中央政治局全体委员和常委都被规定要向总书记述职，形成<strong>“总书记绝对领导制”</strong>，习近平作为总书记不再只是集体领导的一员，其权威已经达到毛泽东时期中央委员会主席的程度，成为全党全国的最高领袖。</p><h1 id="历代领导人"><a href="#历代领导人" class="headerlink" title="历代领导人"></a>历代领导人</h1><div class="table-container"><table><thead><tr><th>代</th><th>姓名</th><th>肖像</th><th>党职</th><th>时间</th><th>备注</th></tr></thead><tbody><tr><td>1</td><td>毛泽东</td><td><img alt="Mao_Zedong_portrait.jpg" src="https://upload.wikimedia.org/wikipedia/commons/e/e8/Mao_Zedong_portrait.jpg" width="100" height="120"></td><td>中共中央委员会主席<br>中共中央军事委员会主席</td><td>1949-1976</td><td>党主席，一直都是最高领导人</td></tr><tr><td></td><td>华国锋</td><td><img alt="Hua Guofeng-1.jpg" src="https://upload.wikimedia.org/wikipedia/commons/0/09/Hua_Guofeng-1.jpg" width="100" height="132"></td><td>中共中央委员会主席<br>中共中央军事委员会主席</td><td>1976-1978</td><td>毛泽东钦点的接班人，党内斗争失势后退休</td></tr><tr><td>2</td><td>邓小平</td><td><img alt="Deng Xiaoping.jpg" src="https://upload.wikimedia.org/wikipedia/commons/1/1c/Deng_Xiaoping.jpg" width="100" height="120"></td><td>中共顾问委员会主任<br>中共中央军事委员会主席</td><td>1978-1992</td><td>1978年复出做<a href="https://zh.wikipedia.org/wiki/%E4%B8%AD%E5%85%B1%E5%85%AB%E5%A4%A7%E5%85%83%E8%80%81" target="_blank" rel="noopener">元老</a>代表，主持改革开放政策</td></tr><tr><td>3</td><td>江泽民</td><td><img alt="Jiang Zemin St. Petersburg2002.jpg" src="https://upload.wikimedia.org/wikipedia/commons/0/09/Jiang_Zemin_St._Petersburg2002.jpg" width="100" height="120"></td><td>中共中央总书记<br>中共中央军事委员会主席</td><td>1992-2002</td><td><a href="https://zh.wikipedia.org/wiki/%E5%85%AD%E5%9B%9B%E6%B8%85%E5%9C%BA" target="_blank" rel="noopener">六四事件</a>之后取代赵紫阳做中共中央总书记</td></tr><tr><td>4</td><td>胡锦涛</td><td><img alt="Hu Jintao Cannes2011.jpg" src="https://upload.wikimedia.org/wikipedia/commons/5/59/Hu_Jintao_Cannes2011.jpg" width="100" height="120"></td><td>中共中央总书记<br>中共中央军事委员会主席</td><td>2002-2012</td><td>邓小平于1992年就已经隔代钦点的接班人</td></tr><tr><td>5</td><td>习近平</td><td><img alt="Xi Jinping Sept. 19, 2012.jpg" src="https://upload.wikimedia.org/wikipedia/commons/2/28/Xi_Jinping_Sept._19%2C_2012.jpg" width="100" height="120"></td><td>中共中央总书记<br>中共中央军事委员会主席</td><td>2012-</td><td>革命元老习仲勋儿子，中共党内协商产生</td></tr></tbody></table></div><h1 id="领导班子"><a href="#领导班子" class="headerlink" title="领导班子"></a>领导班子</h1><p><script type="text/javascript" src="https://www.gstatic.com/charts/loader.js"></script><script type="text/javascript">google.charts.load("current",{packages:["timeline"]}); google.charts.setOnLoadCallback(drawChart); function drawChart(){var container=document.getElementById('timeline-china'); var chart=new google.visualization.Timeline(container); var dataTable=new google.visualization.DataTable(); dataTable.addColumn({type: 'string', id: 'Position'}); dataTable.addColumn({type: 'string', id: 'Name'}); dataTable.addColumn({type: 'date', id: 'Start'}); dataTable.addColumn({type: 'date', id: 'End'}); dataTable.addRows([ [ '国家主席', '毛泽东', new Date(1949, 10, 1), new Date(1959, 4, 27)], [ '国家主席', '刘少奇', new Date(1959, 4, 27), new Date(1968, 10, 31)], [ '国家主席', '宋庆龄、董必武(代理)', new Date(1968, 10, 31), new Date(1972, 2, 24)], [ '国家主席', '董必武(代理)', new Date(1972, 2, 24), new Date(1975, 1, 17)], [ '国家主席', '宋庆龄', new Date(1981, 5, 16), new Date(1981, 5, 29)], [ '国家主席', '李先念(名誉主席)', new Date(1983, 6, 18), new Date(1988, 4, 8)], [ '国家主席', '杨尚昆', new Date(1988, 4, 8), new Date(1993, 3, 27)], [ '国家主席', '江泽民', new Date(1993, 3, 27), new Date(2003, 3, 15)], [ '国家主席', '胡锦涛', new Date(2003, 3, 15), new Date(2013, 3, 14)], [ '国家主席', '习近平', new Date(2013, 3, 14), new Date()], [ '中共总书记', '毛泽东', new Date(1945, 6, 19), new Date(1976, 9, 9)], [ '中共总书记', '华国锋', new Date(1976, 10, 7), new Date(1981, 6, 28)], [ '中共总书记', '胡耀邦', new Date(1981, 6, 29), new Date(1987, 1, 16)], [ '中共总书记', '赵紫阳', new Date(1987, 1, 16), new Date(1989, 6, 2)], [ '中共总书记', '江泽民', new Date(1989, 6, 24), new Date(2002, 11, 14)], [ '中共总书记', '胡锦涛', new Date(2002, 11, 15), new Date(2012,11, 14)], [ '中共总书记', '习近平', new Date(2012, 11, 15), new Date()], [ '军委主席', '毛泽东', new Date(1949, 10, 1), new Date(1976, 8)], [ '军委主席', '华国锋', new Date(1976, 10, 7), new Date(1981, 6)], [ '军委主席', '邓小平', new Date(1981, 6), new Date(1989, 11)], [ '军委主席', '江泽民', new Date(1989, 11), new Date(2004, 9)], [ '军委主席', '胡锦涛', new Date(2004, 9), new Date(2012, 11)], [ '军委主席', '习近平', new Date(2012, 11), new Date()], [ '国务院总理', '周恩来', new Date(1949, 10, 1), new Date(1976, 1, 8)], [ '国务院总理', '华国锋', new Date(1976, 2, 2), new Date(1980, 9, 10)], [ '国务院总理', '赵紫阳', new Date(1980, 9, 10), new Date(1987, 11, 24)], [ '国务院总理', '李鹏', new Date(1987, 11, 24), new Date(1998, 3, 17)], [ '国务院总理', '朱镕基', new Date(1998, 3, 17), new Date(2003, 3, 16)], [ '国务院总理', '温家宝', new Date(2003, 3, 16), new Date(2013, 3, 15)], [ '国务院总理', '李克强', new Date(2013, 3, 15), new Date()]]); var options={'title':'中国最高领导人', 'height':220, 'language': 'ja'}; chart.draw(dataTable,options);}</script><div id="timeline-china" style="height: 200px;"></div></p><blockquote><p>邓小平一生未担任国家元首、政府首脑，或党内最高领导职务，但从1978年12月（中共十一届三中全会）至1989年11月辞去中共中央军委主席（中共十三届五中全会）一职前，普遍认为他是实际的最高领导人，并写入《中国共产党章程》予以确认。</p><p>1976-1981 华国锋任国家主席。1978年实权逐渐转移至邓小平。<br>1981-1982 胡耀邦任国家主席。由邓小平为首的中共元老掌握实权。<br>1982-1987 胡耀邦 总书记   在职期间由中共元老邓小平担任实际最高领导人。<br>1987-1989 赵紫阳 总书记   在职期间由中共元老邓小平担任实际最高领导人。</p></blockquote><h1 id="军委主席"><a href="#军委主席" class="headerlink" title="军委主席"></a>军委主席</h1><p>因此形式上存在<strong>两个中央军事委员会</strong>，即<code>中国共产党中央军事委员会</code>和<code>中华人民共和国中央军事委员会</code>，但是两个委员会的最高负责人（又分别称中共中央军委主席和国家军委主席）和副主席除了过渡时期外均为<strong>相同的人选</strong>。</p><h1 id="国家主席"><a href="#国家主席" class="headerlink" title="国家主席"></a>国家主席</h1><ul><li>邓小平指出：“还是要设国家主席，有国家主席代表国家比较好，但是对国家主席的职权可以规定得虚一点，不要管具体工作，不要干涉具体政务。”</li><li>1981年5月16日，第五届全国人民代表大会常务委员会第十八次会议决定，授予病危的宋庆龄“中华人民共和国名誉主席”荣誉称号。</li><li>1983年开始，中华人民共和国“主席”的官方英文译名由“Chairman”（直译为“主席”）改为“President”（可译为“总统”）。</li></ul><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li>维基百科</li></ul>]]></content>
      
      <categories>
          
          <category> others </category>
          
          <category> politics </category>
          
          <category> china </category>
          
          <category> 国家领袖 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 国家领导 </tag>
            
            <tag> 国家元首 </tag>
            
            <tag> 国家主席 </tag>
            
            <tag> 军委主席 </tag>
            
            <tag> 总书记 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>【Hexo插件系列】hexo-reference</title>
      <link href="/pub/dec3cfee/"/>
      <url>/pub/dec3cfee/</url>
      <content type="html"><![CDATA[<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> renderFootnotes = <span class="built_in">require</span>(<span class="string">'./src/footnotes'</span>);</span><br><span class="line">    util = <span class="built_in">require</span>(<span class="string">'hexo-util'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Register footnotes filter</span></span><br><span class="line">hexo.extend.filter.register(<span class="string">'before_post_render'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">  data.content = renderFootnotes(data.content);</span><br><span class="line">  <span class="keyword">return</span> data;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Add CDN CSS resources</span></span><br><span class="line">hexo.extend.filter.register(<span class="string">'after_post_render'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">  data.content =</span><br><span class="line">      util.htmlTag(<span class="string">'link'</span>, &#123;<span class="attr">rel</span>: <span class="string">'stylesheet'</span>, <span class="attr">type</span>: <span class="string">'text/css'</span>, <span class="attr">href</span>: <span class="string">'https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css'</span>&#125;) +</span><br><span class="line">      data.content;</span><br><span class="line">  <span class="keyword">return</span> data;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>是不是应该叫filter</p>]]></content>
      
      <categories>
          
          <category> CS </category>
          
          <category> web </category>
          
          <category> blog-framework </category>
          
          <category> nodejs-hexo </category>
          
          <category> plugin </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>【java源码系列】random的源码实现</title>
      <link href="/pub/6b34bb62/"/>
      <url>/pub/6b34bb62/</url>
      <content type="html"><![CDATA[<h1 id="API介绍"><a href="#API介绍" class="headerlink" title="API介绍"></a>API介绍</h1><ul><li>Math.random()方法来产生一个随机数，这个产生的随机数是0-1之间的一个double<br>-</li></ul><h1 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h1><h2 id="生成从1到10的int型随机数"><a href="#生成从1到10的int型随机数" class="headerlink" title="生成从1到10的int型随机数"></a>生成从1到10的int型随机数</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 方式一：</span></span><br><span class="line"><span class="keyword">int</span> i = (<span class="keyword">int</span>)(<span class="number">1</span>+Math.random()*(<span class="number">10</span>-<span class="number">1</span>+<span class="number">1</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方式二:</span></span><br><span class="line"><span class="keyword">int</span> i = random.nextInt(<span class="number">99</span>)+<span class="number">1</span>;</span><br></pre></td></tr></table></figure><h1 id="主要涉及的类"><a href="#主要涉及的类" class="headerlink" title="主要涉及的类"></a>主要涉及的类</h1><p><a href="https://github.com/dmlloyd/openjdk/blob/jdk8u/jdk8u/jdk/src/share/classes/java/util/Random.java" target="_blank" rel="noopener">java.util.Random</a></p><h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><p>Random从Jdk 1.0开始就有了，而<code>ThreadLocalRandom</code>是Jdk1.7才新增的。简单从命名和类所在的包上看，两者的区别在于对并发的支持。</p>]]></content>
      
      <categories>
          
          <category> CS </category>
          
          <category> programing </category>
          
          <category> lan </category>
          
          <category> java </category>
          
          <category> jdk </category>
          
          <category> rt </category>
          
          <category> lang </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> java源码 </tag>
            
            <tag> random </tag>
            
            <tag> 随机数 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>【数据分析篇】aspect-level 数据分析</title>
      <link href="/pub/27351887/"/>
      <url>/pub/27351887/</url>
      <content type="html"><![CDATA[<p>SemEval 2014 Task 4</p><p>Read train 2990, test 973</p><p>长度 20以下的，Trimmed to train 2124, test 692</p><p>数据量好少，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">and cheap !</span><br><span class="line">price</span><br><span class="line">1</span><br><span class="line">the staff is n&apos;t the friendliest or most competent , and i am stickler for service , but everything else about this place makes up for it .</span><br><span class="line">service</span><br><span class="line">-1</span><br><span class="line">the service is always bad though , do n&apos;t expect much of anything from your server , and i would not recommend bringing a date here either .</span><br><span class="line">service</span><br><span class="line">-1</span><br><span class="line">i absolutely love this place ! ! !</span><br><span class="line">miscellaneous</span><br><span class="line">1</span><br><span class="line">a restaurant that does n&apos;t try to do anything except serve great food with great service in a pleasant atmosphere .</span><br><span class="line">ambience</span><br><span class="line">1</span><br><span class="line">this place was not all that !</span><br><span class="line">miscellaneous</span><br><span class="line">-1</span><br><span class="line">the food is great .</span><br><span class="line">food</span><br><span class="line">1</span><br><span class="line">highly recommended ! ! ! ! !</span><br><span class="line">miscellaneous</span><br><span class="line">1</span><br><span class="line">the food was really good , i had the onion soup and it was one of the best ever .</span><br><span class="line">food</span><br><span class="line">1</span><br><span class="line">a++ the service was good to excellent along with the attitude .</span><br><span class="line">service</span><br><span class="line">1</span><br><span class="line">we had a 3 hour brunch- they definitely do not rush you- and they kept the unlimited mimosas flowing the whole time .</span><br><span class="line">service</span><br><span class="line">1</span><br><span class="line">i &apos;ve been eating at taj mahal for over twenty years and have found them to be the most excellent of the indian eateries on this block of indian restaurants .</span><br><span class="line">miscellaneous</span><br><span class="line">1</span><br><span class="line">anyway , the food is good , the price is right and they have a decent wine list .</span><br><span class="line">price</span><br><span class="line">1</span><br></pre></td></tr></table></figure><p>基于aspect的情感分析指的是挖掘句子中涉及的aspect，以及对每个aspect表现出来的情感。</p><p>现有的工作一般把这个任务分成两个部分：aspect识别，可以是aspect term提取或者aspect分类；aspect的情感识别</p><h2 id="aspect-term提取"><a href="#aspect-term提取" class="headerlink" title="aspect term提取"></a>aspect term提取</h2><h1 id="待阅读"><a href="#待阅读" class="headerlink" title="待阅读"></a>待阅读</h1><ul><li><a href="http://zhaoxueli.win/2017/03/06/%E5%9F%BA%E4%BA%8E-Aspect-%E7%9A%84%E6%83%85%E6%84%9F%E5%88%86%E6%9E%90/" target="_blank" rel="noopener">http://zhaoxueli.win/2017/03/06/%E5%9F%BA%E4%BA%8E-Aspect-%E7%9A%84%E6%83%85%E6%84%9F%E5%88%86%E6%9E%90/</a></li><li><a href="https://www.jianshu.com/p/227053b4a85c" target="_blank" rel="noopener">https://www.jianshu.com/p/227053b4a85c</a></li></ul>]]></content>
      
      <categories>
          
          <category> ML </category>
          
          <category> applications </category>
          
          <category> nlp </category>
          
          <category> text_classification </category>
          
          <category> datasets </category>
          
          <category> aspect </category>
          
      </categories>
      
      
        <tags>
            
            <tag> dataset </tag>
            
            <tag> 数据分析 </tag>
            
            <tag> 文本分类 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>【深度学习-模型系列】word2vec</title>
      <link href="/pub/f6ca296f/"/>
      <url>/pub/f6ca296f/</url>
      <content type="html"><![CDATA[<h1 id="优化目标"><a href="#优化目标" class="headerlink" title="优化目标"></a>优化目标</h1><p>分类。词典大小是N，那么就是N分类。</p><p>弊端：</p><ul><li>【策略一】转化为二叉树，多个二分类。即<code>Hierarchical Softmax</code></li><li>【策略二】直接视为二分类：中心词w和context(w)相关，是正例，其他word都是负例<ul><li>负例太多，所以采用<code>Negative Sampling</code></li></ul></li></ul><p>论文采用<code>Negative Sampling</code>了吗？</p><h2 id="Hierarchical-Softmax"><a href="#Hierarchical-Softmax" class="headerlink" title="Hierarchical Softmax"></a>Hierarchical Softmax</h2><p>Hierarchical Softmax的缺点：有缺点吗？二叉树没毛病啊，复杂度也不高</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 默认采用cbow模型</span></span><br><span class="line">cbow = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 默认不用`Hierarchical Softmax`</span></span><br><span class="line"><span class="keyword">int</span> hs = <span class="number">0</span>, negative = <span class="number">5</span>;</span><br></pre></td></tr></table></figure><ul><li><a href="https://github.com/tmikolov/word2vec/blob/master/word2vec.c#L449" target="_blank" rel="noopener">基于Hierarchical Softmax的CBOW模型 源码</a></li><li><a href="https://github.com/tmikolov/word2vec/blob/master/word2vec.c#L505" target="_blank" rel="noopener">基于Hierarchical Softmax的Skip-Gram模型 源码</a></li><li>两者能同时都用吧。即采样负例后，再HS，可以减少HS的编码吗？</li></ul><p>Use Hierarchical Softmax; default is 0 (not used)</p><h2 id="Negative-Sampling"><a href="#Negative-Sampling" class="headerlink" title="Negative Sampling"></a>Negative Sampling</h2><ul><li><a href="https://github.com/tmikolov/word2vec/blob/master/word2vec.c#L464" target="_blank" rel="noopener">基于Negative Sampling的CBOW模型 源码</a></li><li><a href="https://github.com/tmikolov/word2vec/blob/master/word2vec.c#L520" target="_blank" rel="noopener">基于Negative Sampling的Skip-Gram模型 源码</a><br>-</li></ul><p>比如我们有一个训练样本，中心词是w,它周围上下文共有2c个词，记为context(w)。由于这个中心词w,的确和context(w)相关存在，因此它是一个真实的正例。通过Negative Sampling采样，我们得到neg个和w不同的中心词wi,i=1,2,..neg，这样context(w)和$$w<em>i$就组成了neg个并不真实存在的负例。利用这一个正例和neg个负例，我们进行二元逻辑回归，得到负采样对应每个词$w_i$对应的模型参数$\theta</em>{i}$，和每个词的词向量。</p><blockquote><p>Negative Sampling由于没有采用霍夫曼树，每次只是通过采样neg个不同的中心词做负例，就可以训练模型，因此整个过程要比Hierarchical Softmax简单。</p></blockquote><p>Negative Sampling可否也用霍夫曼树？貌似还真不能？HS和NS貌似是冲突的。</p><h1 id="疑问"><a href="#疑问" class="headerlink" title="疑问"></a>疑问</h1><p>为什么叫CBOW（ Continuous Bag-Of-Words，即连续的词袋模型） 和 Skip-Gram？</p><h1 id="缺陷"><a href="#缺陷" class="headerlink" title="缺陷"></a>缺陷</h1><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li><a href="https://blog.csdn.net/itplus/" target="_blank" rel="noopener">word2vec 中的数学原理详解 | CSDN</a></li></ul><h1 id="live-demo"><a href="#live-demo" class="headerlink" title="live demo"></a>live demo</h1><p><a href="http://projector.tensorflow.org" target="_blank" rel="noopener">http://projector.tensorflow.org</a></p><iframe width="100%" height="800" scrolling="no" src="http://projector.tensorflow.org/"></iframe><h1 id="TODO：扩展demo"><a href="#TODO：扩展demo" class="headerlink" title="TODO：扩展demo"></a>TODO：扩展demo</h1><ul><li>word2vec的可视化<ul><li>给定word1 出word2</li><li>显示vector向量</li><li>一个word与一组word的相似度。用attention可视化。</li><li>向量计算，比如king - man + woman = queen</li></ul></li></ul>]]></content>
      
      <categories>
          
          <category> ML </category>
          
          <category> deep learning </category>
          
          <category> model </category>
          
      </categories>
      
      
        <tags>
            
            <tag> word2vec </tag>
            
            <tag> deep learning </tag>
            
            <tag> hierarchical softmax </tag>
            
            <tag> negative sampling </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>【java源码】HashMap</title>
      <link href="/pub/1b7bcecc/"/>
      <url>/pub/1b7bcecc/</url>
      <content type="html"><![CDATA[<p><a href="https://github.com/dmlloyd/openjdk/blob/jdk7u/jdk7u/jdk/src/share/classes/java/util/HashMap.java" target="_blank" rel="noopener">java 7的HashMap源码</a></p><p><a href="https://github.com/dmlloyd/openjdk/blob/jdk8u/jdk8u/jdk/src/share/classes/java/util/HashMap.java" target="_blank" rel="noopener">java 8的HashMap源码</a></p><h1 id="历史"><a href="#历史" class="headerlink" title="历史"></a>历史</h1><ul><li>java 1.0 中没有HashMap，有<a href="https://github.com/BitMindLab/JDK-1.0.2/blob/master/src/java/util/Hashtable.java" target="_blank" rel="noopener">HashTable</a></li><li>java 1.2 引入HashMap</li><li>java 7</li><li>java 8</li></ul><p>主要区别</p><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> CS </category>
          
          <category> programing </category>
          
          <category> lan </category>
          
          <category> java </category>
          
          <category> jdk </category>
          
          <category> rt </category>
          
          <category> util </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>【java源码】准备篇</title>
      <link href="/pub/eab986ce/"/>
      <url>/pub/eab986ce/</url>
      <content type="html"><![CDATA[<h1 id="关于版本号"><a href="#关于版本号" class="headerlink" title="关于版本号"></a>关于版本号</h1><p>7是指jdk版本  7.0版本  u是update 更新的意思  45 是第45次更新</p><p>为什么要新建u开头的project？<a href="http://openjdk.java.net/projects/jdk8u/qanda.html" target="_blank" rel="noopener">http://openjdk.java.net/projects/jdk8u/qanda.html</a></p><p>b07是不是发布JDK6u1时，JDK6作为开发分支的最后一个buid号？<br>每个release（无论是大版本的第一个release还是后面小版本的update release）在真的发布前都会经过很多次build。开发过程中通常是每周一build来做整合测试，临发布前会选择一个build作为候选版本跑更完整的测试，当这些测试都通过之后就发布。<br>所以6u18b07的意思就是针对JDK 6 update 18这个release，这是第07个build。<br>每个release的build number都是独立递增的，从1开始。</p><h1 id="JDK源码"><a href="#JDK源码" class="headerlink" title="JDK源码"></a>JDK源码</h1><h2 id="openJDK"><a href="#openJDK" class="headerlink" title="openJDK"></a>openJDK</h2><ul><li>官方源码：<a href="http://hg.openjdk.java.net/" target="_blank" rel="noopener">http://hg.openjdk.java.net/</a>  采用<code>Mercurial(Hg)</code>管理，类似git</li><li><code>Github</code>镜像：<a href="https://github.com/dmlloyd/openjdk" target="_blank" rel="noopener">https://github.com/dmlloyd/openjdk</a>  <ul><li>这是对<code>官方Git仓库</code>的实时同步。很赞。怎么做到的？用的github插件？</li></ul></li></ul><p>阅读笔记</p><ul><li>Jdk1.8源码解析 <a href="https://github.com/wupeixuan/JDKSourceCode1.8" target="_blank" rel="noopener">https://github.com/wupeixuan/JDKSourceCode1.8</a></li><li>JDK源码阅读笔记 <a href="https://github.com/seaswalker/JDK" target="_blank" rel="noopener">https://github.com/seaswalker/JDK</a></li><li><a href="https://github.com/codefollower/OpenJDK-Research" target="_blank" rel="noopener">https://github.com/codefollower/OpenJDK-Research</a></li></ul><h2 id="Oracle-JDK"><a href="#Oracle-JDK" class="headerlink" title="Oracle JDK"></a>Oracle JDK</h2>]]></content>
      
      <categories>
          
          <category> CS </category>
          
          <category> programing </category>
          
          <category> lan </category>
          
          <category> java </category>
          
          <category> jdk </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> java源码 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>文本分类 - 综述</title>
      <link href="/pub/eae469b0/"/>
      <url>/pub/eae469b0/</url>
      <content type="html"><![CDATA[<h2 id="任务"><a href="#任务" class="headerlink" title="任务"></a>任务</h2><ul><li>短文本分类</li><li>长文本分类</li><li>超短文本(一个word)分类</li></ul><p>特定领域的文本分类</p><ul><li>aspect-level classification</li><li>ss</li></ul><h2 id="methods"><a href="#methods" class="headerlink" title="methods:"></a>methods:</h2><ul><li><p>word-level</p><ul><li>tfidf + svm/lr</li><li>fastText facebook (只是作为baseline而已)</li><li>lstm bilstm</li><li>lstm + attention</li><li><a href="TextCNN">cnn</a>  <a href="TextCNN-code">code1</a> <a href="TextCNN-code">code2</a></li><li>gated cnn</li><li><a href="RNN+CNN">rcnn</a></li></ul></li><li><p>char-level</p><ul><li>char的作用？ 见NLP.md</li><li>char cnn  (Zhang and LeCun, 2015)</li><li>char rnn</li><li>char-CRNN (Xiao and Cho, 2016)</li><li>char-rnn + word rnn (Finding Function in Form: Compositional Character Models for Open Vocabulary Word Representation)  </li><li>char-cnn + word rnn</li></ul></li><li>Hierarchical:<ul><li>char + word:</li><li>word + sentence: <a href="[RNN+Attention]">Hierarchical Attention</a></li><li>char + word + sentence:</li></ul></li></ul><h2 id="datasets-amp"><a href="#datasets-amp" class="headerlink" title="datasets &amp;"></a>datasets &amp;</h2><h2 id="paper-amp-implementation"><a href="#paper-amp-implementation" class="headerlink" title="paper &amp; implementation"></a>paper &amp; implementation</h2><p>[TextCNN]: Convolutional Neural Networks for Sentence Classification</p><p>[TextRNN]: Recurrent Neural Network for Text Classification with Multi-Task Learning<br>[TextRNN-code]:</p><p>[RNN+Attention]: Hierarchical Attention Networks for Document Classification<br><a href="http://www.jianshu.com/p/4fbc4939509f" target="_blank" rel="noopener">http://www.jianshu.com/p/4fbc4939509f</a></p><p>[RNN+CNN]: Recurrent Convolutional Neural Networks for Text Classification. AAAI. 2015.</p><p>[fastText]:</p><ul><li>three papers.  <a href="https://github.com/facebookresearch/fastText" target="_blank" rel="noopener">https://github.com/facebookresearch/fastText</a>  in C++<ul><li>[1] P. Bojanowski<em>, E. Grave</em>, A. Joulin, T. Mikolov, Enriching Word Vectors with Subword Information</li><li>[2] A. Joulin, E. Grave, P. Bojanowski, T. Mikolov, Bag of Tricks for Efficient Text Classification</li><li>[3] A. Joulin, E. Grave, P. Bojanowski, M. Douze, H. Jégou, T. Mikolov, FastText.zip: Compressing text classification models</li></ul></li><li><a href="https://github.com/scharmchi/char-level-cnn-tf" target="_blank" rel="noopener">https://github.com/scharmchi/char-level-cnn-tf</a></li><li>!!!!!! char-level deep learning  <a href="https://offbit.github.io/how-to-read/" target="_blank" rel="noopener">https://offbit.github.io/how-to-read/</a>    <a href="https://github.com/offbit/char-models" target="_blank" rel="noopener">https://github.com/offbit/char-models</a></li></ul><h2 id="tutorial-amp-survey-amp-blog"><a href="#tutorial-amp-survey-amp-blog" class="headerlink" title="tutorial &amp; survey &amp; blog"></a>tutorial &amp; survey &amp; blog</h2><p><a href="http://www.jeyzhang.com/cnn-apply-on-modelling-sentence.html" target="_blank" rel="noopener">http://www.jeyzhang.com/cnn-apply-on-modelling-sentence.html</a><br><a href="https://zhuanlan.zhihu.com/p/25928551" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/25928551</a></p><h2 id="web-service"><a href="#web-service" class="headerlink" title="web service"></a>web service</h2><pre><code>1. watson NLC: https://www.ibm.com/watson/developercloud/natural-language-classifier/api/v12. songfang NLC</code></pre><h1 id="code"><a href="#code" class="headerlink" title="code"></a>code</h1><ul><li>模型汇总 <a href="https://github.com/brightmart/text_classification" target="_blank" rel="noopener">https://github.com/brightmart/text_classification</a></li></ul>]]></content>
      
      <categories>
          
          <category> ML </category>
          
          <category> applications </category>
          
          <category> nlp </category>
          
          <category> text_classification </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>【对话系统】之ChatterBot</title>
      <link href="/pub/5bd088c3/"/>
      <url>/pub/5bd088c3/</url>
      <content type="html"><![CDATA[<h1 id="快速搭建"><a href="#快速搭建" class="headerlink" title="快速搭建"></a>快速搭建</h1><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ pip install chatterbot</span><br></pre></td></tr></table></figure><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> chatterbot <span class="keyword">import</span> ChatBot</span><br><span class="line"></span><br><span class="line">chatbot = ChatBot(</span><br><span class="line">    <span class="string">'Ron Obvious'</span>,</span><br><span class="line">    trainer=<span class="string">'chatterbot.trainers.ChatterBotCorpusTrainer'</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Train based on the english corpus</span></span><br><span class="line">chatbot.train(<span class="string">"chatterbot.corpus.chinese"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Get a response to an input statement</span></span><br><span class="line">chatbot.get_response(<span class="string">"你是谁"</span>)</span><br></pre></td></tr></table></figure><h1 id="后台算法"><a href="#后台算法" class="headerlink" title="后台算法"></a>后台算法</h1><p><a href="https://chatterbot.readthedocs.io/en/stable/faq.html#what-kinds-of-machine-learning-does-chatterbot-use" target="_blank" rel="noopener">https://chatterbot.readthedocs.io/en/stable/faq.html#what-kinds-of-machine-learning-does-chatterbot-use</a></p><p>基于搜索和分类</p><ul><li>搜索</li><li>分类<ul><li>利用朴素贝叶斯 判断是否 <code>an input statement meets a particular set of criteria that warrant a response</code><br><br> 说的好模糊</li></ul></li></ul>]]></content>
      
      <categories>
          
          <category> ML </category>
          
          <category> applications </category>
          
          <category> nlp </category>
          
          <category> conversation </category>
          
          <category> 系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 聊天机器人 </tag>
            
            <tag> 对话系统 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>spiking neural network 脉冲神经网络</title>
      <link href="/pub/fee0b5e6/"/>
      <url>/pub/fee0b5e6/</url>
      <content type="html"><![CDATA[<h1 id="生物学背景"><a href="#生物学背景" class="headerlink" title="生物学背景"></a>生物学背景</h1><p><a href="https://zh.wikipedia.org/wiki/%E7%A5%9E%E7%BB%8F%E7%A7%91%E5%AD%A6" target="_blank" rel="noopener">神经科学</a>（英语：neuroscience），又称神经生物学，是专门研究神经系统的结构、功能、发育、演化、遗传学、生物化学、生理学、药理学及病理学的一门科学。对行为及学习的研究都是神经科学的分支。</p><p>对人脑研究是个跨领域的范畴，当中涉及分子层面、细胞层面、神经小组、大型神经系统，如视觉神经系统、脑干、脑皮层。</p><p>最高层次的研究就是结合<code>认知科学</code>成为认知神经科学，其专家被称为认知心理学家。一些研究人员相信认知神经科学提供对思维及知觉的全面了解，甚至可以代替心理学。</p><h2 id="神经元结构"><a href="#神经元结构" class="headerlink" title="神经元结构"></a>神经元结构</h2><table class="toccolours" style="width:410px; margin:0 0 5px 10px; "><tbody><tr style="text-align: center;"></tr><tr style="text-align: center;"><th style="background:white"><div style="position: relative;"><a href="/wiki/File:Neuron_Hand-tuned.svg" class="image"><img alt="Neuron Hand-tuned.svg" src="https://upload.wikimedia.org/wikipedia/commons/thumb/b/bc/Neuron_Hand-tuned.svg/400px-Neuron_Hand-tuned.svg.png" width="400" height="215" srcset="//upload.wikimedia.org/wikipedia/commons/thumb/b/bc/Neuron_Hand-tuned.svg/600px-Neuron_Hand-tuned.svg.png 1.5x, //upload.wikimedia.org/wikipedia/commons/thumb/b/bc/Neuron_Hand-tuned.svg/800px-Neuron_Hand-tuned.svg.png 2x" data-file-width="1179" data-file-height="634"></a><div style="position: absolute; left:50px; top: 2px; color:"><a class="mw-selflink selflink">树突</a></div><div style="position: absolute; left:135px; top: 60px; color:"><a href="/wiki/%E7%BB%86%E8%83%9E" title="细胞">细胞体</a></div><div style="position: absolute; left:189px; top: 116px; color:"><a href="/wiki/%E8%BB%B8%E7%AA%81" class="mw-redirect" title="轴突">轴突</a></div><div style="position: absolute; left:13px; top: 197px; color:"><a href="/wiki/%E7%B4%B0%E8%83%9E%E6%A0%B8" class="mw-redirect" title="细胞核">细胞核</a></div><div style="position: absolute; left:226px; top: 38px; color:"><a href="/wiki/%E8%98%AD%E6%B0%8F%E7%B5%90" title="兰氏结">兰氏结</a></div><div style="position: absolute; left:319px; top: 0px; color:"><a href="/wiki/%E7%AA%81%E8%A7%B8" class="mw-redirect" title="突触">突触</a></div><div style="position: absolute; left:306px; top: 161px; color:"><a href="/wiki/%E6%96%BD%E6%97%BA%E7%B4%B0%E8%83%9E" title="施旺细胞">施旺细胞</a></div><div style="position: absolute; left:220px; top: 187px; color:"><a href="/wiki/%E9%AB%93%E9%9E%98" class="mw-redirect" title="髓鞘">髓鞘</a></div></div></th></tr><tr><th style="text-align: left; line-height: 1;"><center>典型神经元的结构(来自wikipedia)</center></th></tr></tbody></table><ul><li><p>树突为神经元的输入通道，其功能是将自其他神经元所接收的动作电位（电信号）传送至细胞本体。其他神经元的动作电位借由位于树突分支上的多个突触传送至树突上。与长度可达约1米的轴突相比，树突通常较短。</p></li><li><p>轴突（Axon）由神经元组成，即神经细胞之细胞本体长出突起，功能为传递细胞本体之动作电位至突触。</p></li></ul><h2 id="生物学功能"><a href="#生物学功能" class="headerlink" title="生物学功能"></a>生物学功能</h2><ul><li><p>陈述性记忆：对事件、人物等有意识回忆，相对容易记住和忘记</p></li><li><p>非陈述性记忆：对抽象、感知、动作和习惯等无意识操作</p></li><li><p><a href="https://zhuanlan.zhihu.com/p/26657313" target="_blank" rel="noopener">突触可塑性</a>（Synaptic plasticity）指神经细胞间的连接，即突触，其连接强度可调节的特性。突触可塑性的产生有多种原因，例如：突触中释放的神经递质数量的变化，细胞对神经递质的反应效率。突触可塑性被认为是构成记忆和学习的重要神经化学基础。</p></li></ul><h2 id="脉冲"><a href="#脉冲" class="headerlink" title="脉冲"></a>脉冲</h2><blockquote><p>Biological neurons use <code>short and sudden increases</code> in voltage to send information.<br>action potentials, spikes or pulses.</p></blockquote><h1 id="SNN-脉冲神经网络"><a href="#SNN-脉冲神经网络" class="headerlink" title="SNN 脉冲神经网络"></a>SNN 脉冲神经网络</h1><image width="50%" title="integrate-and-fire neuron" src="/images/raw/NN - spiking - integrate and fire.jpg"><h1 id="信息承载"><a href="#信息承载" class="headerlink" title="信息承载"></a>信息承载</h1><p>SNN的信息承载，仅仅是靠脉冲频率吗？等价于二值的普通编码吗？</p><blockquote><p>neurons encode information in the timing of single spikes, and not only just in their average<br>firing frequency.</p></blockquote><h1 id="独特之处"><a href="#独特之处" class="headerlink" title="独特之处"></a>独特之处</h1><blockquote><p>they can encode temporal information in their signals, but therefore do also need different and biologically more plausible rules for synaptic plasticity.</p></blockquote><h1 id="疑问"><a href="#疑问" class="headerlink" title="疑问"></a>疑问</h1><p>SNN的图像分类等常见任务上效果怎样？</p><p>SNN的优势是什么，独特之处是什么？</p><p>一个image怎样转化成脉冲作为网络输入？</p><p>firing rate表示信号强弱，单个脉冲有什么意义？</p></image>]]></content>
      
      <categories>
          
          <category> ML </category>
          
          <category> deep learning </category>
          
          <category> model </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SNN </tag>
            
            <tag> spiking neural network </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>机器学习中的正则化约束 - 结构风险</title>
      <link href="/pub/7c29b6b9/"/>
      <url>/pub/7c29b6b9/</url>
      <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p> 结构风险（structural risk）：描述模型与训练样本的拟合程度，以及模型的复杂程度。</p><p>正则化的由来<br>　　有几种角度来看待正则化(Regularization)，它符合奥卡姆剃刀(Occam’s razor)原理：在所有可能选择的模型中，能够很好地解释已知数据并且十分简单的才是最好的模型。从贝叶斯估计的角度来看，正则化项对应于模型的先验概率。还有个说法就是，正则化是结构风险最小化策略的实现，是在经验风险上加一个正则化项(regularization term)或惩罚项(penalty term)或权重衰减项(weight decay term)。</p><!--It tends to decrease the magnitude of the weights, and helps prevent overfitting--><p>　　高维统计分析模型通常都是稀疏模型，即真正有效的变量只占一小部分，绝大多数变量都是噪声数据。因此当模型的参数过多时，不仅无法提高模型的解释力，反而会降低模型的解释力。<br>　　在这个背景下，统计学家提出了各种各样的变量选择方法来筛选模型中重要的解释变量，从而防止过拟合问题。其中正则化是最常用的一种方法，而正则化方法中最常见的就是L0, L1 和L2范数。</p><p>　　正则化方法的思想：处理最优化函数问题时，在目标函数中加入对参数的约束惩罚项，从而达到简化模型的目的。</p><h1 id="常见的结构风险"><a href="#常见的结构风险" class="headerlink" title="常见的结构风险"></a>常见的结构风险</h1><p>L0范数：就是指矩阵中非零元素的个数，很显然，在损失函数后面加上L0正则项就能够得到稀疏解，但是L0范数很难求解，是一个NP问题，因此转为求解相对容易的L1范数（l1能够实现稀疏性是因为l1是L0范数的最优凸近似）</p><h2 id="L1"><a href="#L1" class="headerlink" title="L1"></a>L1</h2><p>L1正则化使得模型更加稀疏，</p><p>L1范数：矩阵中所有元素的绝对值的和。损失函数后面加上L1正则项就成了著名的Lasso问题（Least Absolute Shrinkage and Selection Operator），L1范数可以约束方程的稀疏性，该稀疏性可应用于特征选择：<br>比如，有一个分类问题，其中一个类别Yi(i=0,1),特征向量为Xj（j=0,1~~~1000），那么构造一个方程<br>Yi = W0<em>X0+W1</em>X1···Wj<em>Xj···W1000</em>X1000+b;<br>其中W为权重系数，那么通过L1范数约束求解，得到的W系数是稀疏的，那么对应的X值可能就是比较重要的，这样就达到了特征选择的目的</p><p>L1 正则化在零点不可微，因此权重以趋近于零的常数因子增长。很多神经网络在权重衰减公式中使用一阶步骤来解决非凸 L1 正则化问题。</p><p>elastic net 的提出 是为了 可以解决feature之间的 高相关性 问题，单纯Lasso 一般会在一个 高相关性 的 特征group 里面选取一个显著特征， zou 的paper 里面有相关证明。 当然解决 高相关性的方法还有 group lasso ， general fused lasso 等<br>从几何解释来讲 elastic net 很像 L1 到 L2 之间一个 penalty， 但不同之处在于 elastic net 具有 L1 的特性，sparsity， 函数并不是smooth 的。这个具体可以参考 Element of statistical learning 的第三章。</p><p><a href="https://www.zhihu.com/question/38081976" target="_blank" rel="noopener">https://www.zhihu.com/question/38081976</a></p><h2 id="L2"><a href="#L2" class="headerlink" title="L2"></a>L2</h2><p>二范数，等价于Gauss共轭先验</p><p>L2使得模型参数更趋近于0，提高泛化能力</p><h2 id="稀疏约束"><a href="#稀疏约束" class="headerlink" title="稀疏约束"></a>稀疏约束</h2><h3 id="普通参数的稀疏约束"><a href="#普通参数的稀疏约束" class="headerlink" title="普通参数的稀疏约束"></a>普通参数的稀疏约束</h3><p>一范数，等价于Laplace共轭先验</p><h3 id="归一化后的参数稀疏"><a href="#归一化后的参数稀疏" class="headerlink" title="归一化后的参数稀疏"></a>归一化后的参数稀疏</h3><script type="math/tex; mode=display">P=(p_1,p_2...p_n)</script><ul><li><p>共轭先验是狄利克雷分布，可通过先验参数控制稀疏程度。</p></li><li><p>可用二范数</p></li><li><p>可用1范数。</p></li></ul><h2 id="其他约束"><a href="#其他约束" class="headerlink" title="其他约束"></a>其他约束</h2><ol><li><p>正交约束：<br>AA’ = 对角阵</p></li><li><p>单位正交约束：<br>AA’ = I</p></li><li><p>另外sum=1 + 平方和=1<br>这就是稀疏约束。</p></li></ol><p>AA’为对角阵</p><p>|AA’-E|_2</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="http://www.cnblogs.com/stevenlk/p/6247992.html" target="_blank" rel="noopener">http://www.cnblogs.com/stevenlk/p/6247992.html</a></p>]]></content>
      
      <categories>
          
          <category> ML </category>
          
          <category> machine learning 传统方法 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>倒排索引的分布式存储</title>
      <link href="/pub/684b5b69/"/>
      <url>/pub/684b5b69/</url>
      <content type="html"><![CDATA[<p>倒排索引又叫反向索引</p><h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>索引数据的规模为TB级。TB相当于1 000 GB，一个1 000 GB的文件是不可想象的。因此将<strong>全部索引文件存放在一台主机上，不仅是不合适的，而且是不安全的</strong>。这样一旦这个倒排文件损坏，全部服务就会受到很大影响，因此倒排索引的<code>分布式存储</code>技术应运而生了。</p><h2 id="大数据遇到的问题"><a href="#大数据遇到的问题" class="headerlink" title="大数据遇到的问题"></a>大数据遇到的问题</h2><h3 id="单机的瓶颈"><a href="#单机的瓶颈" class="headerlink" title="单机的瓶颈"></a>单机的瓶颈</h3><ul><li>存储：索引数据大</li><li>网络：传输瓶颈(网络负载)，尽量减少网络开销</li><li>磁盘I/O：</li></ul><h3 id="多机需要解决的问题-集群或分布式"><a href="#多机需要解决的问题-集群或分布式" class="headerlink" title="多机需要解决的问题 (集群或分布式)"></a>多机需要解决的问题 (集群或分布式)</h3><ul><li>数据倾斜问题</li><li>可靠性</li><li>网络</li><li>查询速度，memory db？如何</li></ul><h3 id="策略"><a href="#策略" class="headerlink" title="策略"></a>策略</h3><p>如何解决以上各种问题？</p><ul><li>没什么特别好的办法…就是各种<code>切分索引</code>，然后把<code>结果合并</code>之类的</li></ul><p>常见操作</p><ul><li>重建索引 周期性重建索引</li><li>基于主索引的前提下，构建辅助索引，用于储存新文档，维护于内存中，当辅助索引达到一定的内存占用时，写入磁盘与主索引进行合并；</li></ul><p>种切分索引，然后把结果合并之类的</p><p>服务功能的分布式拆分</p><ul><li>尽量减少网络开销</li><li>各个子服务应该是无状态的</li><li>每个子服务都应该是可横向扩展的</li></ul><h1 id="分布式-VS-集群"><a href="#分布式-VS-集群" class="headerlink" title="分布式 VS 集群"></a>分布式 VS 集群</h1><p>数据的分布式拆分</p><ul><li>搜索引擎索引分片</li><li>Log</li></ul><p>参考 <a href="https://juejin.im/entry/58abf9432f301e006bdbc373" target="_blank" rel="noopener">https://juejin.im/entry/58abf9432f301e006bdbc373</a></p><h1 id="常见疑问"><a href="#常见疑问" class="headerlink" title="常见疑问"></a>常见疑问</h1><h2 id="切分索引"><a href="#切分索引" class="headerlink" title="切分索引"></a>切分索引</h2><p>多机分布式索引一般按照文档编号(<code>docId</code>)或者按照索引词编号(<code>wordId</code>)进行划分。按照DocId划分的结果称为<code>局部倒排文</code>件（Local inverted file）；按照WordId划分的结果称为<code>全局倒排文件</code>（Global inverted file）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">apple -&gt; 1, 13, 24, 33, 46, 52, 77</span><br><span class="line">banana -&gt; 4, 8, 33, 34, 52, 66, 88</span><br><span class="line">grapes -&gt; 7, 22, 46, 77, 89</span><br><span class="line">pineapple -&gt; 15, 37, 52</span><br><span class="line">delicious -&gt; 24, 34, 46, 77, 89</span><br><span class="line">rotten -&gt; 8, 66</span><br><span class="line">exotic -&gt; 37</span><br></pre></td></tr></table></figure><p>按照<code>docid</code>来切分，比如<code>1-100</code>和<code>101-200</code>分在不同的服务器。</p><p>按照<code>wordid</code>来切分，比如<code>apple</code> <code>banana</code>分在不同的服务器。</p><div class="table-container"><table><thead><tr><th>group_by</th><th>term (全局方案)</th><th>index (局部倒排文件)</th><th></th><th></th></tr></thead><tbody><tr><td>index的获取</td><td>并行度=term数</td><td>并行度不限</td><td></td><td></td></tr><tr><td>网络负载</td><td>单点压力大</td><td>分布式结点分担网络负载</td><td></td><td></td></tr><tr><td>磁盘IO</td><td>节约磁盘I/O (如果只检索一个单词，那么只需要在一个索引结点中检索即可)</td><td></td><td></td><td></td></tr><tr><td>可靠性</td><td>单点故障很危险</td><td>单点故障影响不大</td><td></td></tr></tbody></table></div><p>索引的存储结果我们人为能看到的就是segment文件，其实索引文件segment的下层结构就是field域（类似于数据库里面的列名，但是这两个概念区别还是蛮大的，只是拿过来类比），对于每一个field里面存储的就是倒排文件，而我们进行查询的过程时，为了加快查询效率就会制定field域去查询，对于每一个term来说会·去查找字典的一种结构（现在存储结构有FST（英文字典存储结构），前缀树等），因为字典是已经排好序的了，所以这里只需要进行二分查找就可以了，对于每一个term查找到的倒排链进行交集或者并集的合并，在合并的过程若要是按照文本相关性排序（不指定排序股则），就会在合并的过程中会进行相关的score分数计算（例如BM25，或者TF-IDF等一些算法），计算出来的文档会存储在一个top-N的小根堆里面，最后返回给用户。对于倒排链的合并过程交集是一个比较消耗性能的操作，比如lucene对于OR操作的优化比较多，比如说把现在N条倒排链按照长度排序（短的文档在前，长的在后），然后分成两组最短的1条一个组，剩下的N-1条一组，然后对于这两个组进行合并。在OR的合并过程中，可以指定最少有几个term满足要求，这样在前N-1中要是没有满足要求，这样最后一条就不需要在进行合并了。</p><h1 id=""><a href="#" class="headerlink" title="#"></a>#</h1><p>倒排索引，当有100台server，要把索引表</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">An inverted index is used to support text search. The inverted index has a record for each term. Each record has the list of documents that the term appears in. Documents are identified by an integer document ID. The list of document IDs is sorted in ascending order. For the purpose of this problem, assume that the only operation performed on the inverted index is intersection to find the documents that contain all terms in the search query.</span></span><br><span class="line"><span class="comment">For example, the inverted index could have the following data.</span></span><br><span class="line"><span class="comment">Term</span></span><br><span class="line"><span class="comment">Document IDs</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">apple -&gt; 1, 13, 24, 33, 46, 52, 77</span></span><br><span class="line"><span class="comment">banana -&gt; 4, 8, 33, 34, 52, 66, 88</span></span><br><span class="line"><span class="comment">grapes -&gt; 7, 22, 46, 77, 89</span></span><br><span class="line"><span class="comment">pineapple -&gt; 15, 37, 52</span></span><br><span class="line"><span class="comment">delicious -&gt; 24, 34, 46, 77, 89</span></span><br><span class="line"><span class="comment">rotten -&gt; 8, 66</span></span><br><span class="line"><span class="comment">exotic -&gt; 37</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">Expected results from intersections are as follows:</span></span><br><span class="line"><span class="comment">Terms intersected</span></span><br><span class="line"><span class="comment">Document IDs with all terms</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">delicious apple -&gt; 24, 46, 77</span></span><br><span class="line"><span class="comment">delicious apple grapes -&gt; 46, 77</span></span><br><span class="line"><span class="comment">apple banana -&gt; 33, 52</span></span><br><span class="line"><span class="comment">We have an inverted index that is very large and requires N servers to "fit". Assume N is 100.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* This class will be given a list of words (such as might be tokenized</span></span><br><span class="line"><span class="comment"> * from a paragraph of text), and will provide a method that takes two</span></span><br><span class="line"><span class="comment"> * words and returns the shortest distance (in words) between those two</span></span><br><span class="line"><span class="comment"> * words in the provided text.</span></span><br><span class="line"><span class="comment"> * Example:</span></span><br><span class="line"><span class="comment"> *   WordDistanceFinder finder = new WordDistanceFinder(Arrays.asList("the", "quick", "brown", "fox", "quick"));</span></span><br><span class="line"><span class="comment"> *   assert(finder.distance("fox", "the") == 3);</span></span><br><span class="line"><span class="comment"> *   assert(finder.distance("quick", "fox") == 1);</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * "quick" appears twice in the input. There are two possible distance values for "quick" and "fox":</span></span><br><span class="line"><span class="comment"> * (3 - 1) = 2 and (4 - 3) = 1.</span></span><br><span class="line"><span class="comment"> * Since we have to return the shortest distance between the two words we return 1.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WordDistanceFinder</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">WordDistanceFinder</span> <span class="params">(List&lt;String&gt; words)</span> </span>&#123;</span><br><span class="line">      Map&lt;String, List&lt;Integer&gt;&gt; map = <span class="keyword">new</span> HashMap&lt;String, List&lt;Integer&gt;&gt;();</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; words.size(); i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(!map.contains(word))</span><br><span class="line">          map.put(word, <span class="keyword">new</span> ArrayList&lt;Integer&gt;());</span><br><span class="line">        map.get(word).add(i);         </span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">distance</span> <span class="params">(String wordOne, String wordTwo)</span> </span>&#123;</span><br><span class="line">      List&lt;Integer&gt; index1 = map.get(wordOne);</span><br><span class="line">      List&lt;integer&gt; index2 = map.get(wordTwo);</span><br><span class="line">      <span class="keyword">int</span> i = <span class="number">0</span>; j = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">int</span> min_distance = map.size();</span><br><span class="line">      <span class="keyword">while</span>(i &lt; index1.size() &amp;&amp; j &lt; index2.size()) &#123;</span><br><span class="line">        ind1 = index1[i];</span><br><span class="line">        ind2 = index[j];</span><br><span class="line">        current_distance = math.abs(ind1 - ind2);</span><br><span class="line">        min_distance = current_distance&gt;min_distance?min_distance:current_distance;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(ind1 &lt; ind2) &#123;</span><br><span class="line">          i++;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          j++;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> min_distance;</span><br><span class="line">        <span class="comment">// implementation here</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> ML </category>
          
          <category> retrieval </category>
          
          <category> 倒排索引 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>【深度学习】基础篇</title>
      <link href="/pub/8e5190ac/"/>
      <url>/pub/8e5190ac/</url>
      <content type="html"><![CDATA[<h1 id="基础概念"><a href="#基础概念" class="headerlink" title="基础概念"></a>基础概念</h1><ul><li>NN</li><li>前馈网络: <code>前馈</code>是相对<code>反馈</code>(backward)，带反馈的网络就构成了环，即有环网络。通常所用到的网络都是前馈网络。<!--feedforward neural network: the connectivity graph does not have any directed loops or cycles.Q: LSTM的forget算有环吗？A: 不算，按时间拆分开就显而易见了。Q: 双向LSTM算有环吗？A: 不算--></li><li>感知机</li><li>多层感知机</li><li>autoencoder</li><li>RBM</li></ul><h2 id="答疑"><a href="#答疑" class="headerlink" title="答疑"></a>答疑</h2><h2 id="梯度爆炸-梯度消失"><a href="#梯度爆炸-梯度消失" class="headerlink" title="梯度爆炸 梯度消失"></a>梯度爆炸 梯度消失</h2><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">Q:</span> <span class="string">梯度消失就是0.9^30≈0.04？梯度爆炸就是1.1的n次方？</span></span><br><span class="line">   <span class="string">怎样不消失，不爆炸呢？就是1的n次方吗？</span></span><br><span class="line"><span class="attr">A:</span> <span class="string">是的，ReLU就是这么干的</span></span><br><span class="line"></span><br><span class="line"><span class="attr">Q:</span> <span class="string">那sigmoid和tanh，是不是就彻底被淘汰了？</span></span><br><span class="line"><span class="attr">A:</span> <span class="string">网络不深可以用，具体情况具体分析</span></span><br><span class="line">   <span class="string">再说了batch</span> <span class="string">normalization的作用对于mitigate这种情况效果不错</span></span><br><span class="line"></span><br><span class="line"><span class="attr">Q:</span> <span class="string">除了ReLU，还有什么能防止梯度爆炸、梯度消失的策略？</span></span><br><span class="line"><span class="attr">A:</span> <span class="string">还有一些特殊的网络结果诸如resnet</span> <span class="string">LSTM，也可以防止梯度小时或者爆炸，但不能根本解决</span></span><br><span class="line"></span><br><span class="line"><span class="attr">Q:</span> <span class="string">为什么BN能起到一定的作用？</span></span><br><span class="line"><span class="attr">A:</span> <span class="string">避免了梯度非常小，或者非常大。将梯度归一化到一个固定范围，相当于他说的消除了柔性</span></span><br><span class="line">   <span class="string">通过mini-batch来对相应的activation做规范化操作，使得结果（输出信号各个维度）的均值为0，方差为1</span></span><br><span class="line"></span><br><span class="line"><span class="attr">Q:</span> <span class="string">为什么resnet</span> <span class="string">LSTM，能防止梯度爆炸</span> <span class="string">梯度消失？</span></span><br><span class="line"><span class="attr">A:</span> <span class="string">因为避免了连乘。</span></span><br><span class="line"></span><br><span class="line"><span class="attr">Q:</span> <span class="string">可以理解bn是集中到标准正态分布范围内，但是网络里用的ReLU抑制负数所以有损失吗？</span></span><br><span class="line"><span class="attr">A:</span></span><br><span class="line"></span><br><span class="line"><span class="attr">Q:</span> <span class="string">RNN</span> <span class="string">为什么会出现</span> <span class="string">Gradient</span> <span class="string">Vanish？LSTM为什么能防止梯度消失？</span></span><br></pre></td></tr></table></figure><h2 id="激活函数-activation-function"><a href="#激活函数-activation-function" class="headerlink" title="激活函数 (activation function)"></a>激活函数 (activation function)</h2><p>VGG ResNet都采用ReLU</p><h1 id=""><a href="#" class="headerlink" title="#"></a>#</h1>]]></content>
      
      <categories>
          
          <category> ML </category>
          
          <category> deep learning </category>
          
          <category> model </category>
          
      </categories>
      
      
        <tags>
            
            <tag> nn </tag>
            
            <tag> gradient vanish </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>github issue</title>
      <link href="/pub/3f25fe26/"/>
      <url>/pub/3f25fe26/</url>
      <content type="html"><![CDATA[<p>每一次commit都可以选择性的与某个issue关联。比如在 <code>message</code>中添加<code>#n</code>，就可以与第n个 issue 进行关联。<br><code>commit message title, #1</code></p><p>官方doc：</p><ul><li><a href="https://guides.github.com/features/issues/" target="_blank" rel="noopener">https://guides.github.com/features/issues/</a></li><li><a href="https://help.github.com/articles/closing-issues-using-keywords/" target="_blank" rel="noopener">https://help.github.com/articles/closing-issues-using-keywords/</a></li></ul><p>By prefacing your commits with:</p><ul><li><code>fix</code></li><li><code>fixes</code>: 例如提交messeage为<code>Fixes #45</code>，当commit被merge到master上时，会自动关闭<code>issue 45</code></li><li><code>fixed</code></li><li><code>close</code></li><li><code>closes</code></li><li><code>closed</code></li><li><code>resolve</code></li><li><code>resolves</code></li><li><code>resolved</code></li></ul><p>when the commit is merged into master, it will also automatically close the issue.</p><h2 id="同时操作多个issue"><a href="#同时操作多个issue" class="headerlink" title="同时操作多个issue"></a>同时操作多个issue</h2><p><code>This closes #34, closes #23, and closes example_user/example_repo#42</code></p><h2 id="常用标签"><a href="#常用标签" class="headerlink" title="常用标签"></a>常用标签</h2><p>Labels，标签。包括 enhancement、bug、invalid 等，表示 issue 的类型，解决的方式。除了自带的以外，也可以去自定义。</p><p>Milestone，里程碑。几经修改后，它现在已经与git tag和Github release区分开来，仅仅作为issue的一个集合。通常用来表示项目的一个阶段，比如demo、release等，保护达成这些阶段需要解决的问题。有时候，也会与版本计划重合，比如v1.0、v2.0等。issue不能设置截止时间，但是milestone可以。</p><p>Assignee，责任人。指定这个 issue 由谁负责来解决。</p>]]></content>
      
      <categories>
          
          <category> CS </category>
          
          <category> tools </category>
          
          <category> 同步与版本管理 </category>
          
          <category> git </category>
          
          <category> github </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>rsync 原理</title>
      <link href="/pub/af0b984c/"/>
      <url>/pub/af0b984c/</url>
      <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>rsync是Unix下的一款应用软件，它能同步更新两处计算机的文件与目录，并适当<strong>利用差分编码以减少数据传输量</strong>。rsync中的一项同类软件不常见的重要特性是每个目标的镜像只需发送一次。rsync可以拷贝／显示目录内容，以及拷贝文件，并<strong>可选压缩</strong>以及递归拷贝。</p><p>在常驻模式（daemon mode）下，rsync默认监听TCP端口873，以原生rsync传输协议或者通过远程shell如RSH或者SSH提供文件。SSH模式下，rsync客户端运行程序必须同时在本地和远程机器上安装。</p><p>rsync使用所谓的“rsync算法”来使本地和远程两个主机之间的文件达到同步，这个算法<strong>只传送两个文件的不同部分</strong>，而不是每次都整份传送，因此速度相当快。</p><h1 id="需要解决的问题"><a href="#需要解决的问题" class="headerlink" title="需要解决的问题"></a>需要解决的问题</h1><ol><li>如何判断文件是否变更？</li><li>如何找到变更的部分？</li><li>对于二进制文件怎样处理？</li><li>对于大文件怎样处理？</li></ol><h1 id="rsync算法"><a href="#rsync算法" class="headerlink" title="rsync算法"></a>rsync算法</h1><ol><li>按固定大小将A分为多块，每块都计算出一个32位的滚动哈希值和一个128位的MD4（有些也用MD5），发给B一端。</li><li>B一端从位置0开始按的同样块大小的滚动哈希值，查找看是否命中A给的某个滚动哈希值，若匹配，则表明B文件中的这块内容与对应的A中的那块内容很可能是一致的，但由于32位的哈希值强度不够，因此再计算MD4，若还是匹配，则确认是一致内容，这时B发给A端匹配的段号。对于那些不能匹配的内容，则发给A端原始内容。</li><li>A端得到B端给的匹配信息，构造一个与B一致的复本，若是匹配的块，则拷贝原A文件中对应的块，若是不匹配内容则追加之。</li></ol><h2 id="分块Checksum算法"><a href="#分块Checksum算法" class="headerlink" title="分块Checksum算法"></a>分块Checksum算法</h2><p>首先，我们会把fileDst的文件平均切分成若干个小块，比如每块512个字节（最后一块会小于这个数），然后对每块计算两个checksum，</p><ul><li>一个叫rolling checksum，是弱checksum，32位的checksum，其使用的是Mark Adler发明的adler-32算法，</li><li>另一个是强checksum，128位的，以前用md4，现在用md5 hash算法。</li></ul><p>为什么要这样？因为若干年前的硬件上跑md4的算法太慢了，所以，我们需要一个快算法来鉴别文件块的不同，但是弱的adler32算法碰撞概率太高了，所以我们还要引入强的checksum算法以保证两文件块是相同的。也就是说，弱的checksum是用来区别不同，而强的是用来确认相同。（checksum的具体公式可以参看这篇文章）</p><h2 id="传输算法"><a href="#传输算法" class="headerlink" title="传输算法"></a>传输算法</h2><p>同步目标端会把fileDst的一个checksum列表传给同步源，这个列表里包括了三个东西，rolling checksum(32bits)，md5 checksume(128bits)，文件块编号。</p><p>我估计你猜到了同步源机器拿到了这个列表后，会对fileSrc做同样的checksum，然后和fileDst的checksum做对比，这样就知道哪些文件块改变了。</p><p>但是，聪明的你一定会有以下两个疑问：</p><p>如果我fileSrc这边在文件中间加了一个字符，这样后面的文件块都会位移一个字符，这样就完全和fileDst这边的不一样了，但理论上来说，我应该只需要传一个字符就好了。这个怎么解决？<br>如果这个checksum列表特别长，而我的两边的相同的文件块可能并不是一样的顺序，那就需要查找，线性的查找起来应该特别慢吧。这个怎么解决？<br>很好，让我们来看一下同步源端的算法。</p><h2 id="checksum查找算法"><a href="#checksum查找算法" class="headerlink" title="checksum查找算法"></a>checksum查找算法</h2><h2 id="比对算法"><a href="#比对算法" class="headerlink" title="比对算法"></a>比对算法</h2><h1 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h1><h1 id="基于rsync的应用"><a href="#基于rsync的应用" class="headerlink" title="基于rsync的应用"></a>基于rsync的应用</h1><ul><li>Rclone</li><li>Back In Time</li></ul><p>…</p><p>都没听过</p><h1 id="基于rsync的改进算法"><a href="#基于rsync的改进算法" class="headerlink" title="基于rsync的改进算法"></a>基于rsync的改进算法</h1><p>基于rsync的改进算法主要有多轮rsync和本地rsync两个。</p><h1 id="疑问"><a href="#疑问" class="headerlink" title="疑问"></a>疑问</h1><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li><a href="https://zh.wikipedia.org/wiki/Rsync" target="_blank" rel="noopener">维基百科</a></li><li><a href="https://coolshell.cn/articles/7425.html" target="_blank" rel="noopener">RSYNC 的核心算法 | 酷壳</a></li><li><a href="http://wangyuanzju.blog.163.com/blog/static/130292010101252632998/" target="_blank" rel="noopener">Dropbox差异同步算法rsync及其改进算法原理  </a></li></ul>]]></content>
      
      <categories>
          
          <category> CS </category>
          
          <category> tools </category>
          
          <category> 同步与版本管理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> checksum </tag>
            
            <tag> 同步 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>【Hexo插件系列】日志排序插件 hexo-generator-index，实现文章置顶</title>
      <link href="/pub/70564e/"/>
      <url>/pub/70564e/</url>
      <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>Hexo默认提供了按发布日期的排序，即hexo-generator-index</p><h1 id="源码解读"><a href="#源码解读" class="headerlink" title="源码解读"></a>源码解读</h1><p>核心逻辑：</p><p><a href="https://github.com/hexojs/hexo-generator-index/blob/master/index.js" target="_blank" rel="noopener">index.js</a><br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> assign = <span class="built_in">require</span>(<span class="string">'object-assign'</span>);</span><br><span class="line"></span><br><span class="line">hexo.config.index_generator = assign(&#123;</span><br><span class="line">  per_page: <span class="keyword">typeof</span> hexo.config.per_page === <span class="string">'undefined'</span> ? <span class="number">10</span> : hexo.config.per_page,</span><br><span class="line">  order_by: <span class="string">'-date'</span>  <span class="comment">// 默认提供了按发布日期的排序</span></span><br><span class="line">&#125;, hexo.config.index_generator);</span><br><span class="line"></span><br><span class="line">hexo.extend.generator.register(<span class="string">'index'</span>, <span class="built_in">require</span>(<span class="string">'./lib/generator'</span>));</span><br></pre></td></tr></table></figure></p><p><a href="https://github.com/hexojs/hexo-generator-index/blob/master/lib/generator.js" target="_blank" rel="noopener">generator.js</a><br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> pagination = <span class="built_in">require</span>(<span class="string">'hexo-pagination'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="keyword">function</span>(<span class="params">locals</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> config = <span class="keyword">this</span>.config;</span><br><span class="line">  <span class="keyword">var</span> posts = locals.posts.sort(config.index_generator.order_by); <span class="comment">// 默认 sort by date</span></span><br><span class="line">  <span class="keyword">var</span> paginationDir = config.pagination_dir || <span class="string">'page'</span>;</span><br><span class="line">  <span class="keyword">var</span> path = config.index_generator.path || <span class="string">''</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> pagination(path, posts, &#123;</span><br><span class="line">    perPage: config.index_generator.per_page,</span><br><span class="line">    layout: [<span class="string">'index'</span>, <span class="string">'archive'</span>],</span><br><span class="line">    format: paginationDir + <span class="string">'/%d/'</span>,</span><br><span class="line">    data: &#123;</span><br><span class="line">      __index: <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><h1 id="Hexo文章置顶的方案"><a href="#Hexo文章置顶的方案" class="headerlink" title="Hexo文章置顶的方案"></a>Hexo文章置顶的方案</h1><h2 id="被pass的方案-加top属性"><a href="#被pass的方案-加top属性" class="headerlink" title="被pass的方案 - 加top属性"></a>被pass的方案 - 加top属性</h2><p><a href="https://github.com/hexojs/hexo-generator-index/search?q=top&amp;type=Issues" target="_blank" rel="noopener">相关 issue</a></p><p>这里提议在文件头加<code>top</code>属性，比如以下配置，就可以把当前的日志排到第一位。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">title: XXX</span><br><span class="line">date:</span><br><span class="line">top: 1</span><br><span class="line">---</span><br></pre></td></tr></table></figure></p><p>然而，这两个PR并未被merge。原因很简单，自带的<code>date</code>排序能够实现日志<code>置顶</code>或者<code>置底</code>操作。</p><h2 id="通过date置顶"><a href="#通过date置顶" class="headerlink" title="通过date置顶"></a>通过date置顶</h2><p>比如</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">date:</span> <span class="number">2020</span><span class="bullet">-01</span><span class="bullet">-01</span></span><br></pre></td></tr></table></figure><p>这样就很容易<code>置顶</code>了</p><p>Hexo文章置底也是同样的道理，比如设置日期为2000年，或者1000年来实现文章置底。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><blockquote><p>当然，有些需求是想实现置顶，又不想更改<code>date</code>。因此<code>某些主题</code>merge了这个feature，也有某些<code>插件</code>单独实现文章置顶功能。</p></blockquote>]]></content>
      
      <categories>
          
          <category> CS </category>
          
          <category> web </category>
          
          <category> blog-framework </category>
          
          <category> nodejs-hexo </category>
          
          <category> plugin </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
            <tag> plugin </tag>
            
            <tag> generator </tag>
            
            <tag> hexo-generator-index </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>【Hexo插件系列】日志的自动分类插件 hexo-auto-category</title>
      <link href="/pub/e2f6e239/"/>
      <url>/pub/e2f6e239/</url>
      <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><!--## pain point--><p>Hexo写日志，通常我们都需要维护一个front-matter信息，包括<code>title</code>、<code>date</code>。博客多了，为了方便日志分类，一般还需要设置<code>categories</code>。<br>比如下面的例子：<br><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">title:</span> <span class="string">Hexo简介</span></span><br><span class="line"><span class="attr">date:</span> <span class="number">2008</span><span class="bullet">-08</span><span class="bullet">-08</span></span><br><span class="line"><span class="attr">categories:</span></span><br><span class="line"><span class="bullet">  -</span> <span class="string">web开发</span></span><br><span class="line"><span class="bullet">  -</span> <span class="string">前端</span></span><br><span class="line"><span class="bullet">  -</span> <span class="string">博客框架</span></span><br><span class="line"><span class="meta">---</span></span><br></pre></td></tr></table></figure></p><p>久而久之，就会发现很多问题：</p><ul><li><strong>工作繁琐</strong>：大量的category是重复性工作</li><li><strong>容易出错</strong>：大小写和中英文目录有可能混杂。比如有个<code>web</code>目录，偶尔我们写成了<code>Web</code>，造成了目录树中冗余的节点。</li><li><strong>可维护性差</strong>：如果要更改<code>目录树</code>中的节点，就要手动更改每个日志的<code>categories</code>变量。</li></ul><p>本文介绍一种<strong>自动生成categories</strong>的插件 <a href="https://github.com/xu-song/hexo-auto-category" target="_blank" rel="noopener">hexo-auto-category官方地址</a>。</p><h1 id="自动生成-categories"><a href="#自动生成-categories" class="headerlink" title="自动生成 categories"></a>自动生成 <code>categories</code></h1><p>最常用的文件管理策略，就是利用文件系统目录结构(树形结构 directory-tree)。<br>同样，为了便于管理大量的日志文件，采用目录结构是一种简便可行的方案。<code>hexo-auto-category</code>根据日志文件(Markdown)所在文件目录自动分类，即自动生成<code>markdown</code>的front-matter中的<code>categories</code>变量。</p><p><strong>示例</strong></p><p>对于博客  <code>source/_post/web/framework/hexo.md</code>，该插件会自动生成以下<code>categories</code><br><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">categories:</span></span><br><span class="line"><span class="bullet">  -</span> <span class="string">web</span></span><br><span class="line"><span class="bullet">  -</span> <span class="string">framework</span></span><br></pre></td></tr></table></figure></p><h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install hexo-auto-category --save</span><br></pre></td></tr></table></figure><h1 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h1><p>在站点根目录下的<code>_config.yml</code>添加：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Generate categories from directory-tree</span></span><br><span class="line"><span class="comment"># Dependencies: https://github.com/xu-song/hexo-auto-category</span></span><br><span class="line"><span class="comment"># depth: the depth of directory-tree you want to generate, should &gt; 0</span></span><br><span class="line"><span class="attr">auto_category:</span></span><br><span class="line"><span class="attr"> enable:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr"> depth:</span></span><br></pre></td></tr></table></figure><h1 id="编译-amp-部署"><a href="#编译-amp-部署" class="headerlink" title="编译 &amp; 部署"></a>编译 &amp; 部署</h1><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo clean &amp;&amp; hexo g &amp;&amp; hexo d</span><br></pre></td></tr></table></figure><h1 id="高级配置"><a href="#高级配置" class="headerlink" title="高级配置"></a>高级配置</h1><p>如果只想生成第一级目录分类，可以设置<code>depth</code>属性，比如：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">auto_category:</span></span><br><span class="line"><span class="attr"> enable:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr"> depth:</span> <span class="number">1</span></span><br></pre></td></tr></table></figure><p>如有任何疑问，可在<a href="https://github.com/xu-song/hexo-auto-category/issues" target="_blank" rel="noopener">Github Issue</a>提出</p><!--# 可行性分析- 结构通用：`categories`变量是树形结构，文件系统的目录也是树形结构。关于树形结构竟然也有[争议](https://github.com/hexojs/hexo/issues/848)# 疑问这是theme-level的，还是site-level的？# 疑似相关插件hexo-generator-category  这个插件是生成tag文件的，不是用来自动生成category的。-->]]></content>
      
      <categories>
          
          <category> CS </category>
          
          <category> web </category>
          
          <category> blog-framework </category>
          
          <category> nodejs-hexo </category>
          
          <category> plugin </category>
          
          <category> site-level </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
            <tag> plugin </tag>
            
            <tag> hexo-auto-category </tag>
            
            <tag> category </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>关于Monkey Patch猴子补丁</title>
      <link href="/pub/7b5bc9fe/"/>
      <url>/pub/7b5bc9fe/</url>
      <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>以下是维基百科对猴子补丁的定义</p><blockquote><p>The term monkey patch refers to dynamic modifications of a class or module at runtime, motivated by the intent to patch existing third-party code as a workaround to a bug or feature which does not act as desired.</p></blockquote><!-- 在动态语言中， --><p>所谓的猴子补丁，是指在运行时修改类或模块，而不去改变源码，达到hot patch的目的。</p><p>猴补丁（英语：Monkey patch）是一种很脏的编程技巧，用拼凑代码的方法修改程序逻辑。</p><p>Monkey patching 只能在动态语言中实现。比如Python类的方法其实也只是一个属性，方便运行时修改，所以用Python做猴子补丁非常方便。</p><p>Changing a method at runtime instead of updating the object definition is one example。</p><h2 id="名字来源"><a href="#名字来源" class="headerlink" title="名字来源"></a>名字来源</h2><ol><li>这个词原来为Guerrilla Patch，杂牌军、游击队，说明这部分不是原装的，在英文里guerilla发音和gorllia(猩猩)相似，再后来就写了monkey(猴子)。</li><li>还有一种解释是说由于这种方式将原来的代码弄乱了(messing with it)，在英文里叫monkeying about(顽皮的)，所以叫做Monkey Patch。</li></ol><!-- Applications --><h1 id="示例-应用场景"><a href="#示例-应用场景" class="headerlink" title="示例/应用场景"></a>示例/应用场景</h1><p>维基百科总结了4种应用场景</p><ul><li>Replace methods / attributes / functions at runtime, e.g. to stub out a function during testing;</li><li>Modify/extend behaviour of a third-party product without maintaining a private copy of the source code;</li><li>Apply a patch at runtime to the objects in memory, instead of the source code on disk;</li><li>Distribute security or behavioural fixes that live alongside the original source code (an example of this would be distributing the fix as a plugin for the Ruby on Rails platform).</li></ul><h2 id="简单示例"><a href="#简单示例" class="headerlink" title="简单示例"></a>简单示例</h2><h3 id="对属性-打补丁"><a href="#对属性-打补丁" class="headerlink" title="对属性 打补丁"></a>对属性 打补丁</h3><p>以下来自wikpedia示例。<br>利用猴子补丁，动态修改math标准库中Pi的默认值。(这里仅修改了attributes，也可以对某些method进行重写)</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> math</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>math.pi</span><br><span class="line"><span class="number">3.141592653589793</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>math.pi = <span class="number">3</span>  <span class="comment"># 给标准库打补丁，即运行时修改math的pi属性</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>math.pi</span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>================================ RESTART ================================</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> math</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>math.pi</span><br><span class="line"><span class="number">3.141592653589793</span></span><br></pre></td></tr></table></figure><h3 id="对方法-打补丁"><a href="#对方法-打补丁" class="headerlink" title="对方法 打补丁"></a>对方法 打补丁</h3><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">bar</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">print</span> <span class="string">'Foo.bar'</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bar</span><span class="params">(self)</span>:</span>  <span class="comment"># 这是补丁</span></span><br><span class="line">    <span class="keyword">print</span> <span class="string">'Modified bar'</span></span><br><span class="line"></span><br><span class="line">Foo().bar()</span><br><span class="line">Foo.bar = bar  <span class="comment"># 给Foo的bar方法打补丁，即运行时修改类的方法</span></span><br><span class="line">Foo().bar()</span><br></pre></td></tr></table></figure><p>由于Python中的名字空间是开放，通过dict来实现，所以很容易就可以达到patch的目的。</p><h2 id="实际应用案例"><a href="#实际应用案例" class="headerlink" title="实际应用案例"></a>实际应用案例</h2><h3 id="socket的热补丁"><a href="#socket的热补丁" class="headerlink" title="socket的热补丁"></a>socket的热补丁</h3><p>用过gevent就会知道,会在最开头的地方gevent.monkey.patch_all();把标准库中的thread/socket等给替换掉.这样我们在后面使用socket的时候可以跟平常一样使用,无需修改任何代码,但是它变成非阻塞的了.</p><h3 id="SQL注入攻击"><a href="#SQL注入攻击" class="headerlink" title="SQL注入攻击"></a>SQL注入攻击</h3><p>网页和数据库</p><h3 id="Zope、Plone中的安全补丁"><a href="#Zope、Plone中的安全补丁" class="headerlink" title="Zope、Plone中的安全补丁"></a>Zope、Plone中的安全补丁</h3><blockquote><p>In Zope and Plone, security patches are often delivered using dynamic class modification, but they are called hot fixes.<br>— wikipedia</p></blockquote><p>很多安全补丁也是一种猴子补丁，只不过叫法不同而已。</p><h3 id="Eventlet-Patcher"><a href="#Eventlet-Patcher" class="headerlink" title="Eventlet Patcher"></a>Eventlet Patcher</h3><p>现在我们先来看一下eventlet中的Patcher的调用代码吧，这段代码对标准的ftplib做monkey patch，将eventlet的GreenSocket替换标准的socket。</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> eventlet <span class="keyword">import</span> patcher  </span><br><span class="line"><span class="comment"># *<span class="doctag">NOTE:</span> there might be some funny business with the "SOCKS" module  </span></span><br><span class="line"><span class="comment"># if it even still exists  </span></span><br><span class="line"><span class="keyword">from</span> eventlet.green <span class="keyword">import</span> socket  </span><br><span class="line">patcher.inject(<span class="string">'ftplib'</span>, globals(), (<span class="string">'socket'</span>, socket))  </span><br><span class="line"><span class="keyword">del</span> patcher</span><br></pre></td></tr></table></figure><p>Eventlet中大量使用了该技巧，以替换标准库中的组件，比如socket。</p><p>未完待续，参考 <a href="https://blog.csdn.net/seizef/article/details/5732657" target="_blank" rel="noopener">https://blog.csdn.net/seizef/article/details/5732657</a></p><h3 id="从Gevent学习猴子补丁的设计"><a href="#从Gevent学习猴子补丁的设计" class="headerlink" title="从Gevent学习猴子补丁的设计"></a>从Gevent学习猴子补丁的设计</h3><p>异步协程工具Gevent是python上面最有名也支持面最广通用性最好的协程工具,它底层基于greenlet,而且可以通过使用猴子补丁将标准库中的同步模块自动的转换成异步.同时他也提供了方便的并发模型和常用的web服务器工具.</p><p>gevent能够 修改标准库里面大部分的阻塞式系统调用，包括socket、ssl、threading和 select等模块，而变为协作式运行。</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> socket</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(socket.socket)     <span class="comment"># monkey patch前</span></span><br><span class="line">&lt;<span class="class"><span class="keyword">class</span> '<span class="title">socket</span>.<span class="title">_socketobject</span>'&gt;</span></span><br><span class="line"><span class="class">&gt;&gt;&gt;</span></span><br><span class="line"><span class="class">&gt;&gt;&gt; <span class="title">from</span> <span class="title">gevent</span> <span class="title">import</span> <span class="title">monkey</span> # <span class="title">monkey</span> <span class="title">patch</span>后</span></span><br><span class="line"><span class="class">&gt;&gt;&gt; <span class="title">monkey</span>.<span class="title">patch_socket</span><span class="params">()</span></span></span><br><span class="line"><span class="class">&gt;&gt;&gt; <span class="title">print</span><span class="params">(socket.socket)</span></span></span><br><span class="line"><span class="class">&lt;<span class="title">class</span> '<span class="title">gevent</span>.<span class="title">_socket2</span>.<span class="title">socket</span>'&gt;  # 改变了标准<span class="title">socket</span>库</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">&gt;&gt;&gt; <span class="title">import</span> <span class="title">select</span>        # <span class="title">monkey</span> <span class="title">patch</span>前</span></span><br><span class="line"><span class="class">&gt;&gt;&gt; <span class="title">print</span><span class="params">(select.select)</span>  #  <span class="title">select</span><span class="params">()</span>轮询的阻塞调用</span></span><br><span class="line"><span class="class">&lt;<span class="title">built</span>-<span class="title">in</span> <span class="title">function</span> <span class="title">select</span>&gt;</span></span><br><span class="line"><span class="class">&gt;&gt;&gt;</span></span><br><span class="line"><span class="class">&gt;&gt;&gt; <span class="title">monkey</span>.<span class="title">patch_select</span><span class="params">()</span> # <span class="title">monkey</span> <span class="title">patch</span>后</span></span><br><span class="line"><span class="class">&gt;&gt;&gt; <span class="title">print</span><span class="params">(select.select)</span> # <span class="title">select</span><span class="params">()</span>轮询的异步调用</span></span><br><span class="line"><span class="class">&lt;<span class="title">function</span> <span class="title">select</span> <span class="title">at</span> 0<span class="title">x7fb8a7239d70</span>&gt;</span></span><br></pre></td></tr></table></figure><p>例如，Redis的python绑定一般使用常规的tcp socket来与redis-server实例通信。 通过简单地调用gevent.monkey.patch_all()，可以使得redis的绑定协作式的调度 请求，与gevent栈的其它部分一起工作。</p><p>这让我们可以将一般不能与gevent共同工作的库结合起来，而不用写哪怕一行代码。 虽然猴子补丁仍然是邪恶的(evil)，但在这种情况下它是“有用的邪恶(useful evil)”。</p><h3 id="patch-all"><a href="#patch-all" class="headerlink" title="patch_all"></a>patch_all</h3><p>除了socket外,gevent还可以为其他的模块打补丁,一起打补丁可以使用<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">patch_all(socket=True, dns=True, time=True, select=True, thread=True, os=True, ssl=True, httplib=False,subprocess=True, sys=False, aggressive=True, Event=False, builtins=True, signal=True)</span><br></pre></td></tr></table></figure></p><p>函数。</p><p>我们可以看到像<code>socket</code>,<code>dns</code>,<code>time</code>,<code>selectthread</code>,<code>os</code>, <code>ssl</code>, <code>httplib</code>,<code>subprocess</code>, <code>sys</code>, <code>aggressive</code>, <code>Event</code>, <code>builtins</code>, <code>signal</code>模块都可以打上补丁,打上以后,他们就是非阻塞的了.</p><h3 id="核心协程模块greenlet"><a href="#核心协程模块greenlet" class="headerlink" title="核心协程模块greenlet"></a>核心协程模块greenlet</h3><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> gevent</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">foo</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">'Running in foo'</span>)</span><br><span class="line">    gevent.sleep(<span class="number">0</span>)  <span class="comment"># 这行的作用是什么？</span></span><br><span class="line">    print(<span class="string">'Explicit context switch to foo again'</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bar</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">'Explicit context to bar'</span>)</span><br><span class="line">    gevent.sleep(<span class="number">0</span>)  <span class="comment">#</span></span><br><span class="line">    print(<span class="string">'Implicit context switch back to bar'</span>)</span><br><span class="line"></span><br><span class="line">gevent.joinall([</span><br><span class="line">    gevent.spawn(foo),</span><br><span class="line">    gevent.spawn(bar),</span><br><span class="line">])</span><br></pre></td></tr></table></figure><p>输出<br><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Running <span class="keyword">in</span> foo</span><br><span class="line">Explicit context to bar</span><br><span class="line">Explicit context switch to foo again</span><br><span class="line">Implicit context switch back to bar</span><br><span class="line">[&lt;Greenlet at <span class="number">0x7fb8a72c3eb0</span>&gt;, &lt;Greenlet at <span class="number">0x7fb8a72c3a50</span>&gt;]</span><br></pre></td></tr></table></figure></p><p>上述例子能看到，执行顺序是  <code>foo--&gt;bar--foo--bar</code>，来回切换。即gevent.sleep()并不会真正的阻塞整个线程，而是将cpu的控制权显式的交给未被gevent.sleep()阻塞的协程使用。</p><p>协程是单线程程序（从上述例子来讲），如果我们使用time.sleep()，那么整个线程都会被阻塞。</p><h3 id="gevent-sleep与time-sleep的区别"><a href="#gevent-sleep与time-sleep的区别" class="headerlink" title="gevent.sleep与time.sleep的区别"></a><code>gevent.sleep</code>与<code>time.sleep</code>的区别</h3><ul><li><p>gevent is a cooperative analog to the threading module. When using gevent.sleep it you would never use time.sleep.  So no example is needed.</p></li><li><p>time.sleep would suspend the entire process, blocking all greenlet threads. <a href="https://mail.python.org/pipermail/python-list/2014-July/675726.html" target="_blank" rel="noopener">来源</a>。 以上说法针对的是协程(单线程程序)。而对于多线程，time.sleep仅仅阻塞当前线程，不阻塞其他线程，<a href="https://stackoverflow.com/questions/92928/time-sleep-sleeps-thread-or-process" target="_blank" rel="noopener">来源</a>。</p></li></ul><h3 id="猴子补丁-与-SocketIO"><a href="#猴子补丁-与-SocketIO" class="headerlink" title="猴子补丁 与 SocketIO"></a>猴子补丁 与 SocketIO</h3><p>用过gevent就会知道,会在最开头的地方gevent.monkey.patch_all();把标准库中的thread/socket等给替换掉.这样我们在后面使用socket的时候可以跟平常一样使用,无需修改任何代码,但是它变成非阻塞的了.</p><p>我看到猴子补丁，是从Gevent中看到的。SocketIO服务器发送数据，浏览器端并非实时接收，而是批量接收 (跟过马路有点像，凑够一波发送一次)。</p><p>这里涉及到buffer和flush。</p><ul><li><a href="https://github.com/miguelgrinberg/Flask-SocketIO/issues/106" target="_blank" rel="noopener">https://github.com/miguelgrinberg/Flask-SocketIO/issues/106</a></li><li><a href="https://github.com/miguelgrinberg/Flask-SocketIO/issues/141" target="_blank" rel="noopener">https://github.com/miguelgrinberg/Flask-SocketIO/issues/141</a></li></ul><p>没看懂的部分，后面再看。</p><blockquote><p> That is really the only way to make this work when you use gevent, threading is cooperative so you have to release the CPU so that other tasks associated with the server get a chance to run and flush the messages. Any chance you haven’t monkey patched the standard library?<br>—- Flask-SocketIO的作者miguelgrinberg link</p></blockquote><p>这里说的意思是，<code>socketio.emit(message)</code> 默认会加缓存(buffer)。需要主动flush才能立即发送。而<code>gevent.sleep(</code>是flush的一种方式，因为它会  将cpu的控制权显式的交给未被gevent.sleep()阻塞的协程使用，切换之前会先flush一下。</p><p>socketio.emit默认会有个buffer（为了高效），为什么gevent.sleep会flush这个buffer？让我们重新梳理一下思路：</p><ol><li><code>gevent.sleep</code>会<code>释放cpu控制权</code>，即<code>切换协程</code>，从而不阻塞其他协程运行。 <a href="https://github.com/gevent/gevent/search?utf8=%E2%9C%93&amp;q=switch&amp;type=" target="_blank" rel="noopener">gevent切换协程的源码</a></li><li>gevent进行<code>协程切换</code>前，需要<code>flush当前协程</code>。 <a href="https://github.com/gevent/gevent/search?utf8=%E2%9C%93&amp;q=flush&amp;type=" target="_blank" rel="noopener">gevent进行flush的源码</a></li><li><code>flush当前协程</code>导致socket.emit中的缓存立即发送</li></ol><h3 id="猴子补丁与-import-json"><a href="#猴子补丁与-import-json" class="headerlink" title="猴子补丁与 import json,"></a>猴子补丁与 import json,</h3><p>之前做的一个游戏服务器,很多地方用的import json,后来发现ujson比自带json快了N倍,于是问题来了,难道几十个文件要一个个把import json改成import ujson as json吗?<br>其实只需要在进程startup的地方monkey patch就行了.是影响整个进程空间的.<br>同一进程空间中一个module只会被运行一次.</p><h1 id="习题"><a href="#习题" class="headerlink" title="习题"></a>习题</h1><h2 id="猴子补丁是动态语言的专利么？"><a href="#猴子补丁是动态语言的专利么？" class="headerlink" title="猴子补丁是动态语言的专利么？"></a>猴子补丁是动态语言的专利么？</h2><p>使用猴子补丁的条件主要是可以打开类、可以重定义现有属性、方法。修改类方法的指针，或者属性</p><h3 id="C"><a href="#C" class="headerlink" title="C"></a>C</h3><h3 id="C-1"><a href="#C-1" class="headerlink" title="C++"></a>C++</h3><p>C++ 类有哪个方法是编译时确定好的, 没法打开类, 对象属于哪个类是 new 对象的代码确定好的, 既然 new 的代码在编译时确定了, 再载入补丁库也修改不了 (除非搞缓冲区溢出攻击…)</p><p>比如python中可以math.Pi=3。</p><h3 id="java"><a href="#java" class="headerlink" title="java"></a>java</h3><p>java强大的反射，即使<code>属性</code>或<code>方法</code>被设置为了<code>private final</code>也可以动态更改。讲道理也可以动态补丁。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>不是脚本语言的专利……是语言设计留不留口的问题？</p><h2 id="猴子补丁的坑"><a href="#猴子补丁的坑" class="headerlink" title="猴子补丁的坑"></a>猴子补丁的坑</h2><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li><a href="https://en.wikipedia.org/wiki/Monkey_patch" target="_blank" rel="noopener">Monkey patch | wikipedia</a></li><li><a href="https://stackoverflow.com/questions/5626193/what-is-monkey-patching" target="_blank" rel="noopener">what-is-monkey-patching | StackOverflow</a></li><li>待看 《松本行弘的程序世界》专门有一章讲了猴子补丁的设计</li><li><a href="https://ruby-china.org/topics/17619" target="_blank" rel="noopener">猴子补丁是动态语言的专利么？ | ruby-china</a></li><li><a href="http://blog.hszofficial.site/TutorialForPython/%E5%85%83%E7%BC%96%E7%A8%8B/%E7%8C%B4%E5%AD%90%E8%A1%A5%E4%B8%81%E5%92%8C%E7%83%AD%E6%9B%B4%E6%96%B0.html" target="_blank" rel="noopener">猴子补丁和热更新 | 网络博客</a></li></ul>]]></content>
      
      <categories>
          
          <category> CS </category>
          
          <category> programing </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>【Hexo插件系列】Hexo 插件推荐</title>
      <link href="/pub/92bb368/"/>
      <url>/pub/92bb368/</url>
      <content type="html"><![CDATA[<h1 id="综述"><a href="#综述" class="headerlink" title="综述"></a>综述</h1><p>官方收录插件：<a href="https://hexo.io/plugins/" target="_blank" rel="noopener">hexo.io/plugins/</a></p><p>我现在的博客，采用的是<code>hexo-abbrlink</code> + <code>hexo-auto-category</code>插件。  前者生成<code>路径无关</code>的hash作为URL，比较鲁棒。后者提供<code>依赖路径</code>的category，既自动生成category，又能方便在浏览器端<code>定位到日志的文件路径</code>。</p><h1 id="可视化插件"><a href="#可视化插件" class="headerlink" title="可视化插件"></a>可视化插件</h1><ul><li>fancy box大赞</li><li>chart相关，很多插件<!--echart(来自百度   ) - hexo-tag-echarts3  d3 ---></li></ul><!--- tag cloud：hexo-tag-cloud  hexo-d3cloudtag--><h1 id="博客管理插件"><a href="#博客管理插件" class="headerlink" title="博客管理插件"></a>博客管理插件</h1><h2 id="博客分类-category-自动管理"><a href="#博客分类-category-自动管理" class="headerlink" title="博客分类(category)自动管理"></a>博客分类(category)自动管理</h2><p><a href="https://github.com/xu-song/hexo-auto-category" target="_blank" rel="noopener">hexo-auto-category</a></p><p>根据日志(Markdown文件)所在目录层级自动分类。用户只需要把日志按照目录的方式组织，该插件就会在日志头部自动生成category标签。</p><p>既方便管理日志，又省去了人工维护<code>categories</code>标签的麻烦。</p><!--发现自己貌似重新造了个轮子 hexo-directory-category--><h2 id="markdown文件的引用"><a href="#markdown文件的引用" class="headerlink" title="markdown文件的引用"></a>markdown文件的引用</h2><p><a href="https://github.com/tea3/hexo-include-markdown" target="_blank" rel="noopener">hexo-include-markdown</a> 避免了多个博客写重复的内容。</p><figure class="highlight md"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">title: Hello World</span><br><span class="line">---</span><br><span class="line"></span><br><span class="line"><span class="section">## include sample</span></span><br><span class="line"></span><br><span class="line">Please load another markdown file with the following code.</span><br><span class="line"></span><br><span class="line"><span class="xml"><span class="comment">&lt;!-- md template.md --&gt;</span></span></span><br></pre></td></tr></table></figure><h1 id="SEO插件"><a href="#SEO插件" class="headerlink" title="SEO插件"></a>SEO插件</h1><h2 id="永久链接-permalink-插件-hexo-abbrlink"><a href="#永久链接-permalink-插件-hexo-abbrlink" class="headerlink" title="永久链接(permalink)插件 - hexo-abbrlink"></a>永久链接(permalink)插件 - hexo-abbrlink</h2><p>URL的设计尽量做到以下几点：</p><ul><li>不变性/鲁棒性：<code>date&gt;title&gt;path&gt;content</code>，即内容更新最频繁，标题和日期变动较少。<ul><li><del>path</del>，<del>content</del> 这俩被pass了</li></ul></li><li>唯一性：<code>content path title date</code> 唯一性都挺好</li><li>长度要短 &amp; 容量要大：<ul><li><del>content</del></li></ul></li></ul><p>Hexo默认采用 date+path作为URL，唯一性很好，但是鲁棒性就比较差（对于我）。像我就经常改变文件的路径，对文件重新归纳整理，这样会造成批量URL变动，严重影响SEO。</p><h2 id="重复网页-权威链接-hexo-auto-canonical"><a href="#重复网页-权威链接-hexo-auto-canonical" class="headerlink" title="重复网页 权威链接 - hexo-auto-canonical"></a>重复网页 权威链接 - hexo-auto-canonical</h2><p>据估计，网上有10%-30%的URL是内容相同但URL不一样的不规范化网址。</p><p>解决，做301重定向</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">hexo.extend.helper.register(<span class="string">'autoCanonical'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">config, page</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> base_url = config.url;</span><br><span class="line">  <span class="keyword">if</span> (config.url.charAt(config.url.length - <span class="number">1</span>) !== <span class="string">'/'</span>) base_url += <span class="string">'/'</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="string">'&lt;link rel="canonical" href="'</span> + base_url + page.canonical_path.replace(<span class="string">'index.html'</span>, <span class="string">''</span>).toLowerCase() + <span class="string">'"/&gt;'</span>;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>什么鬼？这么简单？</p><h2 id="hexo-autonofollow"><a href="#hexo-autonofollow" class="headerlink" title="hexo-autonofollow"></a>hexo-autonofollow</h2><p>Add rel=”external nofollow” to all external links, SEO friendly.<br>Add target=”_blank”, Open external links in new window or tab</p><h2 id="baidu-SEO-相关插件"><a href="#baidu-SEO-相关插件" class="headerlink" title="baidu SEO 相关插件"></a>baidu SEO 相关插件</h2><p>反正我一直没搞定百度。难道是因为网站没备案？</p><h1 id="推荐系统插件"><a href="#推荐系统插件" class="headerlink" title="推荐系统插件"></a>推荐系统插件</h1><ul><li><a href="https://github.com/tea3/hexo-related-popular-posts" target="_blank" rel="noopener">hexo-related-popular-posts</a><br>采用的相似tag作为推荐标准，需要自己合理设置日志的tag</li></ul><h1 id="内容扩展插件"><a href="#内容扩展插件" class="headerlink" title="内容扩展插件"></a>内容扩展插件</h1><h2 id="Instagram扩展"><a href="#Instagram扩展" class="headerlink" title="Instagram扩展"></a>Instagram扩展</h2><p>instagram提供内嵌脚本，只不过有点长，直接贴到markdown也还将就。</p><p><a href="https://github.com/tea3/hexo-tag-instagram" target="_blank" rel="noopener">hexo-tag-instagram</a></p><p>示例：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% instagram https:<span class="comment">//www.instagram.com/p/Bg71nq4HuAU/ %&#125;</span></span><br></pre></td></tr></table></figure></p><div class="instagram-wrapper"><blockquote class="instagram-media" data-instgrm-captioned="" data-instgrm-version="7" style=" background:#FFF; border:0; border-radius:3px; box-shadow:0 0 1px 0 rgba(0,0,0,0.5),0 1px 10px 0 rgba(0,0,0,0.15); margin: 1px auto; padding:0; width:99.375%; width:-webkit-calc(50%- 2px); width:calc(50% - 2px);"><div style="padding:8px;"> <div style=" background:#F8F8F8; line-height:0; margin-top:40px; padding:50.0% 0; text-align:center; width:100%;"> <div style=" background:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACwAAAAsCAMAAAApWqozAAAABGdBTUEAALGPC/xhBQAAAAFzUkdCAK7OHOkAAAAMUExURczMzPf399fX1+bm5mzY9AMAAADiSURBVDjLvZXbEsMgCES5/P8/t9FuRVCRmU73JWlzosgSIIZURCjo/ad+EQJJB4Hv8BFt+IDpQoCx1wjOSBFhh2XssxEIYn3ulI/6MNReE07UIWJEv8UEOWDS88LY97kqyTliJKKtuYBbruAyVh5wOHiXmpi5we58Ek028czwyuQdLKPG1Bkb4NnM+VeAnfHqn1k4+GPT6uGQcvu2h2OVuIf/gWUFyy8OWEpdyZSa3aVCqpVoVvzZZ2VTnn2wU8qzVjDDetO90GSy9mVLqtgYSy231MxrY6I2gGqjrTY0L8fxCxfCBbhWrsYYAAAAAElFTkSuQmCC); display:block; height:44px; margin:0 auto -44px; position:relative; top:-22px; width:44px;"></div></div><p style=" color:#c9c8cd; font-family:Arial,sans-serif; font-size:14px; line-height:17px; margin-bottom:0; margin-top:8px; overflow:hidden; padding:8px 0 7px; text-align:center; text-overflow:ellipsis; white-space:nowrap;"><a href="https://www.instagram.com/p/Bg71nq4HuAU/" style=" color:#c9c8cd; font-family:Arial,sans-serif; font-size:14px; font-style:normal; font-weight:normal; line-height:17px; text-decoration:none;" target="_blank"></a></p></div></blockquote></div><script async defer src="//platform.instagram.com/en_US/embeds.js"></script><h2 id="facebook扩展"><a href="#facebook扩展" class="headerlink" title="facebook扩展"></a>facebook扩展</h2><h2 id="hexo-tag-bilibili"><a href="#hexo-tag-bilibili" class="headerlink" title="hexo-tag-bilibili"></a>hexo-tag-bilibili</h2><h2 id="youtube"><a href="#youtube" class="headerlink" title="youtube"></a>youtube</h2><div class="video-container"><iframe src="//www.youtube.com/embed/video_id" frameborder="0" allowfullscreen></iframe></div><p><a href="https://hexo.io/zh-cn/docs/tag-plugins.html" target="_blank" rel="noopener">https://hexo.io/zh-cn/docs/tag-plugins.html</a></p><h2 id="twitter扩展"><a href="#twitter扩展" class="headerlink" title="twitter扩展"></a>twitter扩展</h2><p><a href="https://github.com/tea3/hexo-tag-twitter" target="_blank" rel="noopener">hexo-tag-twitter</a></p><p>示例：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% twitter https:<span class="comment">//twitter.com/realDonaldTrump/status/976891486510907393 %&#125;</span></span><br></pre></td></tr></table></figure></p><div class="twitter-wrapper"><blockquote class="twitter-tweet"><a href="https://twitter.com/realDonaldTrump/status/976891486510907393" target="_blank" rel="noopener"></a></blockquote></div><script async defer src="//platform.twitter.com/widgets.js" charset="utf-8"></script><h2 id="微博扩展"><a href="#微博扩展" class="headerlink" title="微博扩展"></a>微博扩展</h2><h2 id="flickr扩展"><a href="#flickr扩展" class="headerlink" title="flickr扩展"></a>flickr扩展</h2><p>貌似直接<code>&lt;img&gt;</code>标签就能搞定</p><h2 id="soundcloud扩展"><a href="#soundcloud扩展" class="headerlink" title="soundcloud扩展"></a>soundcloud扩展</h2><p>hexo-tag-soundcloud</p><div class="soundcloud-wrapper"><iframe width="100%" height="450" scrolling="no" frameborder="no" src="https://w.soundcloud.com/player/?url=https%3A%2F%2Fsoundcloud.com%2Frich-the-kid%2Fplug-walk-1&amp;auto_play=false&amp;hide_related=true&amp;show_comments=true&amp;show_user=true&amp;show_reposts=false&amp;visual=true"></iframe></div><h2 id="代码扩展"><a href="#代码扩展" class="headerlink" title="代码扩展"></a>代码扩展</h2><p>gist提供内嵌脚本</p><h1 id="加速-amp-优化"><a href="#加速-amp-优化" class="headerlink" title="加速 &amp; 优化"></a>加速 &amp; 优化</h1><ul><li>cdn：hexo-cdnify</li><li>minify: hexo-all-minifier</li><li>hexo-asset-pipeline</li></ul><h1 id="前端加密类："><a href="#前端加密类：" class="headerlink" title="前端加密类："></a>前端加密类：</h1><p>hexo-encrypt.  </p><p>hexo-blog-encrypt  <a href="http://edolphin.site/2016/05/31/encrypt-post/" target="_blank" rel="noopener">原理见博客</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var content = CryptoJS.AES.decrypt(document.getElementById(&quot;encrypt-blog&quot;).innerHTML.trim(), pass);</span><br></pre></td></tr></table></figure><!--#无聊鸡肋类插件无关类(功能独立，无须作为hexo插件)：hexo-beautify# Hexo博客推荐- https://photo-tea.com  很赞，虽然看不懂写的是什么。[Github](https://github.com/tea3/)- https://blog.zthxxx.me/-->]]></content>
      
      <categories>
          
          <category> CS </category>
          
          <category> web </category>
          
          <category> blog-framework </category>
          
          <category> nodejs-hexo </category>
          
          <category> plugin </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
            <tag> plugin </tag>
            
            <tag> hexo-auto-category </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>【Angular系列】 Angular 2 入门</title>
      <link href="/pub/5a499450/"/>
      <url>/pub/5a499450/</url>
      <content type="html"><![CDATA[<p><a href="http://www.runoob.com/angularjs2/angularjs2-javascript-setup.html" target="_blank" rel="noopener">runoob教程链接</a></p><p>首先是不掺杂typescript，更能熟悉angular其工作原理。</p><h1 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h1><ol><li>下载源码</li><li>npm install</li><li>双击html即可。无须借助node server，更容易理解前端框架</li></ol><h2 id="执行顺序"><a href="#执行顺序" class="headerlink" title="执行顺序"></a>执行顺序</h2><ol><li>npm start启动lite-server，默认加载index.html。或直接双击index.html</li><li>浏览器加载index.html</li><li>浏览器依次加载并执行 app.component.js、app.module.js、main.js<ol><li>执行app.component.js，将app.component匿名函数加入到window.app中。并未调用constructor</li><li>执行app.module.js，将app.module匿名函数加入到window.app中</li><li>执行main.js，</li></ol></li><li>main.js调用app.AppModule，即调用app.module匿名函数。其中会调用constructor</li><li>app.module调用app.AppComponent，即调用app.component匿名函数，返回template</li></ol><h1 id="细节"><a href="#细节" class="headerlink" title="细节"></a>细节</h1><h2 id="index-html"><a href="#index-html" class="headerlink" title="index.html"></a>index.html</h2><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"utf-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Angular 2 实例 - 菜鸟教程(runoob.com)<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width, initial-scale=1"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span> <span class="attr">href</span>=<span class="string">"styles.css"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 1. 载入库 --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- IE 需要 polyfill --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"node_modules/core-js/client/shim.min.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"node_modules/zone.js/dist/zone.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"node_modules/reflect-metadata/Reflect.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"node_modules/rxjs/bundles/Rx.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"node_modules/@angular/core/bundles/core.umd.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"node_modules/@angular/common/bundles/common.umd.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"node_modules/@angular/compiler/bundles/compiler.umd.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"node_modules/@angular/platform-browser/bundles/platform-browser.umd.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"node_modules/@angular/platform-browser-dynamic/bundles/platform-browser-dynamic.umd.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 2. 载入 'modules'</span></span><br><span class="line"><span class="comment">   顺序不能乱，因为main.js依赖app.module.js，app.module.js依赖app.component.js --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">'app/app.component.js'</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">'app/app.module.js'</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">'app/main.js'</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">&lt;!-- 3. 显示应用 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">my-app</span>&gt;</span>Loading...<span class="tag">&lt;/<span class="name">my-app</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="main-js"><a href="#main-js" class="headerlink" title="main.js"></a>main.js</h2><p>定义了一个匿名函数，参数为<code>app</code></p><p>第二个括号用于调用该匿名函数，并传入参数。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params">app</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">document</span>.addEventListener(<span class="string">'DOMContentLoaded'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    ng.platformBrowserDynamic</span><br><span class="line">      .platformBrowserDynamic()</span><br><span class="line">      .bootstrapModule(app.AppModule);  <span class="comment">// 依赖AppModule类</span></span><br><span class="line">  &#125;);</span><br><span class="line">&#125;)(<span class="built_in">window</span>.app || (<span class="built_in">window</span>.app = &#123;&#125;));</span><br></pre></td></tr></table></figure><h2 id="app-module-js"><a href="#app-module-js" class="headerlink" title="app.module.js"></a>app.module.js</h2><p>定义了一个匿名函数，参数为<code>app</code>。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params">app</span>) </span>&#123;</span><br><span class="line">  app.AppModule =  <span class="comment">// // 创建一个Angular Module对象，并赋值给对app</span></span><br><span class="line">    ng.core.NgModule(&#123;</span><br><span class="line">      imports: [ ng.platformBrowser.BrowserModule ],</span><br><span class="line">      declarations: [ app.AppComponent ],</span><br><span class="line">      bootstrap: [ app.AppComponent ]</span><br><span class="line">    &#125;)</span><br><span class="line">    .Class(&#123;</span><br><span class="line">      <span class="keyword">constructor</span>: function() &#123;&#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;)(<span class="built_in">window</span>.app || (<span class="built_in">window</span>.app = &#123;&#125;));</span><br></pre></td></tr></table></figure></p><h2 id="app-component-js"><a href="#app-component-js" class="headerlink" title="app.component.js"></a>app.component.js</h2><p>定义了一个匿名函数，参数为<code>app</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params">app</span>) </span>&#123;</span><br><span class="line">  app.AppComponent =  <span class="comment">// 创建一个Angular Component对象</span></span><br><span class="line">    ng.core.Component(&#123;</span><br><span class="line">      selector: <span class="string">'my-app'</span>,</span><br><span class="line">      template: <span class="string">'&lt;h1&gt;我的第一个 Angular 应用&lt;/h1&gt;'</span></span><br><span class="line">    &#125;)</span><br><span class="line">    .Class(&#123;</span><br><span class="line">      <span class="keyword">constructor</span>: function() &#123;&#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;)(<span class="built_in">window</span>.app || (<span class="built_in">window</span>.app = &#123;&#125;));</span><br></pre></td></tr></table></figure><h2 id="package-json"><a href="#package-json" class="headerlink" title="package.json"></a>package.json</h2><p>用于npm install的依赖和npm start的脚本。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"name"</span>: <span class="string">"angular2-quickstart"</span>,</span><br><span class="line">  <span class="attr">"version"</span>: <span class="string">"1.0.0"</span>,</span><br><span class="line">  <span class="attr">"scripts"</span>: &#123;</span><br><span class="line">    <span class="attr">"start"</span>: <span class="string">"npm run lite"</span>,</span><br><span class="line">    <span class="attr">"lite"</span>: <span class="string">"lite-server"</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">"license"</span>: <span class="string">"ISC"</span>,</span><br><span class="line">  <span class="attr">"dependencies"</span>: &#123;</span><br><span class="line">    <span class="attr">"@angular/common"</span>: <span class="string">"2.0.0"</span>,</span><br><span class="line">    <span class="attr">"@angular/compiler"</span>: <span class="string">"2.0.0"</span>,</span><br><span class="line">    <span class="attr">"@angular/core"</span>: <span class="string">"2.0.0"</span>,</span><br><span class="line">    <span class="attr">"@angular/forms"</span>: <span class="string">"2.0.0"</span>,</span><br><span class="line">    <span class="attr">"@angular/http"</span>: <span class="string">"2.0.0"</span>,</span><br><span class="line">    <span class="attr">"@angular/platform-browser"</span>: <span class="string">"2.0.0"</span>,</span><br><span class="line">    <span class="attr">"@angular/platform-browser-dynamic"</span>: <span class="string">"2.0.0"</span>,</span><br><span class="line">    <span class="attr">"@angular/router"</span>: <span class="string">"3.0.0"</span>,</span><br><span class="line">    <span class="attr">"@angular/upgrade"</span>: <span class="string">"2.0.0"</span>,</span><br><span class="line"></span><br><span class="line">    <span class="attr">"core-js"</span>: <span class="string">"^2.4.1"</span>,</span><br><span class="line">    <span class="attr">"reflect-metadata"</span>: <span class="string">"^0.1.3"</span>,</span><br><span class="line">    <span class="attr">"rxjs"</span>: <span class="string">"5.0.0-beta.12"</span>,</span><br><span class="line">    <span class="attr">"zone.js"</span>: <span class="string">"^0.6.23"</span>,</span><br><span class="line"></span><br><span class="line">    <span class="attr">"angular2-in-memory-web-api"</span>: <span class="string">"0.0.20"</span>,</span><br><span class="line">    <span class="attr">"bootstrap"</span>: <span class="string">"^3.3.6"</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">"devDependencies"</span>: &#123;</span><br><span class="line">    <span class="attr">"concurrently"</span>: <span class="string">"^2.0.0"</span>,</span><br><span class="line">    <span class="attr">"lite-server"</span>: <span class="string">"^2.2.0"</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> CS </category>
          
          <category> web </category>
          
          <category> front-end </category>
          
          <category> framework </category>
          
          <category> Angular </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>【Hexo插件系列】permalink 永久链接 - hexo链接持久化解决方案</title>
      <link href="/pub/2cc9ead/"/>
      <url>/pub/2cc9ead/</url>
      <content type="html"><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>hexo默认的链接是<code>http://example.com/2013/07/14/path/hello-world/</code> 这种类型的，这源于站点目录下的配置<code>_config.yml</code>里的配置: <code>permalink: :year/:month/:day/:title/</code>.</p><p>这种默认配置的缺点</p><ul><li>文件名是中文，导致url链接里有中文出现</li><li>年月日都会有分隔符，目录层次较深</li><li>后台路径<code>path</code>变化，会导致链接批量变化。非常影响SEO</li></ul><h1 id="Hexo-默认配置"><a href="#Hexo-默认配置" class="headerlink" title="Hexo 默认配置"></a>Hexo 默认配置</h1><p><a href="https://hexo.io/zh-cn/docs/permalinks.html" target="_blank" rel="noopener">https://hexo.io/zh-cn/docs/permalinks.html</a></p><p><code>_config.yml</code></p><p><code>permalink: :year/:month/:day/:title/</code></p><h2 id="Hexo实现permalink的源码"><a href="#Hexo实现permalink的源码" class="headerlink" title="Hexo实现permalink的源码"></a>Hexo实现permalink的源码</h2><p><a href="https://github.com/hexojs/hexo/search?utf8=%E2%9C%93&amp;q=permalink&amp;type=" target="_blank" rel="noopener">https://github.com/hexojs/hexo/search?utf8=%E2%9C%93&amp;q=permalink&amp;type=</a></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// https://github.com/hexojs/hexo/blob/master/lib/plugins/filter/post_permalink.js</span></span><br><span class="line"><span class="keyword">const</span> _ = <span class="built_in">require</span>(<span class="string">'lodash'</span>);</span><br><span class="line"><span class="keyword">const</span> util = <span class="built_in">require</span>(<span class="string">'hexo-util'</span>);</span><br><span class="line"><span class="keyword">const</span> pathFn = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"><span class="keyword">const</span> Permalink = util.Permalink;</span><br><span class="line"><span class="keyword">let</span> permalink;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">postPermalinkFilter</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">  1. data变量</span></span><br><span class="line"><span class="comment">  data.slug是path+文件名</span></span><br><span class="line"><span class="comment">  data.title是post中的title</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">  2. meta变量</span></span><br><span class="line"><span class="comment">  post_title</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> config = <span class="keyword">this</span>.config;</span><br><span class="line">  <span class="keyword">const</span> meta = &#123;</span><br><span class="line">    id: data.id || data._id,</span><br><span class="line">    title: data.slug,</span><br><span class="line">    name: <span class="keyword">typeof</span> data.slug === <span class="string">'string'</span> ? pathFn.basename(data.slug) : <span class="string">''</span>, <span class="comment">// 这里把path当做了basename</span></span><br><span class="line">    post_title: util.slugize(data.title, &#123;<span class="attr">transform</span>: <span class="number">1</span>&#125;),</span><br><span class="line">    year: data.date.format(<span class="string">'YYYY'</span>),</span><br><span class="line">    month: data.date.format(<span class="string">'MM'</span>),</span><br><span class="line">    day: data.date.format(<span class="string">'DD'</span>),</span><br><span class="line">    i_month: data.date.format(<span class="string">'M'</span>),</span><br><span class="line">    i_day: data.date.format(<span class="string">'D'</span>)</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!permalink || permalink.rule !== config.permalink) &#123;</span><br><span class="line">    permalink = <span class="keyword">new</span> Permalink(config.permalink);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">  默认配置：permalink: :year/:month/:day/:title/</span></span><br><span class="line"><span class="comment">  对应这里的permalink变量，具体如下：</span></span><br><span class="line"><span class="comment">  permalink Permalink &#123;</span></span><br><span class="line"><span class="comment">    rule: ':year/:month/:day/:title/',</span></span><br><span class="line"><span class="comment">    regex: /^(.+?)\/(.+?)\/(.+?)\/(.+?)\/$/,</span></span><br><span class="line"><span class="comment">    params: [ 'year', 'month', 'day', 'title' ] &#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">  即把meta中的这几个变量作为param，通过rule和regex转为永久链接。</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  <span class="keyword">const</span> categories = data.categories;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (categories.length) &#123;</span><br><span class="line">    meta.category = categories.last().slug;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    meta.category = config.default_category;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> keys = <span class="built_in">Object</span>.keys(data);</span><br><span class="line">  <span class="keyword">let</span> key = <span class="string">''</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, len = keys.length; i &lt; len; i++) &#123;</span><br><span class="line">    key = keys[i];</span><br><span class="line">    <span class="keyword">if</span> (meta.hasOwnProperty(key)) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Use Object.getOwnPropertyDescriptor to copy getters to avoid "Maximum call</span></span><br><span class="line">    <span class="comment">// stack size exceeded" error</span></span><br><span class="line">    <span class="built_in">Object</span>.defineProperty(meta, key, <span class="built_in">Object</span>.getOwnPropertyDescriptor(data, key));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> permalink.stringify(_.defaults(meta, config.permalink_defaults)); <span class="comment">// 核心代码，把meta的变量，传入到</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = postPermalinkFilter; <span class="comment">// 重点是这个exports</span></span><br></pre></td></tr></table></figure><h1 id="hexo-abbrlink插件-源码"><a href="#hexo-abbrlink插件-源码" class="headerlink" title="hexo-abbrlink插件 源码"></a>hexo-abbrlink插件 源码</h1><p>原理：</p><ul><li>注册before_post_render钩子，</li><li>取出来abbrlink这个属性看是否存在，存在的就不管了，</li><li>否则就生成连接</li><li>新链接写入post源文件。</li></ul><p>入口：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> hexo = hexo || &#123;&#125;;</span><br><span class="line"><span class="comment">// 注册before_post_render钩子</span></span><br><span class="line">hexo.extend.filter.register(<span class="string">'before_post_render'</span>, <span class="built_in">require</span>(<span class="string">'./lib/logic'</span>), <span class="number">15</span>);</span><br></pre></td></tr></table></figure><p><a href="https://github.com/rozbo/hexo-abbrlink/blob/master/lib/logic.js" target="_blank" rel="noopener">https://github.com/rozbo/hexo-abbrlink/blob/master/lib/logic.js</a></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> crc16 = <span class="built_in">require</span>(<span class="string">'./crc16'</span>);</span><br><span class="line"><span class="keyword">var</span> crc32 = <span class="built_in">require</span>(<span class="string">'./crc32'</span>);</span><br><span class="line"><span class="keyword">var</span> model = <span class="built_in">require</span>(<span class="string">'./model'</span>);</span><br><span class="line"><span class="keyword">var</span> front = <span class="built_in">require</span>(<span class="string">'hexo-front-matter'</span>);</span><br><span class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">'hexo-fs'</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">org_get_abbrlink</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> r = data.content.match(<span class="regexp">/#\+ABBRLINK:.*\n/</span>);</span><br><span class="line">    <span class="keyword">if</span> (r) &#123;</span><br><span class="line">        data.abbrlink = r[<span class="number">0</span>].split(<span class="string">':'</span>)[<span class="number">1</span>].trim();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        data.abbrlink = <span class="string">''</span></span><br><span class="line">    &#125;</span><br><span class="line">        <span class="keyword">return</span> data</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> logic = <span class="function"><span class="keyword">function</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> log = <span class="keyword">this</span>.log;</span><br><span class="line">    <span class="keyword">if</span> (data.layout == <span class="string">'post'</span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> abbrlink</span><br><span class="line">        <span class="keyword">if</span> (!<span class="regexp">/.*\.org/</span>.test(data.source))&#123;</span><br><span class="line">            abbrlink = data.abbrlink</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            abbrlink = org_get_abbrlink(data).abbrlink</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!abbrlink) &#123;</span><br><span class="line"><span class="keyword">var</span> opt_alg = ((<span class="keyword">this</span>.config.abbrlink &amp;&amp; <span class="keyword">this</span>.config.abbrlink.alg) ? <span class="keyword">this</span>.config.abbrlink.alg : <span class="string">'crc16'</span>);</span><br><span class="line"><span class="keyword">var</span> opt_rep = ((<span class="keyword">this</span>.config.abbrlink &amp;&amp; <span class="keyword">this</span>.config.abbrlink.rep) ? <span class="keyword">this</span>.config.abbrlink.rep : <span class="string">'dec'</span>)</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 注意，这里采用的data.title进行的hash。</span></span><br><span class="line">      <span class="comment">// 很好，正合我意。可以做到path无关hash了。</span></span><br><span class="line"><span class="keyword">let</span> res = (opt_alg == <span class="string">'crc32'</span> ? crc32.str(data.title) &gt;&gt;&gt; <span class="number">0</span> : crc16(data.title) &gt;&gt;&gt; <span class="number">0</span>);</span><br><span class="line"><span class="comment">//check this abbrlink is already exist then get a different one</span></span><br><span class="line">abbrlink = model.check(res);</span><br><span class="line"><span class="comment">//set abbrlink to hex or dec</span></span><br><span class="line">abbrlink = opt_rep == <span class="string">'hex'</span> ? abbrlink.toString(<span class="number">16</span>) : abbrlink;</span><br><span class="line">            data.abbrlink = abbrlink;</span><br><span class="line">            <span class="keyword">let</span> postStr;</span><br><span class="line">            <span class="keyword">if</span> (!<span class="regexp">/.*\.org/</span>.test(data.source))&#123;</span><br><span class="line">            <span class="comment">//re parse front matter</span></span><br><span class="line">            <span class="keyword">var</span> tmpPost = front.parse(data.raw);</span><br><span class="line">            <span class="comment">//add new generated link</span></span><br><span class="line">            tmpPost.abbrlink = abbrlink;</span><br><span class="line">            <span class="comment">//process post  这里要重写post，不建议这样做。有误改原文件的风险。</span></span><br><span class="line">                postStr = front.stringify(tmpPost);</span><br><span class="line">            postStr = <span class="string">'---\n'</span> + postStr;</span><br><span class="line">            fs.writeFileSync(data.full_source, postStr, <span class="string">'utf-8'</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                postStr = data.raw.split(<span class="string">"\n"</span>)</span><br><span class="line">                postStr.splice(<span class="number">2</span>,<span class="number">0</span>,<span class="string">'#+ABBRLINK: '</span> + abbrlink)</span><br><span class="line">                fs.writeFileSync(data.full_source, postStr.join(<span class="string">'\n'</span>), <span class="string">'utf-8'</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            log.i(<span class="string">"Generate link %s for post [%s]"</span>, abbrlink, data.title);</span><br><span class="line">        &#125;</span><br><span class="line">        model.add(abbrlink);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> data</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = logic;</span><br></pre></td></tr></table></figure><p>TODO:</p><ul><li>提供hash配置。比如采用date、path做hash<ul><li>一般用不到，我觉得</li></ul></li><li>不局限hex，可以采用所有数字+字母。容量更大。</li><li>link写入到了.md文件中<ul><li>优势：1. hexo读取方便  2. link复用，减少link的变动，利于SEO  3. 加速，不用每次重新hash</li><li>缺陷：需要重写md文件，强行插入abbrlink属性。</li><li>建议：与hexo动态交互，而不是把link写入到md静态文件。link的复用可以采用独立的数据文件</li></ul></li></ul><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1>]]></content>
      
      <categories>
          
          <category> CS </category>
          
          <category> web </category>
          
          <category> blog-framework </category>
          
          <category> nodejs-hexo </category>
          
          <category> plugin </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
            <tag> plugin </tag>
            
            <tag> hexo-abbrlink </tag>
            
            <tag> permalink </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>OCR</title>
      <link href="/pub/dab63ff1/"/>
      <url>/pub/dab63ff1/</url>
      <content type="html"><![CDATA[<p><a href="https://www.zhihu.com/question/20191727" target="_blank" rel="noopener">OCR文字识别用的是什么算法？—知乎</a></p><h1 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h1><p>General OCR一般包含:</p><ol><li>detection—&gt;找到包含文字的区域(proposal);<ol><li>接着利用radon hough变换 等方法 进行文本校正。</li><li>通过投影直方图分割出单行的文本的图片。</li></ol></li><li>classification—&gt;识别区域中的文字。</li></ol><p>framework是: CNN + LSTM + CTC。这个framework加上residue network + stn可以把通用的数据集刷的非常高。</p><h2 id="detection"><a href="#detection" class="headerlink" title="detection"></a>detection</h2><p>先说detection models, 近两年比较热门的object detection model有 faster-rcnn(<a href="https://arxiv.org/pdf/1506.01497.pdf" target="_blank" rel="noopener">https://arxiv.org/pdf/1506.01497.pdf</a>) 和 yolo(<a href="http://pjreddie.com/media/files/papers/yolo.pdf" target="_blank" rel="noopener">http://pjreddie.com/media/files/papers/yolo.pdf</a>), 两个模型都是基于CNN给出proposed regions 同时对object region进行分类。 其中yolo比faster-rcnn的速度更快，但是在accuracy上有些损失。</p><p>比较著名的是Ian goodfellow在13年提出的multi-digit number classification</p><p>另一类比较常用的方法是RNN/LSTM/GRU + CTC,</p><h1 id="开源工具-amp-代码"><a href="#开源工具-amp-代码" class="headerlink" title="开源工具&amp;代码"></a>开源工具&amp;代码</h1><p><a href="https://github.com/tesseract4java/jtesseract" target="_blank" rel="noopener">https://github.com/tesseract4java/jtesseract</a></p><p>开源包: <a href="https://github.com/tesseract-ocr/tesseract" target="_blank" rel="noopener">tesseract 很赞</a></p><p>最好的模型，竟然是lstm？<a href="https://github.com/tesseract-ocr/tessdata_best" target="_blank" rel="noopener">https://github.com/tesseract-ocr/tessdata_best</a></p>]]></content>
      
      <categories>
          
          <category> ML </category>
          
          <category> applications </category>
          
          <category> vision </category>
          
          <category> OCR </category>
          
      </categories>
      
      
        <tags>
            
            <tag> OCR </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>单页应用</title>
      <link href="/pub/fd7a7791/"/>
      <url>/pub/fd7a7791/</url>
      <content type="html"><![CDATA[<blockquote><p>单页应用（英语：single-page application，缩写SPA）是一种网络应用程序或网站的模型，它通过动态重写当前页面来与用户交互，而非<code>传统的从服务器重新加载整个新页面</code>。这种方法避免了页面之间切换打断用户体验，使应用程序更像一个桌面应用程序。在单页应用中，所有必要的代码（HTML、JavaScript和CSS）都通过单个页面的加载而检索，或者根据需要（通常是为响应用户操作）<code>动态装载适当的资源并添加到页面</code>。尽管可以用位置散列或HTML5历史API来提供应用程序中单独逻辑页面的感知和导航能力，但页面在过程中的任何时间点都不会重新加载，也不会将控制转移到其他页面。[2]与单页应用的交互通常涉及到与网页服务器后端的动态通信。<br>— wikipedia</p></blockquote><p>就是基于ajax技术交互的动态页面呗。</p><blockquote><p>诸如AngularJS、Ember.js、Meteor.js、ExtJS和React等面向网页浏览器的JavaScript框架采纳了单页应用（SPA）原则。</p></blockquote><p>这句话怎么理解？这些框架是为了单页应用设计的？为什么这么说？</p><h1 id="汇总"><a href="#汇总" class="headerlink" title="汇总"></a>汇总</h1><p>参考自掘金 <a href="https://juejin.im/post/5a0ea4ec6fb9a0450407725c" target="_blank" rel="noopener">https://juejin.im/post/5a0ea4ec6fb9a0450407725c</a></p><div class="table-container"><table><thead><tr><th></th><th>单页面应用（SPA）</th><th>多页面应用（MPA）</th></tr></thead><tbody><tr><td>组成</td><td>一个外壳页面和多个页面片段组成</td><td>多个完整页面构成</td></tr><tr><td>资源共用(css,js)</td><td>共用，只需在外壳部分加载</td><td>不共用，每个页面都需要加载</td></tr><tr><td>刷新方式</td><td>页面局部刷新或更改</td><td>整页刷新</td></tr><tr><td>url 模式</td><td>a.com/#/pageone</td><td>a.com/pageone.html</td></tr><tr><td>用户体验</td><td>页面片段间的切换快，用户体验良好</td><td>页面切换加载缓慢，流畅度不够，用户体验比较差</td></tr><tr><td>转场动画</td><td>容易实现</td><td>无法实现</td></tr><tr><td>数据传递</td><td>容易</td><td>依赖 url传参、或者cookie 、localStorage等</td></tr><tr><td>搜索引擎优化(SEO)</td><td>需要单独方案、实现较为困难、不利于SEO检索 可利用服务器端渲染(SSR)优化</td><td>实现方法简易</td></tr><tr><td>试用范围</td><td>高要求的体验度、追求界面流畅的应用</td><td>适用于追求高度支持搜索引擎的应用</td></tr><tr><td>开发成本</td><td>较高，常需借助专业的框架</td><td>较低 ，但页面重复代码多</td></tr><tr><td>维护成本</td><td>相对容易</td><td>相对复杂</td></tr><tr><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td></tr><tr><td></td><td></td></tr></tbody></table></div><h1 id="疑问"><a href="#疑问" class="headerlink" title="疑问"></a>疑问</h1><p>为什么SPA不利于SEO？<br>单页页面，数据在前端渲染。爬虫一般只抓取静态页面，不会调用js来动态生成新页面。</p><p>为什么SPA要首次加载大量资源？<br>前端渲染，肯定前端需要很多js。SPA一定要前端渲染吗，后端可以渲染好html部分元素返回前台吧？</p><p>SPA首次加载大量的静态资源，是前端渲染任务重造成的？</p><h2 id="加载顺序"><a href="#加载顺序" class="headerlink" title="加载顺序"></a>加载顺序</h2><p>首屏渲染速度除了受js文件大小的影响，还有HTML的解析时机。为了提早加载完document，最好将没有用到的其他文件的下载往后推或者异步下载（不要让他阻塞document的加载）。这里给这些js文件添加了 defer属性。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li><a href="https://zh.wikipedia.org/wiki/%E5%8D%95%E9%A1%B5%E5%BA%94%E7%94%A8" target="_blank" rel="noopener">单页应用 | wikipedia</a></li><li><a href="https://www.zhihu.com/question/20792064" target="_blank" rel="noopener">单页应用有那些优缺点？ | 知乎</a></li><li><a href="http://tinyambition.com/Single-Page-App-Break/%E7%AC%AC01%E7%AB%A0%20%E4%BD%95%E4%B8%BA%E5%8D%95%E9%A1%B5%E5%BA%94%E7%94%A8.html" target="_blank" rel="noopener">单页应用开发基础</a></li></ul>]]></content>
      
      <categories>
          
          <category> CS </category>
          
          <category> web </category>
          
          <category> front-end </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 单页应用 </tag>
            
            <tag> angular </tag>
            
            <tag> react </tag>
            
            <tag> ajax </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>文件管理工具 - Everthing原理 之 还没看懂</title>
      <link href="/pub/9299c162/"/>
      <url>/pub/9299c162/</url>
      <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>Everything is an Awesome Utility that Locates Files and Folders Instantly in Windows</p><p><code>Everything</code>仅支持windows系统的NTFS硬盘格式(不支持FAT、FAT32)。<code>Everything</code>默认对文件名、文件大小、日期以及其它某些meta data建索引，可<a href="https://www.voidtools.com/support/everything/indexes/#optimizing_for_smallest_memory_foot_print" target="_blank" rel="noopener">关闭某些字段索引来加速</a>。</p><ol><li>建索引很快<ul><li>数据库文件 Everything.db。 这是什么类型的数据库？自定义的吗？</li></ul></li><li>搜索超快<ul><li>怎样建的索引？咋这么快？建了个hash索引？倒排索引？</li></ul></li><li>实时性好<ul><li>怎样获取的新文件列表？大量的临时文件要不要索引？</li></ul></li></ol><p><code>Everything</code>功能如此强大，让人不禁对其工作原理产生强烈的好奇心。<br>但是，<code>Everthing</code>官方<strong>未开源</strong>，这对想学习其工作原理的程序员来说是个bad news。官方提供<a href="http://www.voidtools.com/support/everything/sdk/" target="_blank" rel="noopener">SDK</a>不知能否看出一些原理逻辑。待看</p><h2 id="啊哈，有相关开源项目"><a href="#啊哈，有相关开源项目" class="headerlink" title="啊哈，有相关开源项目"></a>啊哈，有相关开源项目</h2><p>微软某成员(疑似轮子哥)在codeplex开源了一个类似everything的个人项目<a href="https://archive.codeplex.com/?p=everythingsz" target="_blank" rel="noopener"><code>everythingSZ</code></a>。以下介绍EverythingSZ的原理。</p><h1 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h1><p>Everything搜索文件很快，是利用的NTFS分区的USN功能.</p><p>原理：</p><ul><li>读取NTFS下的USN日志文件<ul><li><a href="https://github.com/BitMindLab/everything/blob/master/UsnOperation/UsnOperator.cs" target="_blank" rel="noopener">UsnOperator类源码</a></li></ul></li><li>根据USN继续查询；</li><li>根据文件编号继续查询；</li><li>创建USN（激活USN状态）；</li><li>NTFS的Change Journal（更改日志）的方法实现监控功能</li></ul><blockquote><p>未采用 FileSystemWatcher 监听文件变化。(everthing不是采用的这个window api)</p></blockquote><h2 id="如何建索引"><a href="#如何建索引" class="headerlink" title="如何建索引"></a>如何建索引</h2><h2 id="如何监听文件变化"><a href="#如何监听文件变化" class="headerlink" title="如何监听文件变化"></a>如何监听文件变化</h2><p>这属于操作系统 &amp; 文件系统的范畴。</p><h3 id="Windows"><a href="#Windows" class="headerlink" title="Windows"></a>Windows</h3><p>即利用windows api。</p><p>以下几种方式：</p><ol><li>FindFirstChangeNotification<ul><li>无法获取是哪一个文件发生了改变。</li></ul></li><li>ReadDirectoryChangesW<ul><li>据说变化量大又密集时，丢失通知现象很严重</li></ul></li><li>FileSystemWatcher<ul><li>貌似是对ReadDirectoryChangesW的封装</li></ul></li><li>NTFS的Change Journal（更改日志）<ul><li>Change Journal是标卷上一个特殊的文件，系统将其隐藏，所以用资源管理器或者CMD Shell都看不到，当文件系统中的文件或者目录发生改变时，就会向日志中追加记录。<a href="https://blog.csdn.net/arrowzz/article/details/75304091" target="_blank" rel="noopener">参考</a></li><li>通过读取和监控USN（后面会讲）而不是扫描文件来构建索引，所以搜索速度飞快</li></ul></li></ol><p>Everything采用了第四种方式，即利用了NTFS系统的Change Journal特性。</p><h3 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h3><ul><li><code>inotify</code> 命令<ul><li>是Linux自带的监控<code>inode</code>变动的函数</li><li>文档 <code>man 7 inotify</code></li></ul></li></ul><h1 id="其它疑问"><a href="#其它疑问" class="headerlink" title="其它疑问"></a>其它疑问</h1><h2 id="linux下有没有类似的工具"><a href="#linux下有没有类似的工具" class="headerlink" title="linux下有没有类似的工具"></a>linux下有没有类似的工具</h2><p>比linux下的find命令快，比locate命令实时性好。</p><ul><li><a href="https://unix.stackexchange.com/questions/31063/is-there-a-file-search-engine-like-everything-in-linux" target="_blank" rel="noopener">见stackexchange</a></li></ul><h1 id="参考-amp-待看"><a href="#参考-amp-待看" class="headerlink" title="参考 &amp; 待看"></a>参考 &amp; 待看</h1><ul><li><a href="https://github.com/BitMindLab/everything" target="_blank" rel="noopener">EverythingSZ源码 - 轮子哥推荐 | Github C#</a></li><li><a href="https://github.com/yuzhengyang/Everything" target="_blank" rel="noopener">探索Everything背后的技术（USN和MFT）| Github</a></li><li><a href="https://blog.csdn.net/column/details/16576.html" target="_blank" rel="noopener">NTFS系列</a></li><li><a href="https://blog.csdn.net/xexiyong/article/details/17200827" target="_blank" rel="noopener">密切关注你的NTFS驱动器 | CSDN</a><br>-</li></ul>]]></content>
      
      <categories>
          
          <category> CS </category>
          
          <category> tools </category>
          
          <category> 文件管理 </category>
          
          <category> everything </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Everthing </tag>
            
            <tag> 文件管理 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>如何debug typescript</title>
      <link href="/pub/848e312f/"/>
      <url>/pub/848e312f/</url>
      <content type="html"><![CDATA[<h1 id="Debugging-TypeScript-in-Visual-Studio"><a href="#Debugging-TypeScript-in-Visual-Studio" class="headerlink" title="Debugging TypeScript in Visual Studio"></a>Debugging TypeScript in Visual Studio</h1><h1 id="Debugging-TypeScript-in-Firefox-or-Chrome"><a href="#Debugging-TypeScript-in-Firefox-or-Chrome" class="headerlink" title="Debugging TypeScript in Firefox or Chrome"></a>Debugging TypeScript in Firefox or Chrome</h1><p>在ts中写个console.info(“ds”)<br>然后浏览器</p><h1 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h1><p>浏览器默认是不认识typescript的，如何做到在浏览器debug typescript的呢？</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://blogs.msdn.microsoft.com/jtarquino/2016/01/24/debugging-typescript-in-visual-studio-code-and-chrome/" target="_blank" rel="noopener">https://blogs.msdn.microsoft.com/jtarquino/2016/01/24/debugging-typescript-in-visual-studio-code-and-chrome/</a></p>]]></content>
      
      <categories>
          
          <category> CS </category>
          
          <category> web </category>
          
          <category> front-end </category>
          
          <category> framework </category>
          
          <category> Angular </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>【Angular系列】 基本概念</title>
      <link href="/pub/84fd5459/"/>
      <url>/pub/84fd5459/</url>
      <content type="html"><![CDATA[<h2 id="运行环境"><a href="#运行环境" class="headerlink" title="运行环境"></a>运行环境</h2><p>由于目前各种环境（浏览器或 Node）暂不支持ES6的代码，所以需要一些shim和polyfill（IE需要）让ES6写的代码能够转化为ES5形式并可以正常运行在浏览器中。</p><p><img src="http://www.runoob.com/wp-content/uploads/2016/09/toolchain.jpg"> </p><p>从上图可以看出在 Es5 浏览器下需要以下模块加载器：</p><ul><li>systemjs - 通用模块加载器，支持AMD、CommonJS、ES6等各种格式的JS模块加载。</li><li>es6-module-loader - ES6模块加载器，systemjs会自动加载这个模块。</li><li>traceur - ES6转码器，将ES6代码转换为当前浏览器支持的ES5代码，systemjs会自动加载 这个模块。</li></ul><h2 id="组件和模块的区别"><a href="#组件和模块的区别" class="headerlink" title="组件和模块的区别"></a>组件和模块的区别</h2><p>组件(Component)和模块(Module)又是一对容易混淆的名词，也常常被用来相互替换。</p><h3 id="模块"><a href="#模块" class="headerlink" title="模块"></a>模块</h3><p>模块相当于是一个namespace，或者package，表示的是一堆功能单元的集合。</p><p>Angular应用都是模块化的，</p><ul><li>命名空间：<br>在JavaScript中，最高级别的函数外定义的变量都是全局变量（这意味着所有人都可以访问到它们）。也正因如此，当一些无关的代码碰巧使用到同名变量的时候，我们就会遇到“命名空间污染”的问题。</li><li>可维护性：<br>命名空间的隔离实现了每个模块的独立性。良好设计的模块会尽量与外部的代码撇清关系，以便于独立对其进行改进和维护。可复用性也好</li></ul><h3 id="组件"><a href="#组件" class="headerlink" title="组件"></a>组件</h3><p>一般来说，一个组件就是一个用于控制视图模板的JavaScript类。</p><p>从设计上来看，组件强调复用，模块强调职责(内聚、分离)，或者说组件是达到可复用要求的模块。</p><h1 id="习题"><a href="#习题" class="headerlink" title="习题"></a>习题</h1><p>原生javascript(ES5)不支持模块化，类难道不起到了隔离作用吗？<br>原生JavaScript并不支持类，虽然最新的ES6里引入了Class不过还不普及。</p><p>没有内置的模块化系统，可以使用第三方模块系统。</p><p>疑问，angular4 是否有cdn？cdn只看到了1 和 2。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://zhuanlan.zhihu.com/p/22890374" target="_blank" rel="noopener">JavaScript 模块化入门Ⅰ：理解模块</a></p>]]></content>
      
      <categories>
          
          <category> CS </category>
          
          <category> web </category>
          
          <category> front-end </category>
          
          <category> framework </category>
          
          <category> Angular </category>
          
      </categories>
      
      
        <tags>
            
            <tag> angular </tag>
            
            <tag> front-end </tag>
            
            <tag> 前端架构 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>【Angular系列】Angular 快速入门教程 - Hello Angular</title>
      <link href="/pub/40a5132a/"/>
      <url>/pub/40a5132a/</url>
      <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>Angular 是由谷歌开发与维护一个开发跨平台应用程序的框架，同时适用于手机与桌面。</p><p>其模板基于双向UI数据绑定。数据绑定是一种自动方法，在模型改变时更新视图，以及在视图改变时更新模型。</p><p>以下代码来自<a href="https://github.com/angular/quickstart" target="_blank" rel="noopener">https://github.com/angular/quickstart</a></p><h2 id="流程简介"><a href="#流程简介" class="headerlink" title="流程简介"></a>流程简介</h2><ul><li><a href="https://github.com/angular/quickstart" target="_blank" rel="noopener">https://github.com/angular/quickstart</a>  (本文代码的来源)</li><li><a href="https://angular.io/guide/quickstart" target="_blank" rel="noopener">https://angular.io/guide/quickstart</a></li></ul><ol><li>浏览器默认请求<code>index.html</code></li><li><code>index.html</code>调用<code>main.js</code></li><li><code>main.js</code>调用<code>app.component.js</code></li><li><code>app.component.js</code>扫描html，发现有<code>my-app</code>标签，将字符串<code>&lt;h1&gt;Hello &lt;/h1&gt;</code>动态插入到<code>my-app</code>元素里。</li><li><code>angular的js</code>扫描html，发现了<code></code>，向后台发送一个动态请求 (好像是在js中的hard code)</li></ol><p>实际node后台顺序貌似是反向的。</p><h2 id="流程分解"><a href="#流程分解" class="headerlink" title="流程分解"></a>流程分解</h2><h3 id="入口-index-html"><a href="#入口-index-html" class="headerlink" title="入口 index.html"></a>入口 index.html</h3><p>以下是<code>index.html</code>，其中调用了<code>main.js</code></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- src/index.html --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Angular QuickStart<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">base</span> <span class="attr">href</span>=<span class="string">"/"</span>&gt;</span>   <span class="comment">&lt;!-- 如果想双击运行html的话，需要去掉这行，并加入angular依赖 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width, initial-scale=1"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span> <span class="attr">href</span>=<span class="string">"styles.css"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- IE 需要 polyfill --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"node_modules/core-js/client/shim.min.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"node_modules/zone.js/dist/zone.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"node_modules/systemjs/dist/system.src.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 这里是Angular的入口js文件 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"systemjs.config.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">      System.import(<span class="string">'main.js'</span>).catch(<span class="function"><span class="keyword">function</span>(<span class="params">err</span>)</span>&#123; <span class="built_in">console</span>.error(err); &#125;);</span></span><br><span class="line"><span class="undefined">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 使用 AppComponent 组件 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">my-app</span>&gt;</span>Loading AppComponent content here ...<span class="tag">&lt;/<span class="name">my-app</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在<code>main.ts</code>中设置断点，会看到页面是这样子的。</p><p><img src="/images/raw/Web - frontend - Angular - quickstart.png"></p><h3 id="main-ts"><a href="#main-ts" class="headerlink" title="main.ts"></a>main.ts</h3><p><code>main.ts</code>调用 AppModule模块，会创建AppModule类。(由Angular的NgModuleFactory创建)<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/main.ts</span></span><br><span class="line"><span class="keyword">import</span> &#123; platformBrowserDynamic &#125; <span class="keyword">from</span> <span class="string">'@angular/platform-browser-dynamic'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; AppModule &#125; <span class="keyword">from</span> <span class="string">'./app/app.module'</span>;</span><br><span class="line">platformBrowserDynamic().bootstrapModule(AppModule);</span><br></pre></td></tr></table></figure></p><h3 id="AppModule-模块"><a href="#AppModule-模块" class="headerlink" title="AppModule 模块"></a>AppModule 模块</h3><p><code>AppModule</code>模块的声明如下。其中调用了<code>AppComponent</code>组件，即首先创建<code>AppComponent</code>类。(由Angular的ComponentFactory创建)<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/app/app.module.ts</span></span><br><span class="line"><span class="keyword">import</span> &#123; NgModule &#125;      <span class="keyword">from</span> <span class="string">'@angular/core'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; BrowserModule &#125; <span class="keyword">from</span> <span class="string">'@angular/platform-browser'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; AppComponent &#125;  <span class="keyword">from</span> <span class="string">'./app.component'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// NgModule指令实现数据的双向绑定</span></span><br><span class="line">@NgModule(&#123;</span><br><span class="line">  imports:      [ BrowserModule ],</span><br><span class="line">  declarations: [ AppComponent ],</span><br><span class="line">  bootstrap:    [ AppComponent ]</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">AppModule</span> </span>&#123; &#125;</span><br></pre></td></tr></table></figure></p><h3 id="AppComponent-组件"><a href="#AppComponent-组件" class="headerlink" title="AppComponent 组件"></a>AppComponent 组件</h3><p><code>AppComponent</code> 组件会对html中的<code>my-app</code>标签进行渲染，返回<code>template</code>中指定的元素。</p><p>以下是<code>AppComponent</code>组件的声明</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/app/app.component.ts</span></span><br><span class="line"><span class="keyword">import</span> &#123; Component &#125; <span class="keyword">from</span> <span class="string">'@angular/core'</span>;</span><br><span class="line"><span class="comment">// 通过 Component 装饰器和自定义组件类来创建自定义组件</span></span><br><span class="line">@Component(&#123; <span class="comment">// 定义组件的元信息</span></span><br><span class="line">  selector: <span class="string">'my-app'</span>, <span class="comment">// 用于定义组件在HTML代码中匹配的标签</span></span><br><span class="line">  template: <span class="string">`&lt;h1&gt;Hello &#123;&#123;name&#125;&#125;&lt;/h1&gt;`</span>, <span class="comment">// 定义组件内嵌视图。利用 &#123;&#123;&#125;&#125; 插值表达式实现数据绑定。这是单向绑定吧？</span></span><br><span class="line">  <span class="comment">// 双向绑定：&lt;input [(ngModel)]="todo.text"&gt;</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 定义组件类</span></span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">AppComponent</span>  </span>&#123; name = <span class="string">'Angular'</span>; &#125;</span><br></pre></td></tr></table></figure><p>其中<code></code>变量是在浏览器端渲染。</p><p>值得注意的是这里的<code>template</code>。<br>Angular模板基于双向UI数据绑定。在模型改变时自动更新视图，以及在视图改变时自动更新模型。其HTML模板在浏览器中编译。<br>比如这里的<code>&lt;h1&gt;Hello &lt;/h1&gt;</code>。</p><h1 id="工作流程"><a href="#工作流程" class="headerlink" title="工作流程"></a>工作流程</h1><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#123;</span></span><br><span class="line"><span class="attr">  "name":</span> <span class="string">"angular-quickstart"</span><span class="string">,</span></span><br><span class="line"><span class="attr">  "version":</span> <span class="string">"1.0.0"</span><span class="string">,</span></span><br><span class="line"><span class="attr">  "description":</span> <span class="string">"QuickStart package.json from the documentation, supplemented with testing support"</span><span class="string">,</span></span><br><span class="line"><span class="attr">  "scripts":</span> <span class="string">&#123;</span></span><br><span class="line"><span class="attr">    "build":</span> <span class="string">"tsc -p src/"</span><span class="string">,</span> <span class="comment"># 采用的tsc编译器，node自带的ts编译器。也可以采用webpack，</span></span><br><span class="line">    <span class="string">"build:watch"</span><span class="string">:</span> <span class="string">"tsc -p src/ -w"</span><span class="string">,</span></span><br><span class="line">    <span class="string">"build:e2e"</span><span class="string">:</span> <span class="string">"tsc -p e2e/"</span><span class="string">,</span>  <span class="comment">#  end-to-end tests.</span></span><br><span class="line"><span class="attr">    "serve":</span> <span class="string">"lite-server -c=bs-config.json"</span><span class="string">,</span>  <span class="comment"># 轻量级node静态文件服务器，默认会读取当前目录下的bs-config.js或者bs-config.json文件做为配置导入</span></span><br><span class="line">    <span class="string">"serve:e2e"</span><span class="string">:</span> <span class="string">"lite-server -c=bs-config.e2e.json"</span><span class="string">,</span></span><br><span class="line"><span class="attr">    "prestart":</span> <span class="string">"npm run build"</span><span class="string">,</span></span><br><span class="line"><span class="attr">    "start":</span> <span class="string">"concurrently \"npm run build:watch\" \"npm run serve\""</span><span class="string">,</span> <span class="comment">#  runs the compiler and a server at the same tim</span></span><br><span class="line"><span class="attr">    "pree2e":</span> <span class="string">"npm run build:e2e"</span><span class="string">,</span></span><br><span class="line"><span class="attr">    "e2e":</span> <span class="string">"concurrently \"npm run serve:e2e\" \"npm run protractor\" --kill-others --success first"</span><span class="string">,</span></span><br><span class="line"><span class="attr">    "preprotractor":</span> <span class="string">"webdriver-manager update"</span><span class="string">,</span></span><br><span class="line"><span class="attr">    "protractor":</span> <span class="string">"protractor protractor.config.js"</span><span class="string">,</span></span><br><span class="line"><span class="attr">    "pretest":</span> <span class="string">"npm run build"</span><span class="string">,</span></span><br><span class="line"><span class="attr">    "test":</span> <span class="string">"concurrently \"npm run build:watch\" \"karma start karma.conf.js\""</span><span class="string">,</span></span><br><span class="line">    <span class="string">"pretest:once"</span><span class="string">:</span> <span class="string">"npm run build"</span><span class="string">,</span></span><br><span class="line">    <span class="string">"test:once"</span><span class="string">:</span> <span class="string">"karma start karma.conf.js --single-run"</span><span class="string">,</span></span><br><span class="line"><span class="attr">    "lint":</span> <span class="string">"tslint ./src/**/*.ts -t verbose"</span></span><br><span class="line">  <span class="string">&#125;,</span></span><br><span class="line"><span class="attr">  "keywords":</span> <span class="string">[],</span></span><br><span class="line"><span class="attr">  "author":</span> <span class="string">""</span><span class="string">,</span></span><br><span class="line"><span class="attr">  "license":</span> <span class="string">"MIT"</span><span class="string">,</span></span><br><span class="line"><span class="attr">  "dependencies":</span> <span class="string">&#123;</span></span><br><span class="line">    <span class="string">"@angular/common"</span><span class="string">:</span> <span class="string">"~4.3.4"</span><span class="string">,</span></span><br><span class="line">    <span class="string">"@angular/compiler"</span><span class="string">:</span> <span class="string">"~4.3.4"</span><span class="string">,</span></span><br><span class="line">    <span class="string">"@angular/core"</span><span class="string">:</span> <span class="string">"~4.3.4"</span><span class="string">,</span></span><br><span class="line">    <span class="string">"@angular/forms"</span><span class="string">:</span> <span class="string">"~4.3.4"</span><span class="string">,</span></span><br><span class="line">    <span class="string">"@angular/http"</span><span class="string">:</span> <span class="string">"~4.3.4"</span><span class="string">,</span></span><br><span class="line">    <span class="string">"@angular/platform-browser"</span><span class="string">:</span> <span class="string">"~4.3.4"</span><span class="string">,</span></span><br><span class="line">    <span class="string">"@angular/platform-browser-dynamic"</span><span class="string">:</span> <span class="string">"~4.3.4"</span><span class="string">,</span></span><br><span class="line">    <span class="string">"@angular/router"</span><span class="string">:</span> <span class="string">"~4.3.4"</span><span class="string">,</span></span><br><span class="line"><span class="attr">    "angular-in-memory-web-api":</span> <span class="string">"~0.3.0"</span><span class="string">,</span></span><br><span class="line"><span class="attr">    "systemjs":</span> <span class="string">"0.19.40"</span><span class="string">,</span></span><br><span class="line"><span class="attr">    "core-js":</span> <span class="string">"^2.4.1"</span><span class="string">,</span></span><br><span class="line"><span class="attr">    "rxjs":</span> <span class="string">"5.0.1"</span><span class="string">,</span></span><br><span class="line">    <span class="string">"zone.js"</span><span class="string">:</span> <span class="string">"^0.8.4"</span></span><br><span class="line">  <span class="string">&#125;,</span></span><br><span class="line"><span class="attr">  "devDependencies":</span> <span class="string">&#123;</span></span><br><span class="line"><span class="attr">    "concurrently":</span> <span class="string">"^3.2.0"</span><span class="string">,</span></span><br><span class="line"><span class="attr">    "lite-server":</span> <span class="string">"^2.2.2"</span><span class="string">,</span></span><br><span class="line"><span class="attr">    "typescript":</span> <span class="string">"~2.1.0"</span><span class="string">,</span></span><br><span class="line"><span class="attr">    "canonical-path":</span> <span class="string">"0.0.2"</span><span class="string">,</span></span><br><span class="line"><span class="attr">    "tslint":</span> <span class="string">"^3.15.1"</span><span class="string">,</span></span><br><span class="line"><span class="attr">    "lodash":</span> <span class="string">"^4.16.4"</span><span class="string">,</span></span><br><span class="line"><span class="attr">    "jasmine-core":</span> <span class="string">"~2.4.1"</span><span class="string">,</span></span><br><span class="line"><span class="attr">    "karma":</span> <span class="string">"^1.3.0"</span><span class="string">,</span></span><br><span class="line"><span class="attr">    "karma-chrome-launcher":</span> <span class="string">"^2.0.0"</span><span class="string">,</span></span><br><span class="line"><span class="attr">    "karma-cli":</span> <span class="string">"^1.0.1"</span><span class="string">,</span></span><br><span class="line"><span class="attr">    "karma-jasmine":</span> <span class="string">"^1.0.2"</span><span class="string">,</span></span><br><span class="line"><span class="attr">    "karma-jasmine-html-reporter":</span> <span class="string">"^0.2.2"</span><span class="string">,</span></span><br><span class="line"><span class="attr">    "protractor":</span> <span class="string">"~4.0.14"</span><span class="string">,</span></span><br><span class="line"><span class="attr">    "rimraf":</span> <span class="string">"^2.5.4"</span><span class="string">,</span></span><br><span class="line">    <span class="string">"@types/node"</span><span class="string">:</span> <span class="string">"^6.0.46"</span><span class="string">,</span></span><br><span class="line">    <span class="string">"@types/jasmine"</span><span class="string">:</span> <span class="string">"2.5.36"</span></span><br><span class="line">  <span class="string">&#125;,</span></span><br><span class="line"><span class="attr">  "repository":</span> <span class="string">&#123;&#125;</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure><h1 id="疑问"><a href="#疑问" class="headerlink" title="疑问"></a>疑问</h1><ol><li>这个project，如何不依赖node，直接双击在浏览器运行？</li><li>这里的是绑定的js中写死的静态变量。如何绑定后台的一个动态变量？</li></ol><h1 id="其他angular入门教程"><a href="#其他angular入门教程" class="headerlink" title="其他angular入门教程"></a>其他angular入门教程</h1><ul><li>首推教程 Angular 2 教程 <a href="http://www.runoob.com/angularjs2/angularjs2-tutorial.html" target="_blank" rel="noopener">http://www.runoob.com/angularjs2/angularjs2-tutorial.html</a>  可直接双击html执行</li><li>Angular 4 教程 <a href="https://www.w3cschool.cn/angular/" target="_blank" rel="noopener">https://www.w3cschool.cn/angular/</a></li></ul>]]></content>
      
      <categories>
          
          <category> CS </category>
          
          <category> web </category>
          
          <category> front-end </category>
          
          <category> framework </category>
          
          <category> Angular </category>
          
      </categories>
      
      
        <tags>
            
            <tag> angular </tag>
            
            <tag> front-end </tag>
            
            <tag> 前端架构 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>webpack原理</title>
      <link href="/pub/6e75b89d/"/>
      <url>/pub/6e75b89d/</url>
      <content type="html"><![CDATA[<p>webpack是一个js打包工具，不是一个完整的前端构建工具。它的流行得益于模块化和单页应用的流行。webpack提供扩展机制，在庞大的社区支持下各种场景基本它都可找到解决方案。</p><h3 id="webpack核心概念"><a href="#webpack核心概念" class="headerlink" title="webpack核心概念"></a>webpack核心概念</h3><ul><li><code>entry</code> 一个可执行模块或库的入口文件。Webpack 执行构建的第一步将从 Entry 开始</li><li><code>Module</code>：模块，在 Webpack 里一切皆模块，一个模块对于着一个文件。Webpack 会从配置的 Entry 开始递归找出所有依赖的模块。</li><li><code>chunk</code> 多个文件组成的一个代码块，例如把一个可执行模块和它所有依赖的模块组合和一个 chunk 这体现了webpack的打包机制。</li><li><code>loader</code> 文件转换器，例如把es6转换为es5，scss转换为css。</li><li><code>plugin</code> 插件，用于扩展webpack的功能，在webpack构建生命周期的节点上加入扩展hook为webpack加入功能。</li></ul><p>Webpack 启动后会从 Entry 里配置的 Module 开始递归解析 Entry 依赖的所有 Module。<br>每找到一个 Module 就会根据配置的 Loader 规则去找出对应的转换规则立即对 Module 进行转换后，再解析出当前 Module 依赖的 Module。<br>这些模块会以 Entry 为单位进行分组，一个 Entry 和其所有依赖的 Module 被分到一个组也就是一个 Chunk。最后 Webpack 会把所有的 Chunk 转换成文件输出。<br>在整个流程中 Webpack 会在恰当的时候执行 Plugin 里定义的逻辑。</p><h2 id="webpack构建流程"><a href="#webpack构建流程" class="headerlink" title="webpack构建流程"></a>webpack构建流程</h2><p>从启动webpack构建到输出结果经历了一系列过程，它们是：</p><ol><li>解析webpack配置参数，合并从shell传入和webpack.config.js文件里配置的参数，生产最后的配置结果。</li><li>注册所有配置的插件，好让插件监听webpack构建生命周期的事件节点，以做出对应的反应。</li><li>从配置的entry入口文件开始解析文件构建AST语法树，找出每个文件所依赖的文件，递归下去。</li><li>在解析文件递归的过程中根据文件类型和loader配置找出合适的loader用来对文件进行转换。</li><li>递归完后得到每个文件的最终结果，根据entry配置生成代码块chunk。</li><li>输出所有chunk到文件系统。</li></ol><p>需要注意的是，在构建生命周期中有一系列插件在合适的时机做了合适的事情，比如UglifyJsPlugin会在loader转换递归完后对结果再使用UglifyJs压缩覆盖之前的结果。</p><h2 id="webpack原理"><a href="#webpack原理" class="headerlink" title="webpack原理"></a>webpack原理</h2><ol><li>一切皆模块<br><br>正如js文件可以是一个“模块（module）”一样，其他的（如css、image或html）文件也可视作模 块。因此，你可以require(‘myJSfile.js’)亦可以require(‘myCSSfile.css’)。这意味着我们可以将事物（业务）分割成更小的易于管理的片段，从而达到重复利用等的目的。</li><li>按需加载<br><br>传统的模块打包工具（module bundlers）最终将所有的模块编译生成一个庞大的bundle.js文件。但是在真实的app里边，“bundle.js”文件可能有10M到15M之大可能会导致应用一直处于加载中状态。因此Webpack使用许多特性来分割代码然后生成多个“bundle”文件，而且异步加载部分代码以实现按需加载。</li></ol><h2 id="example"><a href="#example" class="headerlink" title="example"></a>example</h2><p>示例文件 webpack.config.js<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @author: @AngularClass</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Look in ./config folder for webpack.dev.js</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">switch</span> (process.env.NODE_ENV) &#123;</span><br><span class="line">  <span class="keyword">case</span> <span class="string">'prod'</span>:</span><br><span class="line">  <span class="keyword">case</span> <span class="string">'production'</span>:</span><br><span class="line">    <span class="built_in">module</span>.exports = <span class="built_in">require</span>(<span class="string">'./config/webpack.prod'</span>)(&#123;<span class="attr">env</span>: <span class="string">'production'</span>&#125;);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> <span class="string">'test'</span>:</span><br><span class="line">  <span class="keyword">case</span> <span class="string">'testing'</span>:</span><br><span class="line">    <span class="built_in">module</span>.exports = <span class="built_in">require</span>(<span class="string">'./config/webpack.test'</span>)(&#123;<span class="attr">env</span>: <span class="string">'test'</span>&#125;);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> <span class="string">'dev'</span>:</span><br><span class="line">  <span class="keyword">case</span> <span class="string">'development'</span>:</span><br><span class="line">  <span class="keyword">default</span>:</span><br><span class="line">    <span class="built_in">module</span>.exports = <span class="built_in">require</span>(<span class="string">'./config/webpack.dev'</span>)(&#123;<span class="attr">env</span>: <span class="string">'development'</span>&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>tsconfig.webpack.json<br><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#123;</span></span><br><span class="line"><span class="attr">  "compilerOptions":</span> <span class="string">&#123;</span></span><br><span class="line"><span class="attr">    "target":</span> <span class="string">"es5"</span><span class="string">,</span></span><br><span class="line"><span class="attr">    "module":</span> <span class="string">"es2015"</span><span class="string">,</span></span><br><span class="line"><span class="attr">    "moduleResolution":</span> <span class="string">"node"</span><span class="string">,</span></span><br><span class="line"><span class="attr">    "emitDecoratorMetadata":</span> <span class="literal">true</span><span class="string">,</span></span><br><span class="line"><span class="attr">    "experimentalDecorators":</span> <span class="literal">true</span><span class="string">,</span></span><br><span class="line"><span class="attr">    "allowSyntheticDefaultImports":</span> <span class="literal">true</span><span class="string">,</span></span><br><span class="line"><span class="attr">    "sourceMap":</span> <span class="literal">true</span><span class="string">,</span></span><br><span class="line"><span class="attr">    "noEmit":</span> <span class="literal">true</span><span class="string">,</span></span><br><span class="line"><span class="attr">    "noEmitHelpers":</span> <span class="literal">true</span><span class="string">,</span></span><br><span class="line"><span class="attr">    "importHelpers":</span> <span class="literal">true</span><span class="string">,</span></span><br><span class="line"><span class="attr">    "strictNullChecks":</span> <span class="literal">false</span><span class="string">,</span></span><br><span class="line"><span class="attr">    "lib":</span> <span class="string">[</span></span><br><span class="line">      <span class="string">"es2015"</span><span class="string">,</span></span><br><span class="line">      <span class="string">"dom"</span></span><br><span class="line">    <span class="string">],</span></span><br><span class="line"><span class="attr">    "baseUrl":</span> <span class="string">"."</span><span class="string">,</span></span><br><span class="line"><span class="attr">    "paths":</span> <span class="string">&#123;</span></span><br><span class="line">      <span class="string">"@angular/*"</span><span class="string">:</span> <span class="string">["node_modules/@angular/*"]</span></span><br><span class="line">    <span class="string">&#125;,</span></span><br><span class="line"><span class="attr">    "typeRoots":</span> <span class="string">[</span></span><br><span class="line">      <span class="string">"node_modules/@types"</span></span><br><span class="line">    <span class="string">],</span></span><br><span class="line"><span class="attr">    "types":</span> <span class="string">[</span></span><br><span class="line">      <span class="string">"hammerjs"</span><span class="string">,</span></span><br><span class="line">      <span class="string">"node"</span></span><br><span class="line">    <span class="string">]</span></span><br><span class="line">  <span class="string">&#125;,</span></span><br><span class="line"><span class="attr">  "exclude":</span> <span class="string">[</span></span><br><span class="line">    <span class="string">"node_modules"</span><span class="string">,</span></span><br><span class="line">    <span class="string">"client/dist"</span><span class="string">,</span></span><br><span class="line">    <span class="string">"client/src/**/*.spec.ts"</span><span class="string">,</span></span><br><span class="line">    <span class="string">"client/src/**/*.e2e.ts"</span></span><br><span class="line">  <span class="string">],</span></span><br><span class="line"><span class="attr">  "awesomeTypescriptLoaderOptions":</span> <span class="string">&#123;</span></span><br><span class="line"><span class="attr">    "forkChecker":</span> <span class="literal">true</span><span class="string">,</span></span><br><span class="line"><span class="attr">    "useWebpackText":</span> <span class="literal">true</span></span><br><span class="line">  <span class="string">&#125;,</span></span><br><span class="line"><span class="attr">  "angularCompilerOptions":</span> <span class="string">&#123;</span></span><br><span class="line"><span class="attr">    "genDir":</span> <span class="string">"./compiled"</span><span class="string">,</span></span><br><span class="line"><span class="attr">    "skipMetadataEmit":</span> <span class="literal">true</span></span><br><span class="line">  <span class="string">&#125;,</span></span><br><span class="line"><span class="attr">  "compileOnSave":</span> <span class="literal">false</span><span class="string">,</span></span><br><span class="line"><span class="attr">  "buildOnSave":</span> <span class="literal">false</span><span class="string">,</span></span><br><span class="line"><span class="attr">  "atom":</span> <span class="string">&#123;</span></span><br><span class="line"><span class="attr">    "rewriteTsconfig":</span> <span class="literal">false</span></span><br><span class="line">  <span class="string">&#125;</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://github.com/gwuhaolin/blog/issues/4" target="_blank" rel="noopener">https://github.com/gwuhaolin/blog/issues/4</a></p><p><a href="http://webpack.wuhaolin.cn/" target="_blank" rel="noopener">深入浅出 Webpack</a></p><h1 id=""><a href="#" class="headerlink" title="#"></a>#</h1>]]></content>
      
      <categories>
          
          <category> CS </category>
          
          <category> web </category>
          
          <category> front-end </category>
          
          <category> 前端构建工具 </category>
          
          <category> webpack </category>
          
      </categories>
      
      
        <tags>
            
            <tag> webpack </tag>
            
            <tag> 构建工具 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>2018 - 中美贸易战</title>
      <link href="/pub/40e93d5d/"/>
      <url>/pub/40e93d5d/</url>
      <content type="html"><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>据中方统计，最近10年间美国对中国出口年均增长11%，几乎是同期中国对美国出口年均增速的两倍。美国62%的大豆、14%的棉花、25%的波音飞机、17%的汽车、15%的集成电路都出口到中国。</p><p>而据美国官方数据，2016年中国是美国农产品第二大出口市场；每个美国农民平均向中国出口农产品约1.2万美元。</p><p>时间线</p><ul><li>宣战</li><li>回应</li><li>结束，<a href="https://mp.weixin.qq.com/s?__biz=MzA5NjU0NTEzMg==&amp;mid=2652226604&amp;idx=3&amp;sn=e2d780e544bf3c15abed8cb5afbf42c3&amp;chksm=8b4f142fbc389d391ed69778b2da6b475b661dce4dd90ad1e0e58a2df5fc804af2f47e9f9aff&amp;mpshare=1&amp;scene=23&amp;srcid=0329JgvZuHRQownNW7ZwipsM#rd" target="_blank" rel="noopener">中国提出把部分从韩国和台湾采购的半导体转而向美国购买，以减少中国对美国的贸易顺差</a></li><li>2018-04-16: <a href="http://new.qq.com/omn/20180419/20180419A1R86O.html?pgv_ref=aio2015&amp;ptlang=2052" target="_blank" rel="noopener">美国商务部下令禁止美国公司向中兴出售元器件等产品，为期7年</a><ul><li><a href="https://www.zhihu.com/question/273562609" target="_blank" rel="noopener">如何评价 2018 年 4 月中兴通讯同时遭英美两国制裁？| 知乎</a></li><li>华为年底退出美国市场</li></ul></li><li>2018.04.25，据《华尔街日报》消息称，美国司法部正在对<strong>华为</strong>是否违反了美国对伊朗的制裁规定进行调查<br>除了中兴、华为外，特朗普还准备对阿里下手了！阿里在美国提供的云端运算服务可能会被禁止。</li><li>2018.06.15 美国发布了加征关税商品清单，将对从中国进口的约500亿美元商品加征25%的关税</li><li>2018.06.19 特朗普通过白宫发布声明，“考虑对额外2000亿美元的中国商品加征10%的关税。如果中国仍拒绝改变其贸易行为，美国将在法律程序完成后正式对这批中国商品开证关税。此外，如果中国再次出台对等措施，还将考虑再对2000亿美元的中国商品征税。”  4500亿美元的商品占对美出口的90%</li><li>2018.06.19 中国A股暴跌，千股跌停。黑色星期二。暴跌的主要原因就是今早7点半，特朗普的白宫声明</li><li>2018.06.19 商务部发表声明：如果美方失去理性，中方将不得不采取数量型和质量型相结合的综合措施，做出强有力的反制。因为美国对华出口额仅1300亿，因此提出来质量型</li><li>2018.7.6 经国务院批准，对原产于美国的659项约500亿美元进口商品加征25%的关税。主要包括 牛猪鸡鸭鱼虾蟹、植物、越野车小汽车、化学医疗等。美方发表声明称，<strong>如果中国采取报复性措施，美国将继续追加额外关税</strong>。</li></ul><h2 id="中美贸易领域"><a href="#中美贸易领域" class="headerlink" title="中美贸易领域"></a>中美贸易领域</h2><p>贸易战这个东西我觉得要考虑双方的进出口情况：美国：进口的主要是日常消费品，比如服装、玩具等，数量规模大，和老百姓生活相关度高，打贸易战会造成美国人民日常消费成本大幅度增加，会造成美国人民反对该政策；          </p><p>出口的主要是粮食作物和芯片等技术类产品，会造成部分高科技公司的收入减少，部分农业受到冲击，鉴于美国农业的大规模种植水平，受到影响的人不会太多。中国：进口粮食（主要是大豆），食用油价格预期会上涨，芯片类科技产品推进国产化，这点题主已经提到了，台湾很可能会跟着美国走，所以电子产品预计会价格上涨；</p><p>出口的日常消费品受影响这方面才是危险的，因为失掉美国市场后，过剩产能如果不能及时消化，会造成上述行业大量的滞销、停产以及人员失业，这个影响的人会很多，国民收入减少会导致内需萎缩，对国内经济冲击会比较大。</p><h3 id="依赖性分析"><a href="#依赖性分析" class="headerlink" title="依赖性分析"></a>依赖性分析</h3><ul><li>中国是美国飞机和大豆的第一大出口市场，也是汽车和棉花的第二大出口市场</li></ul><h2 id="中美贸易逆差"><a href="#中美贸易逆差" class="headerlink" title="中美贸易逆差"></a>中美贸易逆差</h2><p><img title="中国与世界主要国家和地区的贸易平衡" alt="中国与世界主要国家和地区的贸易平衡" src="/images/raw/Economy - 中国与世界主要国家和地区的贸易平衡 - 人民日报.jpg"></p><p>以往，中国的集成电路主要从韩国、日本和中国台湾进口，也正因此，在中国与多国的双边贸易中，韩国、日本与中国台湾是难得的几个与中国大陆保持顺差纪录的地区。</p><h2 id="宣战"><a href="#宣战" class="headerlink" title="宣战"></a>宣战</h2><p>美国总统特朗普当地时间22日中午在白宫签署针对中国的总统备忘录，宣布基于“301调查”结果，将对约600亿美元进口自中国的商品加征关税，并对中资投资美国设限等。</p><p>中国随即作出回应。中国驻美大使馆发表声明说，中方不希望打贸易战，但绝不惧怕贸易战，有信心、有能力应对任何挑战。如果美方执意要打，我们将奉陪到底，并采取所有必要措施坚决捍卫自身合法权益。</p><p>几个小时后，中国商务部公布针对美国进口钢铁和铝产品232措施的中止减让产品清单，拟对约30亿美元自美进口商品加征关税。</p><p>针对美国特朗普总统指责中国，“窃取美国知识产权和技术”等，崔大使回应：美国应该意识到，现在世界变化了。很多国家都在发展创新。如果美国觉得技术都是自己一家的，这种态度就是“歧视他国”，是无知的表现。</p><h1 id="美国想干什么"><a href="#美国想干什么" class="headerlink" title="美国想干什么"></a>美国想干什么</h1><p>川普究竟是谈判策略还是真要打一场贸易战？贸易战是个杀敌一千自损八百的手段。</p><ul><li>想捞点钱<br>-</li></ul><p>这次贸易战开打，结果必是中国忍痛让美国剪点羊毛</p><h1 id="中国底气如何"><a href="#中国底气如何" class="headerlink" title="中国底气如何"></a>中国底气如何</h1><ul><li>底气之一，在于中国有巨大的市场</li><li>底气之二，在于中国承受损失的能力更强。<ul><li>屠新泉称，贸易战关键的不是损失，而是承受损失的能力。“中国承受损失的能力强于美国。”</li></ul></li></ul><h1 id="中国能打什么牌"><a href="#中国能打什么牌" class="headerlink" title="中国能打什么牌"></a>中国能打什么牌</h1><h2 id="第一张牌，是限制进口美国商品。"><a href="#第一张牌，是限制进口美国商品。" class="headerlink" title="第一张牌，是限制进口美国商品。"></a>第一张牌，是限制进口美国商品。</h2><ul><li>限制进口美国农产品和高端制成品将是中国的一大“王牌”。</li></ul><p><img alt="中美贸易战-涉及领域" src="/images/raw/Economy - 中美贸易战 - 涉及领域 - 人民日报.jpg"></p><p><a href="http://mp.weixin.qq.com/s?__biz=MjM5MjAxNDM4MA==&amp;mid=2666191303&amp;idx=1&amp;sn=1d14d2f6a518b60f32c0676dd0ac2e40&amp;chksm=bdb2b0848ac53992d44d4dcc6883be7600941f86fd749be9e9239a886c6ddcee2fc79fe8ed30&amp;mpshare=1&amp;scene=23&amp;srcid=0325NfgkESfsUY32TONZMsPV#rd" target="_blank" rel="noopener">完整清单 - 中国拟对这些美国进口产品加征关税</a></p><p>囧，中国并未对美国高端产品加税吧。。。</p><p>中国目前对美国的反击，从比例上看，是选择了一个比较不痛不痒的点，谈不上是正儿八经的回击，更像是一种姿态。</p><h2 id="第二张牌，是削减对美国出口。"><a href="#第二张牌，是削减对美国出口。" class="headerlink" title="第二张牌，是削减对美国出口。"></a>第二张牌，是削减对美国出口。</h2><h1 id="影响"><a href="#影响" class="headerlink" title="影响"></a>影响</h1><p>美国当地时间3月22日，在特朗普宣布对华贸易限制措施之后，资本市场出现恐慌，美国股市暴跌。</p><p>#</p><p>美国之前制裁中兴，理由是中兴向伊朗出售美国技术，双方后来达成和解，但中兴需要支付约 8.9 亿美元的刑事和民事罚金。此次，美方封杀中兴的理由是其没有严格履行和解协议，只解雇了四名高级雇员，未处罚或减少35名员工奖金，这就是所谓的“实锤”。</p><h1 id="网评"><a href="#网评" class="headerlink" title="网评"></a>网评</h1><p>川普贸易战醉翁之意不在酒<br>德媒指出，美国总统特朗普的关税举措首要打击目标并非中国。<br>特朗普需要对中国做出威胁姿态，以不失去自己选民的支持。特朗普迄今宣布的对铝和钢的惩罚性措施的首要打击目标并非中国，而是巴西或日本。</p><h2 id="看不懂系列"><a href="#看不懂系列" class="headerlink" title="看不懂系列"></a>看不懂系列</h2><ul><li>xon：对推动中国进一步开放是有利的，但被某些利益集团绑架的话，会使中国重走日本80年代末的老路……</li><li>xon：此次贸易战的起因是中国不遵循WTO承诺，可以对比一下，如果真正实现WTO承诺，对普通老百姓是不是有利的。未兑现的WTO承诺所保护的车企、银行、石化、医药、通讯、旅游、教育、出版物等等。都是大型国有企业盘踞的、普通老百姓怨声载道的方面。<ul><li>不错，嗟，来食</li><li>说出这种话的人，不是权贵就是奴才…  </li></ul></li><li>xon：如果当年谈判不是授权外让步，就会小概率出现如今的被动；如果当年可以不中断“十五年”的渐进式开放就不会出现如今所担忧的开闸式冲击。<br>换句话说造成如今的局面完全是被某些金字塔顶端的人耽搁了…<ul><li>有些现在才开始开放的领域（需要被保护），其实可以早一些开放？</li><li>xon：1. 有些行业可以不开放，当年入世谈判时并未被授权，当年某位谈判领导会上临时决定的。2、许诺开放的行业里在“十五年”内是在采取渐进式开放的，譬如铁道部转铁路总公司、土地“以租代征”合法化等等都是这一过程的重要节点。但是某大的换届换思路后就嘎然而止了…… 如今的被动不是外界强加给我们的，完全可以说是自己折腾的…</li></ul></li></ul><!--中国不遵循WTO承诺，是不是中国指某些领域不开放？--><h1 id=""><a href="#" class="headerlink" title="#"></a>#</h1><p><a href="https://www.zhihu.com/question/54045798" target="_blank" rel="noopener">| 知乎</a><br><a href="https://www.zhihu.com/question/269539188" target="_blank" rel="noopener">如何看待 2018 年中美贸易战打响？ | 知乎</a></p>]]></content>
      
      <categories>
          
          <category> economy </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Webpack简介</title>
      <link href="/pub/53ff0523/"/>
      <url>/pub/53ff0523/</url>
      <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>Webpack这个工具可以将你的所有代码和可选择地将依赖捆绑成一个单独<br>的 .js 文件。</p><h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 全局安装webpack</span></span><br><span class="line">$ npm install -g webpack</span><br><span class="line"></span><br><span class="line"><span class="comment"># webpack 已经将 webpack 命令行相关的内容都迁移到 webpack-cli，所以除了 webpack 外，我们还需要安装 webpack-cli：</span></span><br><span class="line">$ npm install webpack-cli -D -g</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看版本</span></span><br><span class="line">$ npx webpack --version</span><br></pre></td></tr></table></figure><h1 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h1><p>根目录下新建<code>webpack.config.js</code></p><p>webpack</p><h1 id="打包"><a href="#打包" class="headerlink" title="打包"></a>打包</h1><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sh</span><br></pre></td></tr></table></figure><p> webpack 4 引入的，有俩种模式，development 与 production，默认为 production - 其实还有一个隐藏的 none 模式</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://github.com/chemdemo/chemdemo.github.io/issues/13" target="_blank" rel="noopener">https://github.com/chemdemo/chemdemo.github.io/issues/13</a><br><a href="https://github.com/gwuhaolin/blog/issues/13" target="_blank" rel="noopener">Parcel Vs Webpack</a></p>]]></content>
      
      <categories>
          
          <category> CS </category>
          
          <category> web </category>
          
          <category> front-end </category>
          
          <category> 前端构建工具 </category>
          
          <category> webpack </category>
          
      </categories>
      
      
        <tags>
            
            <tag> webpack </tag>
            
            <tag> 构建工具 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>javascript与typescript的对比</title>
      <link href="/pub/ad7baabf/"/>
      <url>/pub/ad7baabf/</url>
      <content type="html"><![CDATA[<p><a href="https://www.zhihu.com/question/25421196" target="_blank" rel="noopener">https://www.zhihu.com/question/25421196</a></p><p>js做不到的事情指的是</p><p>1：搞面向对象巨方便</p><p>2：可选的强类型可以让你在程序运行之前多发现一些错误</p><p>3：为IDE给javascript弹智能提示打下了良好的基础</p><p>除了语法糖，ts最大的特点应该是静态类型， 包括ts里类的public protected private 也只是做静态类型检查用，</p><p> TypeScript 总体来讲最重要的在于 Scalable.如果只是写个两三千行的脚本 TypeScript 并不是那么重, 但如果是五六千行, 甚至是数万行, TypeScript 的优势就能发挥出来了.<br> 至于 TypeScript 是 Scalable 的原因, 其实也很简单, 静态类型检查, 代码重构和语言服务. 这些都是 JavaScript 的弱势. 项目大了, 很多时候自己的代码怎么用都记不清楚, 当然第三发的类库就不用说了. 用了 TypeScript, 可以看清楚每一个对象的属性, 方法的参数等, 便利很多.</p><p>TypeScript不是 语法上的ECMA6实现，而是以JavaScript为目标语言的，一种编译语言，并且提供向原生JavaScript转换的编译器；而Google的Traceur项目应该才算是ECMA6的语法上实现。</p><p>#</p>]]></content>
      
      <categories>
          
          <category> CS </category>
          
          <category> web </category>
          
          <category> front-end </category>
          
          <category> typescript </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>行政名词 扫盲</title>
      <link href="/pub/5f1b2d12/"/>
      <url>/pub/5f1b2d12/</url>
      <content type="html"><![CDATA[<h2 id="“部”与“委员会”有何区别？"><a href="#“部”与“委员会”有何区别？" class="headerlink" title="“部”与“委员会”有何区别？"></a>“部”与“委员会”有何区别？</h2><p> 简单理解：“部”是一颗颗珍珠，“委”则是串起这些珍珠的链子。前者具有单一职能，重在执行，后者主要在于协调，重在推进。</p><p>比如发改委，几乎涉及了国务院组成部门大部分部级单位的部分权力。</p><h2 id="国务院组成部门、直属机构、办事机构、直属事业单位的区别？"><a href="#国务院组成部门、直属机构、办事机构、直属事业单位的区别？" class="headerlink" title="国务院组成部门、直属机构、办事机构、直属事业单位的区别？"></a>国务院组成部门、直属机构、办事机构、直属事业单位的区别？</h2><p>各级机构中，尤以国务院所属机构的名称特征更加明显，包括国务院组成部门、直属机构、办事机构，都能从名称上识别。</p><ul><li>国务院直属特设机构，只有一个，如国资委。</li><li>国务院直属机构，共16个，如国家税务总局、工商总局、安监总局、统计局、林业局等。有办事机构，共4个，如侨务办、研究室等。</li><li>直属事业单位，共17个，如新华社、中科院、银监委员会、证监委员会、保监委员会等。</li><li>部委管理的局22个，如信访局、粮食局、能源局等，其中个别的叫委，如国家语言文字工作委员会。</li></ul><p>国务院直属机构，不属于国务院级组成部门，其负责人不属于国务院全体会议的组成人员。在国务院直属机构中，没有部的称谓，但有委员会的称谓。直属机构中的正职负责人，有的是正部级，总局的应该都是，局的不是，可能还有就是局级待遇的。事业单位的正职，一般会是正部级。</p><p><a href="https://www.zhihu.com/question/20838877/answer/16352524" target="_blank" rel="noopener">https://www.zhihu.com/question/20838877/answer/16352524</a></p><h2 id="省部级：“部”、“总局”、“总署”-一般都是正部级"><a href="#省部级：“部”、“总局”、“总署”-一般都是正部级" class="headerlink" title="省部级：“部”、“总局”、“总署” 一般都是正部级"></a>省部级：“部”、“总局”、“总署” 一般都是正部级</h2><h2 id="厅局级：司-局-区别"><a href="#厅局级：司-局-区别" class="headerlink" title="厅局级：司 局 区别"></a>厅局级：司 局 区别</h2><p>国务院部门中，为何有的叫“部(委)”，有的叫“总局(局)”？司和局有什么区别？</p><p>在国务院部门中，“司”和“局”虽然行政级别一样，但职能有所区别。</p><p>2012年4月，事业单位改革指导意见正式公布后，不少人发现，像中国气象局、中国证监会这些从名称上看似行政机构，实际也承担行政职能的单位，竟然也被归为事业单位。不过，他们或许能借这次改革，被划入行政序列。</p><p>每个中央机关，都有诸多内设机构，每个部门都有一个办公厅(室)。除此之外，党委部门如中组部、中宣部、统战部的其他内设机构一般都叫“局”。</p><p>国务院下属行政机构的内设机构一般叫“司”，但也还有少量的“局”，如广电总局下设十多个“司”，还有一个电影局，铁道部下设多个司，还有一个运输局。</p><p>在国务院部门中，“司”和“局”虽然在行政级别上是一样的，但在职能上有所区别，文化部一位退休的司级干部用他的自身经历，向南方周末记者说明这个差别。他所在的部门现在叫文化部艺术司，过去叫艺术局。</p><p>在他看来，“司”和“局”在业务上没有太大区别，但在对外协调上有所区别。原来的文化部艺术局，除了下设业务处室之外，还有党委、人事处、计划财务处，统筹文化部在京直属单位如国家京剧院、国家话剧院、国家美术馆等的人、财、物。但变成艺术司之后，就成了一个纯业务部门，对人、财、物的统筹工作，就上交由文化部相关部门负责。</p><p>另外一个变化是，文化部艺术局是可以直接对“外”的，可以直接向各省市的文化厅(局)直接发文。但改成艺术司以后，就不能直接发文了，如需要发文，只能是起草好之后，以文化部或文化部办公厅的名义对外发。</p><h2 id="“国家”、“中国”、“中华”、“中央”，有何差别？"><a href="#“国家”、“中国”、“中华”、“中央”，有何差别？" class="headerlink" title="“国家”、“中国”、“中华”、“中央”，有何差别？"></a>“国家”、“中国”、“中华”、“中央”，有何差别？</h2><p>在日常称呼中，人们一般喜欢将国务院部门简称为“国家××部(委)”，如“国家发改委”、“国家工商总局”。</p><p>但如果你去看机构全称，就会发现，不同部门的准确名称，开头几个字是不同的。有的开头是“中华人民共和国”，如中华人民共和国发展和改革委员会，有的开头却是“中国”，如中国气象局，有的开头又是“国家”，如国家工商行政管理总局。</p><p>这里，都有什么区别和讲究呢？</p><p>“名称的开头”，其实是个外行的说法，规范的说法是“区域名”。在中国，机构名称一般都由三个部分组成，分别是区域名、矢名和格级名。</p><p>以中华人民共和国外交部为例，“中华人民共和国”是它的区域名，表明它的管理范围和隶属关系；“外交”是它的矢名，表明工作内容；“部”是它的格级名，表明了它的级别规格。</p><p>目前国务院部门，分别组成部门、直属机构、办事机构、议事协调机构、事业单位等几类。一般来说，同类机构的区域名、格级名一致，能从名称大体判断的它的机构属性。</p><p>比如，区域名为“中华人民共和国”的，大多都是国务院组成部门，如中华人民共和国教育部、文化部、公安部等。国务院27个组成部门中，只有中国人民银行例外，区域名是“中国”。除了央行和审计署之外，组成部门的格级名都是“部”、“委”。</p><p>而国务院直属机构，区域名大多都是“国家”，如国家广电总局、国家旅游局、国家统计局。国务院15个直属机构中，唯有海关总署的区域名是“中华人民共和国”。这也是唯一一个区域名是“中华人民共和国”，但不是国务院组成部门的机构。国务院直属机构的格级名一般叫“局”、“总局”、“总署”。</p><p>此外，所有部委管理的国家局中，除了2008年机构改革后的中国民航局，其他局的区域名都是“国家”，如国家信访局、国家文物局。</p><p>国务院办事机构的区域名都是“国务院”，如国务院法制办、国务院研究室。</p><p>区域名为“中国”的国务院机构中，除了央行是国务院组成部门，其他都是国务院事业单位，如中国气象局、中国地震局、中国科学院、中国证监会等。事业单位中，还有少数区域名不是“中国”的，如国家电监会、国研中心等。</p><p>国务院系统之外，党委部门区域名一般都是“中央”，人大、政协也有各自的区域名，再有一类就是人民团体，一般而言，区域名为“中华”、“全国”的都是人民团体，如中华全国总工会、中华全国妇女联合会等。</p>]]></content>
      
      <categories>
          
          <category> others </category>
          
          <category> politics </category>
          
          <category> china </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ss </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>【读图识政治】国家机构中的新面孔 - 国家监察委员会</title>
      <link href="/pub/65bf8f/"/>
      <url>/pub/65bf8f/</url>
      <content type="html"><![CDATA[<h1 id="这是标题"><a href="#这是标题" class="headerlink" title="这是标题"></a>这是标题</h1><p><img alt="" src="/images/raw/Politics - 国家监察委员会 - 改革前 - 中纪委监委.jpg"></p><p>afda</p><p><img alt="" src="/images/raw/Politics - 国家监察委员会 - 监察对象 - 中纪委监委.jpg"></p><p>fad</p><p><img alt="" src="/images/raw/Politics - 国家监察委员会 - 改革后1 - 中纪委监委.jpg"></p><p>fad</p><p><img alt="" src="/images/raw/Politics - 国家监察委员会 - 改革后2 - 中纪委监委.jpg"></p><h3 id="监察委干嘛的，跟纪委有关系没？功能冲突不？"><a href="#监察委干嘛的，跟纪委有关系没？功能冲突不？" class="headerlink" title="监察委干嘛的，跟纪委有关系没？功能冲突不？"></a>监察委干嘛的，跟纪委有关系没？功能冲突不？</h3><p>国家监察委员会是中国特色的国家<code>反腐败机构</code>，这个机构将与中国国务院等机构并列为正国级单位。国家监察委员会或将与现在的中纪委<a href="http://www.ccdi.gov.cn/special/zmsjd/zm19da_zm19da/201802/t20180202_163176.html" target="_blank" rel="noopener">合署办公</a>。</p><p><img alt="国家监察委员会--2018" src="/images/raw/Politics - 党和国家机构改革 - 国家监察委员会 - 人民日报.gif"></p><h1 id="扩展阅读"><a href="#扩展阅读" class="headerlink" title="扩展阅读"></a>扩展阅读</h1><p><a href="http://mp.weixin.qq.com/s?__biz=MzAxMDU0MDYwMQ==&amp;mid=2653006611&amp;idx=2&amp;sn=f11b20541a1bbd8f3155d78333df75af&amp;chksm=809bc845b7ec41539652cf59652d954185b9ef35b5656662e6fb39c775cbfb411445935f7a66&amp;mpshare=1&amp;scene=23&amp;srcid=0325dkgloNdzv12aXFjCCuuF#rd" target="_blank" rel="noopener">监察委员会，国家机构中的新面孔｜长漫画 - 中央纪委国家监委网站</a></p>]]></content>
      
      <categories>
          
          <category> others </category>
          
          <category> politics </category>
          
          <category> china </category>
          
          <category> 国家机构 </category>
          
          <category> 国家监察机关 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 宪法 </tag>
            
            <tag> 国家监察委员会 </tag>
            
            <tag> 国家机构改革 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>【读图识政治】图解 党和国家机构改革2018</title>
      <link href="/pub/6637281/"/>
      <url>/pub/6637281/</url>
      <content type="html"><![CDATA[<!--有些知乎内容写明不让转载，可临时在网页看看，后面关掉该页面。--><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>2018年两会刚刚闭幕，中共中央周三（3月21日）公布《深化党和国家机构改革方案》，进一步<code>加强党对政府的领导</code>。</p><p>一、统一职权，消除政出多头</p><p>一位要求匿名的内地政治学者对BBC中文表示：“此次改革强化了党的集中、统一和<code>全面领导</code>，具体部署是从中共执政安全角度考虑，在一些比较重要的、事关执政安全的领域强化了党的领导，如意识形态、社会控制、干部监督管理等。</p><h1 id="机构改革"><a href="#机构改革" class="headerlink" title="机构改革"></a>机构改革</h1><h2 id="国务院"><a href="#国务院" class="headerlink" title="国务院"></a>国务院</h2><p>学者们认为，此次党的机构改革进一步强化了共产党的领导，<strong>削弱了国务院的权力</strong>。</p><p>多个国务院机构被撤销，如监察部、国家预防腐败局、国家公务员局和国务院侨务办公室。许多新组建的委员会和小组将设于国务院部门内，比如中央全面依法治国委员会办公室设在司法部，中央审计委员会办公室设在审计署，中央教育工作领导小组秘书组设在教育部。</p><p>方案称，此次改革，<strong>“着眼于健全加强党的全面领导的制度”</strong>，“确保党的领导全覆盖，确保党的领导更加坚强有力”。</p><p>国务院正部级机构减少8个，副部级机构减少7个，除国务院办公厅外，国务院设置组成部门26个。</p><p>改革后的国务院组成部门为19个，相较过去的25个为少，其中民政部、 教育部、 民族事务委员会、文化部、水利部、农业部、卫生和计划生育部、 科学技术部、国家安全部、监察部、审计署、住房和城乡建设部，都有调整合并，而民政部、国家安全部、审计署等则被取消，相关职能被合并到其他的部委中。</p><h2 id="财政-审计"><a href="#财政-审计" class="headerlink" title="财政 审计"></a>财政 审计</h2><p><img width="50%" alt="审计署" src="/images/raw/Politics - 党和国家机构改革 - 审计署 - 人民日报.gif"></p><h2 id="意识形态领域"><a href="#意识形态领域" class="headerlink" title="意识形态领域"></a>意识形态领域</h2><p><strong>让中宣部统一管理新闻出版和电影</strong>，意味着“今后大陆人能够读什么看什么听什么全部由中宣部来统一口径”；</p><p>国家新闻出版广电总局原本就是国家广电总局和新闻出版署合并组建的，这次改革又恢复了国家广电总局，兜了一大圈又回到原地。而且方案中没有明确新闻出版管理职能归谁，，还有待进一步明确。()</p><p><img width="50%" alt="新闻出版广电总局" src="/images/raw/Politics - 党和国家机构改革 - 新闻出版广电总局 - 人民日报.gif"></p><p><img width="50%" alt="新闻出版广电总局" src="/images/raw/Politics - 党和国家机构改革 - 国家广播电视总局 - 人民日报.gif"></p><p>为何拆分<code>国家新闻出版广电总局</code>？为何把新闻出版可能会划给中宣部？</p><p>中宣部原有职责是？</p><p>中国共产党中央委员会宣传部（通称中共中央宣传部，简称中央宣传部、中宣部），是中共中央直属机构。主要职能是管理中国大陆出版审查体系、中共中央宣传工作以及监管中国大陆媒体和社会舆情舆论工作。<br>中宣部的主要职能是管控意识形态、新闻出版甚至教育方针。</p><blockquote><p>“报刊是党的宣传工具，党的喉舌。”“不许一切反革命分子有言论自由，而只允许人民内部有这种自由……禁止一切反革命分子用言论自由达到他们的反革命目的。”<br>—维基百科<br>wikipedia这样写会不会被查水表。</p></blockquote><p>1998年朱镕基总理视察中央电视台，破例题写16个大字：“舆论监督，群众喉舌，政府镜鉴，改革尖兵。” 短短16个字，尽显真正的共产党、真正的共产党员，为人民服务，坚守人民立场的本色！</p><p>以前记得课本上有这个，现在看来写这几个字很需要勇气啊。<br>一个电视台，本来是中央喉舌，是政府管理下的部门，你让他成为政府镜鉴，这不是本末倒置吗？</p><p>新闻出版广电总局</p><p>中宣部是党机构 - Marx Yong<br>so?听过党政合署的消息吗，知道顺德改革吗？ - 清新脱俗财神爷<br>党政合属但两个牌子 - Marx Yong<br>中宣部是共产党的中央宣传部啊，不是政府机构 - 微小de工作</p><h2 id="社会控制方面"><a href="#社会控制方面" class="headerlink" title="社会控制方面"></a>社会控制方面</h2><p>不再设立中央社会治安综合治理委员会及办公室，职责交由中央政法委承担；</p><h2 id="干部监督方面"><a href="#干部监督方面" class="headerlink" title="干部监督方面"></a>干部监督方面</h2><p>成立国家监察委。中国通过国家监察法 “双规”办案走向合法。<br>国家监察委将与纪委合署办公。由于针对的还是以公权力犯罪为主的案子，检察院的反贪污贿赂、反渎职侵权以及预防职务犯罪三个部门的职能及大部分人员都将被剥离出来，转移至新成立的监察部门。</p><p>去年10月，习近平在中共十九大报告中明确提出，监察人员将用留置取代“两规”措施。留置是指留置在特定场所交代问题。</p><h3 id="“两规”是什么？为何引发争议？"><a href="#“两规”是什么？为何引发争议？" class="headerlink" title="“两规”是什么？为何引发争议？"></a>“两规”是什么？为何引发争议？</h3><p>“两规”又称“双规”，是中共党纪检监察机关查办案件的一种特殊措施，要求有关人员在规定的时间、地点就案件所涉及的问题作出说明。这种措施长期以来一直遭到外界批评。</p><p>中国人民大学法学院教授韩大元曾撰文指出，从监察委的三个试点地区看，监察委员会与纪委虽属于两个机构，但由于主任是纪委书记担任，副主任由副书记兼任，实质上可能导致机构合一，成为党政高度合一的机关。</p><p>姜明安则称，党政合一以后可以提高效率，是国家治理能力的现代化。</p><p>至于监察委权力过大引发的谁来监督监察委的问题，姜明安对此比较乐观，他认为人大、监察委自身、检察院、公安都能从行动上对监察委进行监督。但上述要求匿名的律师认为，在现实中，人大不可能去审查监察委，<strong>“监察委只能靠自我监督”</strong>。</p><p>参考 <a href="http://www.bbc.com/zhongwen/simp/chinese-news-43451802" target="_blank" rel="noopener">http://www.bbc.com/zhongwen/simp/chinese-news-43451802</a></p><h2 id="国家移民管理局"><a href="#国家移民管理局" class="headerlink" title="国家移民管理局"></a>国家移民管理局</h2><p>针对出入境人口越来越多的局面，组建国家移民管理局。将公安部的出入境管理、边防检查职责整合，建立健全签证管理协调机制，组建国家移民管理局，由公安部管理。</p><p><img width="50%" alt="退役军人事务部" src="/images/raw/Politics - 党和国家机构改革 - 国家移民管理局 - 人民日报.gif"></p><h2 id="退役军人事务部"><a href="#退役军人事务部" class="headerlink" title="退役军人事务部"></a>退役军人事务部</h2><p>组建退役部不是为了向美国看齐，这几年来发生了些不让报道的非访事件（大规模），引起了大佬们的重视，原来那么多老士官退役后都得不到合理的安置。 - 赵十六</p><p><img width="50%" alt="退役军人事务部" src="/images/raw/Politics - 党和国家机构改革 - 退役军人事务部 - 人民日报.gif"></p><h2 id="税"><a href="#税" class="headerlink" title="税"></a>税</h2><p>将省级和省级以下国税地税机构合并，具体承担所辖区城内各项税收、非税收入征管等职责。国税地税机构合并后，实行以国家税务总局为主与省（区、市）人民政府双重领导管理体制。这意味着分税制实施二十多年后，又重回了之前国税地部合一的局面，这一改革对地方的深远影响，尚待观察</p><p><img width="50%" alt="退役军人事务部" src="/images/raw/Politics - 党和国家机构改革 - 国税地税征管体制 - 人民日报.gif"></p><h2 id="水利部"><a href="#水利部" class="headerlink" title="水利部"></a>水利部</h2><p>水利部多了三峡工程和南水北调的管理权。</p><p>但三峡和南水北调都修建的差不多了，水利部很多权力都被分配到其他部委了，基本被瓜分</p><h2 id="ss"><a href="#ss" class="headerlink" title="ss"></a>ss</h2><p>当局将国安部、国家保密局、国家密码管理局合并，组建“国家安全保密总局”（加挂中央国家安全保密委牌子）。各省设国安保密局、地市设立分局、县设办事处；各级国安保密部门实行省以下垂直管理，同时接受各级政府协调。换言之，国安部被取消。</p><h2 id="科技部"><a href="#科技部" class="headerlink" title="科技部"></a>科技部</h2><p><img width="50%" alt="退役军人事务部" src="/images/raw/Politics - 党和国家机构改革 - 科技部 - 人民日报.gif"></p><h1 id="哪些部门被加强或削弱了？"><a href="#哪些部门被加强或削弱了？" class="headerlink" title="哪些部门被加强或削弱了？"></a>哪些部门被加强或削弱了？</h1><p>加强：</p><ul><li>审计署，将国家发展和改革委员会的重大项目稽查、财政部的中央预算执行情况和其他财政收支情况的监督检查、国务院国有资产监督管理委员会的国有企业领导干部经济责任审计和国有重点大型企业监事会的职责划入审计署。</li><li>科学技术部，吸收了国家外国专家局的职能</li><li>司法部，吸收了国务院法制办的职能</li></ul><p>削弱</p><ul><li>民政部，民政部的老龄工作、退役军人安置工作、优抚工作、救灾、医疗救助等重要职能均被划出</li><li>国家发改委，组织编制主体功能区规划职责划入自然资源部，应对气候变化和减排职责划入生态环境部，农业投资项目划入农业农村部，重大项目稽查划入审计署，价格监督检查与反垄断执法职责划入市场监管总局，药品和医疗服务价格管理职责划入国家医保局。但这些职责多为国家层面的职能，对地方发改委、发改局的职能，影响不大。</li><li>住房和城乡建设部，划出了城乡规划管理和风景名胜区管理职能</li><li>人力资源和社会保障部划出了城镇职工和城镇居民基本医疗保险、生育保险职责</li><li>商务部划出了经营者集中反垄断执法等职责，且基本上没有新增职责，都可以看成改革中的“输家”。</li><li>发改委没裁，但是被划掉了很多职能，算是不小的削弱</li></ul><h1 id="扩展阅读"><a href="#扩展阅读" class="headerlink" title="扩展阅读"></a>扩展阅读</h1><ul><li><a href="https://zh.wikipedia.org/wiki/%E6%B7%B1%E5%8C%96%E5%85%9A%E5%92%8C%E5%9B%BD%E5%AE%B6%E6%9C%BA%E6%9E%84%E6%94%B9%E9%9D%A9" target="_blank" rel="noopener">深化党和国家机构改革 - 维基百科</a></li><li><a href="http://mp.weixin.qq.com/s?__biz=MjM5MjAxNDM4MA==&amp;mid=2666191144&amp;idx=1&amp;sn=8d6aad2072c8d722af72bdaefcb024ef&amp;chksm=bdb2b06b8ac5397d11e06662b0a4ec88b80b83314ad8c81ae0fc811ada44400c582d4bdd8832&amp;mpshare=1&amp;scene=23&amp;srcid=0325gUxWA4N6S0wPLlu85exN#rd" target="_blank" rel="noopener">深化党和国家机构改革方案动态图 - 人民日报</a></li><li><a href="https://www.zhihu.com/question/20838285" target="_blank" rel="noopener">如何评价2013年国务院机构改革 - 知乎</a></li><li><a href="https://www.zhihu.com/question/268678069/answer/340346697" target="_blank" rel="noopener">如何评价2018《国务院机构改革方案》？ - 知乎</a></li></ul>]]></content>
      
      <categories>
          
          <category> others </category>
          
          <category> politics </category>
          
          <category> china </category>
          
          <category> 国家机构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 国家机构 </tag>
            
            <tag> 国家机构改革 </tag>
            
            <tag> 国务院 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>【读图识政治】图解中国领导团队新阵容 &amp; 主要行政机构 --2018</title>
      <link href="/pub/6de9771b/"/>
      <url>/pub/6de9771b/</url>
      <content type="html"><![CDATA[<h1 id="看图"><a href="#看图" class="headerlink" title="看图"></a>看图</h1><p>今年全国两会适逢换届，至3月19日，国家机构和全国政协新领导层均已产生，中国领导团队的新阵容已组建完毕。</p><p>人民日报客户端根据两会报道和相关公开资料，梳理绘制了一张中国领导团队新阵容思维导图</p><p><img alt="中国领导团队新阵容--2018" src="/images/raw/Politics - 中国领导团队新阵容2018 - 人民日报.jpg"></p><h1 id="职责-分工"><a href="#职责-分工" class="headerlink" title="职责 分工"></a>职责 分工</h1><p>中国领导团队，有<code>三大分支</code>：党、人大、政协。党选举党内领导，人大选举国家领导，政协包括各党派。<br>一般每个分支的大boss都是政治局常委。</p><ul><li>李克强：国务院总理 (中央人民政府)</li><li>栗战书：人大委员长</li><li>汪洋：政协主席</li><li>王沪宁：中央书记处书记，主管意识形态。 上一任刘云山 <!-- 刘云山还兼职中央党校校长 --><br>&lt;!—</li><li>王沪宁毕业后在一直中央政策研究室从事纯理论工作，一干就是二十年，“清水衙门”。</li><li>王沪宁直接参与、起草了江泽民“三个代表”重要思想、胡锦涛“科学发展观”以及习近平“新时代中国特色社会主义思想”等重大政治理论与思想，辅佐了三代总书记，是中共高层的重要理论智囊。</li><li>王沪宁有元老们的认同支持。江曾力挺，胡锦涛也有好感</li><li>栗战书、王沪宁主导了2018宪法修正案。</li><li>他是继邓力群之后，又一位<strong>理论界人士</strong>担任中央书记处书记职务。</li><li>王沪宁代表当前最高意识形态，拥有“习近平思想”解释权。<br>—&gt;</li><li>赵乐际：纪委书记</li><li>韩正：国务院副总理 (原上海市委书记)</li></ul><h2 id="党"><a href="#党" class="headerlink" title="党"></a>党</h2><p>2017年10月25，<a href="https://zh.wikipedia.org/wiki/%E4%B8%AD%E5%9B%BD%E5%85%B1%E4%BA%A7%E5%85%9A%E7%AC%AC%E5%8D%81%E4%B9%9D%E5%B1%8A%E4%B8%AD%E5%A4%AE%E5%A7%94%E5%91%98%E4%BC%9A%E7%AC%AC%E4%B8%80%E6%AC%A1%E5%85%A8%E4%BD%93%E4%BC%9A%E8%AE%AE" target="_blank" rel="noopener">中共19大</a></p><p>选举，党内领导。</p><h2 id="人大"><a href="#人大" class="headerlink" title="人大"></a>人大</h2><p>13届全国人大，选举国家领导。</p><h2 id="政协"><a href="#政协" class="headerlink" title="政协"></a>政协</h2><p>2018年3月14日，第13届全国人民政治协商会议，选举政协领导。</p><h2 id="汇总"><a href="#汇总" class="headerlink" title="汇总"></a>汇总</h2><div class="table-container"><table><thead><tr><th>排名</th><th>肖像姓名</th><th>党职</th><th>公职</th><th>分工</th></tr></thead><tbody><tr><td>1</td><td>习近平</td><td>中共中央总书记中共中央军委主席</td><td>国家主席中央军委主席</td><td>中央国家安全委员会主席中央全面深化改革委员会主任中央全面依法治国委员会主任中央财经委员会主任中央外事工作委员会主任中央对台工作领导小组组长中央网络安全和信息化委员会主任中央军委深化国防和军队改革领导小组组长中央军委联合作战指挥中心总指挥中央军委联合作战指挥中心总指挥中央军民融合发展委员会主任</td></tr><tr><td>2</td><td>李克强</td><td>中共中央政治局常委国务院党组书记</td><td>国务院总理</td><td>中央国家安全委员会副主席中央全面深化改革委员会副主任中央财经委员会副主任中央机构编制委员会主任国家国防动员委员会主任国家能源委员会主任中央网络安全和信息化委员会副主任中央军民融合发展委员会副主任</td></tr><tr><td>3</td><td>栗战书</td><td>中共中央政治局常委全国人大常委会党组书记</td><td>全国人大常委会委员长</td><td>中央国家安全委员会副主席中央港澳工作协调小组组长</td></tr><tr><td>4</td><td>汪　洋</td><td>中共中央政治局常委全国政协党组书记</td><td>全国政协主席</td><td>中央西藏工作协调小组组长中央新疆工作协调小组组长中央对台工作领导小组副组长</td></tr><tr><td>5</td><td>王沪宁</td><td>中共中央政治局常委中央书记处书记中央文明委主任中央政策研究室主任</td><td></td><td>中央全面深化改革委员会副主任中央宣传思想工作领导小组组长中央党的建设工作领导小组组长中央党的群众路线教育实践活动领导小组组长中央机构编制委员会副主任中央网络安全和信息化委员会副主任中央财经委员会成员中央军民融合发展委员会副主任</td></tr><tr><td>6</td><td>赵乐际</td><td>中共中央政治局常委中共中央纪委书记</td><td></td><td>中央党的建设工作领导小组副组长中央巡视工作领导小组组长中央深化国家监察体制改革试点工作领导小组组长</td></tr><tr><td>7</td><td>韩　正</td><td>中共中央政治局常委国务院党组副书记</td><td>国务院副总理</td><td>中央全面深化改革委员会副主任国家能源委员会副主任国务院食品安全委员会主任中央财经委员会成员中央军民融合发展委员会副主任兼办公室主任</td></tr><tr><td></td><td></td><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td><td></td></tr></tbody></table></div><h1 id="变动"><a href="#变动" class="headerlink" title="变动"></a>变动</h1><h2 id="续期七大常委"><a href="#续期七大常委" class="headerlink" title="续期七大常委"></a>续期七大常委</h2><ul><li>习近平</li><li>李克强</li></ul><p>其他5个都是新晋常委</p><h2 id="原常委"><a href="#原常委" class="headerlink" title="原常委"></a>原常委</h2><ul><li>王岐山 -&gt; 副主席 (2017年10月，中共十九大后，王岐山不再担任中央委员会和中纪委领导职务。)<br>王岐山在党内排名第八位，在副总理韩正之后，仅次于七位政治局常委</li></ul><p>对比以下链接 中国官员级别—2013</p><h1 id="疑问"><a href="#疑问" class="headerlink" title="疑问"></a>疑问</h1><p>中央军委是党的会议选举的吧？怎么也挂在人民代表大会下面？</p><h1 id="网评"><a href="#网评" class="headerlink" title="网评"></a>网评</h1><p>五年前，习近平和李克强双接班，人们按照先前的江朱体制和胡温体制的说法，称之为习李体制。但人们很快就发现，没有什么习李体制，李克强这个国务院总理的地位远远比不上先前的朱镕基和温家宝；倒是政治局常委名列第六的王岐山更重要，俨然习王体制。现在，王岐山将出任国家副主席，必将是中共建政以来权力最大的副主席。</p>]]></content>
      
      <categories>
          
          <category> others </category>
          
          <category> politics </category>
          
          <category> china </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 国家领导 </tag>
            
            <tag> 两会 </tag>
            
            <tag> 国家机构 </tag>
            
            <tag> 国家机构改革 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Github Pages示例网站</title>
      <link href="/pub/30663d8e/"/>
      <url>/pub/30663d8e/</url>
      <content type="html"><![CDATA[<p>示例网站</p><h2 id="pytorch"><a href="#pytorch" class="headerlink" title="pytorch"></a>pytorch</h2><p><a href="http://pytorch.org" target="_blank" rel="noopener">http://pytorch.org</a> 搭建在github pages上。对应 pytorch.github.io</p><p><a href="http://pytorch.org/tutorials" target="_blank" rel="noopener">http://pytorch.org/tutorials</a> 站点对应 <a href="https://github.com/pytorch/tutorials" target="_blank" rel="noopener">https://github.com/pytorch/tutorials</a></p><p><a href="https://discuss.pytorch.org/" target="_blank" rel="noopener">https://discuss.pytorch.org/</a> 则需要必须要借助后台服务器，因此是独立的主机域名</p><p>国内测速，，都超时。<br>百度收录2个网页</p><p><a href="http://tool.chinaz.com/dns/" target="_blank" rel="noopener">http://tool.chinaz.com/dns/</a> dns测速，都不通  测速有毛病吧，我手机都能连上</p><h2 id="hexo-io"><a href="#hexo-io" class="headerlink" title="hexo.io"></a>hexo.io</h2><p>hexo.io 采用的美国 CloudFlare公司CDN节点，外加CloudFlare的SSL证书</p><p>百度仅收录了 <a href="https://hexo.io/zh-cn/" target="_blank" rel="noopener">https://hexo.io/zh-cn/</a> 目录。如何做到的</p>]]></content>
      
      <categories>
          
          <category> CS </category>
          
          <category> web </category>
          
          <category> site-dev </category>
          
          <category> host </category>
          
          <category> github-pages </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>为静态网站提供动态服务之 统计模块</title>
      <link href="/pub/995f103a/"/>
      <url>/pub/995f103a/</url>
      <content type="html"><![CDATA[<h1 id="汇总-对比"><a href="#汇总-对比" class="headerlink" title="汇总  对比"></a>汇总  对比</h1><p>site_uv 是指访问的用户个数，一个IP记一次，多次访问不累加<br>site_pv 是网站访问次数，多次访问累加<br>page_pv 是文章点击次数，多次访问累加</p><div class="table-container"><table><thead><tr><th></th><th>google统计</th><th>百度统计</th><th>Leancloud.cn</th><th>不蒜子</th><th></th><th></th><th></th></tr></thead><tbody><tr><td>特点</td><td></td><td></td><td>功能繁杂</td><td>轻量级，无需注册，两行代码</td><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td><td>要注册</td><td></td><td></td><td></td><td></td></tr><tr><td>功能</td><td></td><td></td><td></td><td>pv uv</td><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr></tbody></table></div><h2 id="速度-对比"><a href="#速度-对比" class="headerlink" title="速度 对比"></a>速度 对比</h2><p>不蒜子的js放在七牛，速度应该不慢，如果说速度慢，可能是七牛的原因，</p><h2 id="初始化首次数据"><a href="#初始化首次数据" class="headerlink" title="初始化首次数据"></a>初始化首次数据</h2><p>初始化首次数据无非就两种方式</p><ol><li>修改服务器的数据库数据 (多数不提供该服务，因为随意篡改数据就失去了数据权威性)</li><li>仅更改本网站的显示 (so easy，也可以理解成自己欺骗自己)</li></ol><p>首先看方式二：以不蒜子为例</p><p>在html中引入以下js<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 修正不蒜子计数初始值 --&gt;</span><br><span class="line">    &lt;script &gt;</span><br><span class="line">        $(<span class="built_in">document</span>).ready(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">var</span> int = setInterval(fixCount, <span class="number">50</span>);  <span class="comment">// 50ms周期检测函数</span></span><br><span class="line">            <span class="keyword">var</span> countOffset = <span class="number">20000</span>;  <span class="comment">// 初始化首次数据</span></span><br><span class="line">           <span class="function"><span class="keyword">function</span> <span class="title">fixCount</span>(<span class="params"></span>) </span>&#123;                   </span><br><span class="line">             <span class="keyword">if</span> ($(<span class="string">"#busuanzi_container_site_pv"</span>).css(<span class="string">"display"</span>) != <span class="string">"none"</span>)</span><br><span class="line">               &#123;</span><br><span class="line">                  $(<span class="string">"#busuanzi_value_site_pv"</span>).html(<span class="built_in">parseInt</span>($(<span class="string">"#busuanzi_value_site_pv"</span>).html()) + countOffset); <span class="comment">// 加上初始数据</span></span><br><span class="line">                  clearInterval(int); <span class="comment">// 停止检测</span></span><br><span class="line">             &#125;  </span><br><span class="line">         &#125;           </span><br><span class="line">        &#125;);</span><br><span class="line">    &lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure></p><p>这里的方法是改给自己看，并未改动busuanzi的数据库。</p><p>方式一，看各家提供的接口咯</p><h3 id="不蒜子的方式"><a href="#不蒜子的方式" class="headerlink" title="不蒜子的方式"></a>不蒜子的方式</h3><blockquote><p>“不蒜子”与百度统计谷歌分析等有区别：“不蒜子”可直接将访问次数显示在您在网页上（也可不显示）；对于已经上线一段时间的网站，“不蒜子”允许您初始化首次数据。<br>请先注册登录，自行修改阅读次数。<br>—- 来自不蒜子官网</p></blockquote><p>然而，至今不蒜子尚未提供注册服务(2018年3月)，也就是不蒜子暂时也不提供 <code>修改统计数据的接口</code>。</p><p>实际上并未改初始化首次数据的方式。因为</p><h1 id="单独介绍"><a href="#单独介绍" class="headerlink" title="单独介绍"></a>单独介绍</h1><h2 id="不蒜子"><a href="#不蒜子" class="headerlink" title="不蒜子"></a>不蒜子</h2><p>“不蒜子”是通过页面url（或者主机名神马的）来标识一个计数值，而像localhost、index.html这样的名字早已经被像我们一样的广大程序猿在测试时用烂了，自然就累计了好多次</p>]]></content>
      
      <categories>
          
          <category> CS </category>
          
          <category> web </category>
          
          <category> site-dev </category>
          
          <category> plugin-for-static-site </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 静态网站 </tag>
            
            <tag> 插件 </tag>
            
            <tag> 动态服务 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>javascript的正则表达式</title>
      <link href="/pub/5e28078b/"/>
      <url>/pub/5e28078b/</url>
      <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><h2 id="匹配到的字符串"><a href="#匹配到的字符串" class="headerlink" title="匹配到的字符串"></a>匹配到的字符串</h2><div class="table-container"><table><thead><tr><th>字符</th><th>替换文本</th></tr></thead><tbody><tr><td>$&amp;</td><td>与正则相匹配的字符串</td></tr><tr><td>$`</td><td>匹配字符串左边的字符</td></tr><tr><td>$’</td><td>匹配字符串右边的字符</td></tr><tr><td>$1,$2,$3,…,$n</td><td>匹配结果中对应的分组匹配结果</td></tr></tbody></table></div><h2 id="回调函数"><a href="#回调函数" class="headerlink" title="回调函数"></a>回调函数</h2><h2 id="匹配的正则表达式"><a href="#匹配的正则表达式" class="headerlink" title="匹配的正则表达式"></a>匹配的正则表达式</h2><div class="table-container"><table><thead><tr><th>字符</th><th>含义</th></tr></thead><tbody><tr><td>\</td><td>匹配将依照下列规则：在非特殊字符之前的反斜杠表示下一个字符是特殊的，不能从字面上解释。例如，没有前面’\’的’b’通常匹配小写’b’，无论它们出现在哪里。如果加了’\’,这个字符变成了一个特殊意义的字符，意思是匹配一个字符边界。反斜杠也可以将其后的特殊字符，转义为字面量。例如，模式 /a<em>/ 代表会匹配 0 个或者多个 a。相反，模式 /a\</em>/ 将 ‘<em>‘ 的特殊性移除，从而可以匹配像 “a</em>“ 这样的字符串。使用 new RegExp(“pattern”) 的时候不要忘记将 \ 进行转义，因为 \ 在字符串里面也是一个转义字符。</td></tr><tr><td>^</td><td>匹配输入的开始。如果多行标志被设置为true，那么也匹配换行符后紧跟的位置。例如，/^A/ 并不会匹配 “an A” 中的 ‘A’，但是会匹配 “An E” 中的 ‘A’。当 ‘^’ 作为第一个字符出现在一个字符集合模式时，它将会有不同的含义。补充字符集合 一节有详细介绍和示例。</td></tr><tr><td>$</td><td>匹配输入的结束。如果多行标示被设置为true，那么也匹配换行符前的位置。例如，/t$/ 并不会匹配 “eater” 中的 ‘t’，但是会匹配 “eat” 中的 ‘t’。</td></tr><tr><td>*</td><td>匹配前一个表达式0次或多次。等价于 {0,}。例如，/bo*/会匹配 “A ghost boooooed” 中的 ‘booooo’ 和 “A bird warbled” 中的 ‘b’，但是在 “A goat grunted” 中将不会匹配任何东西。</td></tr><tr><td>+</td><td>匹配前面一个表达式1次或者多次。等价于 {1,}。例如，/a+/匹配了在 “candy” 中的 ‘a’，和在 “caaaaaaandy” 中所有的 ‘a’。</td></tr><tr><td>?</td><td>匹配前面一个表达式0次或者1次。等价于 {0,1}。例如，/e?le?/ 匹配 “angel” 中的 ‘el’，和 “angle” 中的 ‘le’ 以及”oslo’ 中的’l’。如果紧跟在任何量词 *、 +、? 或 {} 的后面，将会使量词变为非贪婪的（匹配尽量少的字符），和缺省使用的贪婪模式（匹配尽可能多的字符）正好相反。例如，对 “123abc” 应用 /\d+/ 将会返回 “123”，如果使用 /\d+?/,那么就只会匹配到 “1”。还可以运用于先行断言，如本表的 x(?=y) 和 x(?!y) 条目中所述。</td></tr><tr><td>.</td><td>（小数点）匹配除换行符之外的任何单个字符。例如，/.n/将会匹配 “nay, an apple is on the tree” 中的 ‘an’ 和 ‘on’，但是不会匹配 ‘nay’。</td></tr><tr><td>(x)</td><td>匹配 ‘x’ 并且记住匹配项，就像下面的例子展示的那样。括号被称为 捕获括号。模式/(foo) (bar) \1 \2/中的 ‘(foo)’ 和 ‘(bar)’ 匹配并记住字符串 “foo bar foo bar” 中前两个单词。模式中的 \1 和 \2 匹配字符串的后两个单词。注意 \1、\2、\n 是用在正则表达式的匹配环节。在正则表达式的替换环节，则要使用像 $1、$2、$n 这样的语法，例如，’bar foo’.replace( /(…) (…)/, ‘$2 $1’ )。</td></tr><tr><td>(?:x)</td><td>匹配 ‘x’ 但是不记住匹配项。这种叫作非捕获括号，使得你能够定义为与正则表达式运算符一起使用的子表达式。来看示例表达式 /(?:foo){1,2}/。如果表达式是 /foo{1,2}/，{1,2}将只对 ‘foo’ 的最后一个字符 ’o‘ 生效。如果使用非捕获括号，则{1,2}会匹配整个 ‘foo’ 单词。</td></tr><tr><td>x(?=y)</td><td>匹配’x’仅仅当’x’后面跟着’y’.这种叫做正向肯定查找。例如，/Jack(?=Sprat)/会匹配到’Jack’仅仅当它后面跟着’Sprat’。/Jack(?=Sprat\</td><td>Frost)/匹配‘Jack’仅仅当它后面跟着’Sprat’或者是‘Frost’。但是‘Sprat’和‘Frost’都不是匹配结果的一部分。</td></tr><tr><td>x(?!y)</td><td>匹配’x’仅仅当’x’后面不跟着’y’,这个叫做正向否定查找。例如，/\d+(?!.)/匹配一个数字仅仅当这个数字后面没有跟小数点的时候。正则表达式/\d+(?!.)/.exec(“3.141”)匹配‘141’但是不是‘3.141’</td></tr><tr><td>x</td><td>y    \</td><td>匹配‘x’或者‘y’。例如，/green\</td><td>red/匹配“green apple”中的‘green’和“red apple”中的‘red’</td></tr><tr><td>{n}</td><td>n是一个正整数，匹配了前面一个字符刚好发生了n次。比如，/a{2}/不会匹配“candy”中的’a’,但是会匹配“caandy”中所有的a，以及“caaandy”中的前两个’a’。</td></tr><tr><td>{n,m}</td><td>n 和 m 都是整数。匹配前面的字符至少n次，最多m次。如果 n 或者 m 的值是0， 这个值被忽略。例如，/a{1, 3}/ 并不匹配“cndy”中的任意字符，匹配“candy”中得a，匹配“caandy”中的前两个a，也匹配“caaaaaaandy”中的前三个a。注意，当匹配”caaaaaaandy“时，匹配的值是“aaa”，即使原始的字符串中有更多的a。</td></tr><tr><td>[xyz]</td><td>一个字符集合。匹配方括号的中任意字符，包括转义序列。你可以使用破折号（-）来指定一个字符范围。对于点（.）和星号（*）这样的特殊符号在一个字符集中没有特殊的意义。他们不必进行转义，不过转义也是起作用的。例如，[abcd] 和[a-d]是一样的。他们都匹配”brisket”中得‘b’,也都匹配“city”中的‘c’。/[a-z.]+/ 和/[\w.]+/都匹配“test.i.ng”中得所有字符。</td></tr><tr><td><sup><a href="#fn_xyz" id="reffn_xyz">xyz</a></sup></td><td>一个反向字符集。也就是说， 它匹配任何没有包含在方括号中的字符。你可以使用破折号（-）来指定一个字符范围。任何普通字符在这里都是起作用的。例如，<sup><a href="#fn_abc" id="reffn_abc">abc</a></sup> 和 <sup><a href="#fn_a-c" id="reffn_a-c">a-c</a></sup> 是一样的。他们匹配”brisket”中得‘r’，也匹配“chop”中的‘h’。</td></tr><tr><td>[\b]</td><td>匹配一个退格(U+0008)。（不要和\b混淆了。）</td></tr><tr><td>\b</td><td>匹配一个词的边界。一个词的边界就是一个词不被另外一个词跟随的位置或者不是另一个词汇字符前边的位置。注意，一个匹配的词的边界并不包含在匹配的内容中。换句话说，一个匹配的词的边界的内容的长度是0。（不要和[\b]混淆了）例子：/\bm/匹配“moon”中得‘m’；/oo\b/并不匹配”moon”中得’oo’，因为’oo’被一个词汇字符’n’紧跟着。/oon\b/匹配”moon”中得’oon’，因为’oon’是这个字符串的结束部分。这样他没有被一个词汇字符紧跟着。/\w\b\w/将不能匹配任何字符串，因为一个单词中的字符永远也不可能被一个非词汇字符和一个词汇字符同时紧跟着。注意: JavaScript的正则表达式引擎将特定的字符集定义为“字”字符。不在该集合中的任何字符都被认为是一个断词。这组字符相当有限：它只包括大写和小写的罗马字母，小数位数和下划线字符。不幸的是，重要的字符，例如“é”或“ü”，被视为断词。</td></tr><tr><td>\B</td><td>匹配一个非单词边界。他匹配一个前后字符都是相同类型的位置：都是单词或者都不是单词。一个字符串的开始和结尾都被认为是非单词。例如，/\B../匹配”noonday”中得’oo’, 而/y\B./匹配”possibly yesterday”中得’ye‘</td></tr><tr><td>\cX</td><td>当X是处于A到Z之间的字符的时候，匹配字符串中的一个控制符。例如，/\cM/ 匹配字符串中的 control-M (U+000D)。</td></tr><tr><td>\d</td><td>匹配一个数字。等价于[0-9]。例如， /\d/ 或者 /[0-9]/ 匹配”B2 is the suite number.”中的’2’。</td></tr><tr><td>\D</td><td>匹配一个非数字字符。等价于<sup><a href="#fn_0-9" id="reffn_0-9">0-9</a></sup>。例如， /\D/ 或者 /<sup><a href="#fn_0-9" id="reffn_0-9">0-9</a></sup>/ 匹配”B2 is the suite number.”中的’B’ 。</td></tr><tr><td>\f</td><td>匹配一个换页符 (U+000C)。</td></tr><tr><td>\n</td><td>匹配一个换行符 (U+000A)。</td></tr><tr><td>\r</td><td>匹配一个回车符 (U+000D)。</td></tr><tr><td>\s</td><td>匹配一个空白字符，包括空格、制表符、换页符和换行符。等价于[ \f\n\r\t\v\u00a0\u1680\u180e\u2000-\u200a\u2028\u2029\u202f\u205f\u3000\ufeff]。例如, /\s\w*/ 匹配”foo bar.”中的’ bar’。</td></tr><tr><td>\S</td><td>匹配一个非空白字符。等价于<sup><a href="#fn_ \f\n\r\t\v\u00a0\u1680\u180e\u2000-\u200a\u2028\u2029\u202f\u205f\u3000\ufeff" id="reffn_ \f\n\r\t\v\u00a0\u1680\u180e\u2000-\u200a\u2028\u2029\u202f\u205f\u3000\ufeff"> \f\n\r\t\v\u00a0\u1680\u180e\u2000-\u200a\u2028\u2029\u202f\u205f\u3000\ufeff</a></sup>。例如， /\S\w*/ 匹配”foo bar.”中的’foo’。</td></tr><tr><td>\t</td><td>匹配一个水平制表符 (U+0009)。</td></tr><tr><td>\v</td><td>匹配一个垂直制表符 (U+000B)。</td></tr><tr><td>\w</td><td>匹配一个单字字符（字母、数字或者下划线）。等价于[A-Za-z0-9_]。例如, /\w/ 匹配 “apple,” 中的 ‘a’，”$5.28,”中的 ‘5’ 和 “3D.” 中的 ‘3’。</td></tr><tr><td>\W</td><td>匹配一个非单字字符。等价于<sup><a href="#fn_A-Za-z0-9_" id="reffn_A-Za-z0-9_">A-Za-z0-9_</a></sup>。例如, /\W/ 或者 /<sup><a href="#fn_A-Za-z0-9_" id="reffn_A-Za-z0-9_">A-Za-z0-9_</a></sup>/ 匹配 “50%.” 中的 ‘%’。</td></tr><tr><td>\n</td><td>当 n 是一个正整数，一个返回引用到最后一个与有n插入的正则表达式(counting left parentheses)匹配的副字符串。比如 /apple(,)\sorange\1/ 匹配”apple, orange, cherry, peach.”中的’apple, orange,’ 。</td></tr><tr><td>\0</td><td>匹配 NULL (U+0000) 字符， 不要在这后面跟其它小数，因为 \0<digits> 是一个八进制转义序列。</digits></td></tr><tr><td>\xhh</td><td>与代码 hh 匹配字符（两个十六进制数字）</td></tr><tr><td>\uhhhh</td><td>与代码 hhhh 匹配字符（四个十六进制数字）。</td></tr></tbody></table></div><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li><a href="https://github.com/dunizb/JS-Regular-expression-awesome" target="_blank" rel="noopener">常用的JS正则表达式 | Github</a></li></ul>]]></content>
      
      <categories>
          
          <category> CS </category>
          
          <category> web </category>
          
          <category> front-end </category>
          
          <category> js </category>
          
      </categories>
      
      
        <tags>
            
            <tag> javascript </tag>
            
            <tag> 正则表达式 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>利用travis自动构建Gitbook静态页面，并自动部署到Github Page</title>
      <link href="/pub/a8e526f0/"/>
      <url>/pub/a8e526f0/</url>
      <content type="html"><![CDATA[<h1 id="目的"><a href="#目的" class="headerlink" title="目的"></a>目的</h1><p>实现 Gitbook - Github仓库 - Github Pages 三方同步。</p><ul><li>修改Gitbook，实现 Github自动同步 + 自动部署静态页面到Github Pages</li><li>修改Github仓库，实现Gitbook自动同步 + 自动部署静态页面到Github Pages</li></ul><p>Gitbook自身已经实现了与Github仓库的同步，现在的问题是，如何实现自动部署静态页面到Github Pages。</p><p>当然有很多实现方式，这里我们介绍利用Travis CI自动部署Github Pages。</p><h1 id="Travis-CI"><a href="#Travis-CI" class="headerlink" title="Travis CI"></a>Travis CI</h1><p>Travis CI原理就是当你每次提交commit到在github后，它会自动检测你的提交，同时根据的配置文件，生成一个Linux虚拟机来运行你的命令，通常这些命令用于测试，构建等。在我们的要求下，就可以用它运行一些hexo g d之类的命令来自动生成、部署我静态网页。</p><ol><li>博客提交修改后push到github</li><li>github通知travis ci项目需要构建<ul><li>这里需要配置：</li></ul></li><li>travis ci立马安排构建<ul><li>这里需要.travis.yml</li></ul></li><li>构建完成后将结果push到github的gh-pages分支<ul><li>这里需要github访问权限。即personal access token</li><li>把token设置到.travis.yml环境变量中，安全起见，最好加密</li><li><a href="https://docs.travis-ci.com/user/environment-variables" target="_blank" rel="noopener">travis环境变量的定义与加密</a></li></ul></li><li>vps利用git钩子将结果部署到web容器</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ npm install travis-encrypt -g</span><br><span class="line">$ travis-encrypt -r username/repository GH_TOKEN=[the token you created before] -a</span><br><span class="line">$ travis-encrypt -r ESbook/TCP-IP GH_TOKEN=6ad73f4597162bf335caaeef3e1138b77645dd5c -a</span><br><span class="line"># GH_TOKEN</span><br><span class="line">XpJ36JE64TJCwGQ5ZxxWosn64Rhwq3OGOqNJhjKUyeGPlj9B+fNPAqBmP+YTLxB5nRpoLv5UsK62Qw15Of02iZcoO50H8qBrb2cWNEW3z2+Ih12JoeN5qJi4MTShT6ePbwH7Tvid27wosswuYH2+O4hvSQR13WwsHqCPDmzno6Zni+Unt8tya0etSkRqS81hKbHTItL0fOQiDpVIK2GrUioqPAbDV2TNBZfas8EENmSfZMRjHV6BYaOY/ZQg8qx3UuPSnGLU6pmiv9pcaiths4LNBoHb71+Rm87E+FffI6sHtmqrKn9NoW5sEsiiIAUusYQE5woQsn46+uc8lgjlx+1DGBxPstQwvTQNcu8HWzoN0lxlnIYMTWTj/aoUBmc90/Do1GPlpSP9/vONrU2ljfyfKlxxwbUdvHg8pvfU09QsWtTRAqfSjrH305nHOCPKWQgeYv0zbgTqRq/zKh5xTS+iaU6R+VscxFTCnktQaCG1oB6VMSBsU6YjvG5KcY7UZHiyF/fPTRFIH/LtT6iX9DpGlvc3NBb/mA4ERcEvMp/1Bgs7rqHVML+luhwKBwqeivilz0VRajK5JQxBmMeuJ4cDVt/yJuwGjf72chKa8Y909/iwAKm5wJ/FAEKvv7wl1aZJyOFdWEW6n/6u63+6VQy1YF/6aSodbkQcvO/o8qw=</span><br><span class="line">$ git remote add origin &apos;https://f6884617cab7ada45740e5034604e3e82e4ac722@github.com/ESbook/TCP-IP.git&apos;</span><br></pre></td></tr></table></figure><ul><li>博客：<a href="http://blog.csdn.net/qq8427003/article/details/64921201" target="_blank" rel="noopener">http://blog.csdn.net/qq8427003/article/details/64921201</a></li><li>应用实例 <a href="https://github.com/8427003/book/blob/master/deploy-to-github.sh" target="_blank" rel="noopener">https://github.com/8427003/book/blob/master/deploy-to-github.sh</a></li><li>实例&amp;博客：<a href="https://github.com/steveklabnik/automatically_update_github_pages_with_travis_example" target="_blank" rel="noopener">https://github.com/steveklabnik/automatically_update_github_pages_with_travis_example</a></li><li>博客：<a href="https://shawnho.me/2017/11/23/deploy-hexo-blog-with-travis-ci/" target="_blank" rel="noopener">https://shawnho.me/2017/11/23/deploy-hexo-blog-with-travis-ci/</a></li></ul><h1 id="疑问"><a href="#疑问" class="headerlink" title="疑问"></a>疑问</h1><h2 id="为什么要采用personal-access-token？为什么不采用ssh验证？"><a href="#为什么要采用personal-access-token？为什么不采用ssh验证？" class="headerlink" title="为什么要采用personal access token？为什么不采用ssh验证？"></a>为什么要采用personal access token？为什么不采用ssh验证？</h2><p>HTTPS URLs和SSH URLs对应的是两套完全独立的权限校验方式，主要的区别就是HTTPS URLs采用账号密码进行校验，SSH URLs采用SSH秘钥对进行校验。</p><p>采用personal access token的方式来访问gitub，目的是代替密码输入。</p><p>如果要采用ssh，需要把travis主机的ssh key加入到github中。这样确实能够方便部署，免密码验证，但是存在风险。因为travis主机是很多人共用的，同一个主机加很多github的ssh会存在多账户权限风险。（我猜的）。即使每个github账号对应一个虚机或者docker，不方便多主机CDN。</p><h2 id="为什么要travis-encrypt？"><a href="#为什么要travis-encrypt？" class="headerlink" title="为什么要travis encrypt？"></a>为什么要travis encrypt？</h2><p>因为公开personal access token，就基本等同于公开github密码。任何人可以通过用户名+token获得github的相应权限，github中的项目有被恶意篡改，删除的风险。</p><p>travis encrypt对token进行加密，该密文仅travis能够识别。</p><h1 id=""><a href="#" class="headerlink" title="#"></a>#</h1>]]></content>
      
      <categories>
          
          <category> CS </category>
          
          <category> tools </category>
          
          <category> CI-持续集成 </category>
          
          <category> Travis CI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> travis </tag>
            
            <tag> gitbook </tag>
            
            <tag> 自动化部署 </tag>
            
            <tag> 持续集成 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>开源密码管理工具对比</title>
      <link href="/pub/74ac13e4/"/>
      <url>/pub/74ac13e4/</url>
      <content type="html"><![CDATA[<div class="table-container"><table><thead><tr><th></th><th>KeepPass</th><th>KeepPassX</th><th>LessPass</th><th>clipperz</th><th>Encryptr</th><th>备注</th></tr></thead><tbody><tr><td>简介</td><td></td><td>keepass的山寨版，很弱</td><td></td><td></td><td></td><td></td></tr><tr><td>github-fork</td><td>代码由sourceforget-svn托管。老顽固拒绝github</td><td>535</td><td>106</td><td>121</td><td>121</td><td>submoduel的contributor是否算在主仓库中？</td></tr><tr><td>github-star</td><td></td><td>3613</td><td>2618</td><td>569</td><td>1480</td><td></td></tr><tr><td>github-contributor</td><td></td><td>29</td><td>10</td><td>9</td><td>7</td><td></td></tr><tr><td>github近期更新</td><td>☆</td><td>☆☆</td><td>☆☆☆</td><td>☆☆</td><td>☆☆</td><td></td></tr><tr><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>主仓库</td><td></td><td>主仓库即所有代码，C++ Qt客户端</td><td>shell</td><td></td><td></td><td></td></tr><tr><td>backend</td><td></td><td></td><td>python-django</td><td></td><td></td><td></td></tr><tr><td>frontend</td><td></td><td></td><td>vuejs + html</td><td></td><td></td><td></td></tr><tr><td>cli</td><td></td><td></td><td>nodejs</td><td></td><td></td><td></td></tr><tr><td>desktop</td><td></td><td></td><td>node + js 编译成windos、linux、max客户端</td><td></td><td></td><td></td></tr><tr><td>webextension</td><td></td><td>无</td><td></td><td></td><td></td><td></td></tr><tr><td>移动客户端</td><td></td><td>由第三方提供，并非开源。种类繁多，良莠不齐</td><td></td><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>同步</td><td></td><td>借助dropbox等第三方</td><td></td><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>主推功能</td><td></td><td></td><td>synchronize，多设备同步</td><td></td><td></td><td></td></tr><tr><td>模块化/组件化</td><td>也有很多plugin</td><td></td><td>基于nodejs，模块化很好</td><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>优点</td><td>比keepassx好用</td><td></td><td>1. C++看着吃力，python看着爽，nodejs也比较火 2. 多设备同步很重要3. 模块化很赞</td><td></td><td></td></tr></tbody></table></div><p>老顽固拒绝github<br><a href="https://sourceforge.net/p/keepass/discussion/329221/thread/97110c29/" target="_blank" rel="noopener">https://sourceforge.net/p/keepass/discussion/329221/thread/97110c29/</a></p><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p> LastPass（最大的优势是跨浏览器平台</p>]]></content>
      
      <categories>
          
          <category> CS </category>
          
          <category> tools </category>
          
          <category> 密码管理 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>【读图识政治】图解中国官员级别--2013</title>
      <link href="/pub/88222587/"/>
      <url>/pub/88222587/</url>
      <content type="html"><![CDATA[<p><a href="http://cnpolitics.org/2013/03/chinese-officials/" target="_blank" rel="noopener">图来自政见网</a><br>貌似被墙了</p><p><img src="/images/raw/Politics - ChineseOfficials2013 - cnpolitics.jpg"></p><p>2005年4月27日通过的《公务员法》第十六条规定：</p><ul><li>公务员职务分为<strong>领导职务</strong>和<strong>非领导职务</strong>。</li><li>领导职务层次分为：国家级正职、国家级副职、省部级正职、省部级副职、厅局级正职、厅局级副职、县处级正职、县处级副职、乡科级正职、乡科级副职。</li></ul><h2 id="国家副主席是国家级正职吧？"><a href="#国家副主席是国家级正职吧？" class="headerlink" title="国家副主席是国家级正职吧？"></a>国家副主席是国家级正职吧？</h2><p>No</p><p>2013年，中共十二届全国人大第一次会议上，李源潮顺利“当选”国家副主席，这使得李源潮成为中国政府约20年来首位非政治局常委的国家副主席，前一“非常”副主席是王震。令人们十分好奇的内容之一是，他在随后的5年时间里，更准确地说是他在2017年秋季召开中共十九大之前的这段时间里，到底会享受和7名政治局常委一样的“正国级”待遇，还是继续享受十八届中央领导集体内和他党内身份相同的其他政治局委员们共同享受的“副国级”待遇。</p><p>中共此前有明文规定，以下职位：中共中央总书记、中央政治局常委、国家主席、国务院总理、全国人大常委会委员长、全国政协主席、中央军委主席、国家副主席为正国家级别。因此，有观点认为，延续原来的惯例，现在在职的正国家领导有八位，<strong>7大常委</strong> 和国家副主席李源潮。</p><p>但也有观点认为，中国的国家主席一般是中央总书记，行政级别是是国家级，在这届李源潮之前近20年间，国家副主席均是政治局常委，属于党和国家领导人，其行政级别是国家级，但从今年开始，国家副主席不是政治局常委，而是政治局委员，因此，他的行政级别是副国级。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="http://m.creaders.net/china/2015/01/20/1480359.html" target="_blank" rel="noopener">参考</a></p><p>  “高级检察院” “中级检察院” 笑尿了</p>]]></content>
      
      <categories>
          
          <category> others </category>
          
          <category> politics </category>
          
          <category> china </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 官员级别 </tag>
            
            <tag> 国家领导 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Gitbook自动化部署到Github Pages的方案汇总</title>
      <link href="/pub/941b4609/"/>
      <url>/pub/941b4609/</url>
      <content type="html"><![CDATA[<h2 id="采用shell命令"><a href="#采用shell命令" class="headerlink" title="采用shell命令"></a>采用shell命令</h2><ul><li>参考一：<br><a href="http://sangsoonam.github.io/2016/08/02/publish-gitbook-to-your-github-pages.html" target="_blank" rel="noopener">http://sangsoonam.github.io/2016/08/02/publish-gitbook-to-your-github-pages.html</a></li><li>参考二：<a href="https://tonydeng.github.io/gitbook-zh/gitbook-howtouse/publish/gitpages.html" target="_blank" rel="noopener">https://tonydeng.github.io/gitbook-zh/gitbook-howtouse/publish/gitpages.html</a></li><li>参考三：<a href="http://yangjh.oschina.io/gitbook/UsingPages.html" target="_blank" rel="noopener">http://yangjh.oschina.io/gitbook/UsingPages.html</a></li></ul><h2 id="封装成node-module"><a href="#封装成node-module" class="headerlink" title="封装成node module"></a>封装成node module</h2><p>借鉴 hexo deploy命令</p><h2 id="采用web-hook"><a href="#采用web-hook" class="headerlink" title="采用web hook"></a>采用web hook</h2><p>这是 Github 提供的一种机制，使应用能与 Github 通讯。这种机制实际上就是 Pub/Sub，当 Github 监测到资源（如仓库）有变化就往预先设定的 URL 发送一个 POST 请求（Pub），告知变化情况，而后接收变化的服务器（Sub）即可做一些额外的事情。</p><p>这个思路需要有一个服务器并启动一个服务来接收 Github 的请求。这里又有种不同的策略，这两种策略都是基于源码放置在 Github 的前提。第一个是源码将最终文档直接部署在这台服务器上（如使用 Nginx），当接收到 Github 通知直接编译更新到服务器指定的文件夹下即可。另一种策略是当服务器接收到通知后编译更新，而后将编译后的版本提交到 Github 仓库的 gh-pages 分支，让 Github 做 Host。</p><h2 id="采用git-hook"><a href="#采用git-hook" class="headerlink" title="采用git hook"></a>采用git hook</h2><p>貌似必须要自己搭建git server。</p><h2 id="CI工具"><a href="#CI工具" class="headerlink" title="CI工具"></a>CI工具</h2><p>持续集成（英语：Continuous integration，缩写CI）是一种软件工程流程，是将所有软件工程师对于软件的工作副本持续集成到共用主线（mainline）的一种举措。<br>持续集成的提出主要是为解决软件进行系统集成时面临的各项问题，极限编程称这些问题为集成地狱（integration hell）。</p><p>常用工具 travis-ci  Jenkins</p><p>Jenkins是一个持续集成工具，相当于一个构建调度平台，围绕着scm，ssh, ant,maven插件，进行构建操作。<br>理论上来讲，有合适的插件，大部分自动化行为都可以在jenkins平台上展开。<br>使用Jenkins 来触发和调度，在Jenkins构建执行shell脚本来进行分发和安装，测试，可以部署成流水线的方式，依次运行</p><p>已实现</p>]]></content>
      
      <categories>
          
          <category> CS </category>
          
          <category> tools </category>
          
          <category> formatting </category>
          
          <category> gitbook </category>
          
      </categories>
      
      
        <tags>
            
            <tag> gitbook </tag>
            
            <tag> 自动化部署 </tag>
            
            <tag> 持续集成 </tag>
            
            <tag> travis-ci </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>OCR引擎-Tesseract-OCR简介</title>
      <link href="/pub/1ff2cbf2/"/>
      <url>/pub/1ff2cbf2/</url>
      <content type="html"><![CDATA[<h1 id="Tesseract简介-amp-历史"><a href="#Tesseract简介-amp-历史" class="headerlink" title="Tesseract简介&amp;历史"></a>Tesseract简介&amp;历史</h1><p>Tesseract(/‘tesərækt/) 意思是四维超正方体（英语：tesseract）或正八胞体。下图来自维基百科，是一个正八胞体绕着两个四维空间中互相正交的平面进行双旋转时的透视投影。</p><p><img title="这不是Tesseract-OCR的logo" src="https://upload.wikimedia.org/wikipedia/commons/5/55/8-cell-simple.gif"></p><blockquote><p>Tesseract was originally developed at Hewlett-Packard Laboratories Bristol and at Hewlett-Packard Co, Greeley Colorado between 1985 and 1994, with some more changes made in 1996 to port to Windows, and some C++izing in 1998. In 2005 Tesseract was open sourced by HP. Since 2006 it is developed by Google.<br>来自 github官方</p></blockquote><p>Tesseract-OCR是一个开源的OCR引擎，具有悠久的历史。<br>惠普公司的布里斯托尔实验室在1985-1994年开发完成。起初作为惠普的平板扫描仪的文字识别引擎。Tesseract在1995年UNLV OCR字符识别准确性测试中拔得头筹，受到广泛关注。后来HP放弃了OCR市场。在1994年以后，Tesseract的开发就停止了。</p><p>在2005年，HP将Tesseract贡献给开源社区。美国内华达州信息技术研究所获得该源码，同时，Google开始对Tesseract进行功能扩展及优化。目前，Tesseract作为开源项目发布在Google Project上，重获新生。Tesseract的最新版本是3.02，它支持60种以上的语言，提供一个引擎和一个命令行工具。</p><ul><li><a href="https://github.com/tesseract-ocr/tesseract" target="_blank" rel="noopener">github-官网</a></li><li><a href="https://github.com/tesseract-ocr/tesseract/wiki" target="_blank" rel="noopener">官方文档-wiki</a></li></ul><h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><p>sudo apt-get install tesseract-ocr</p><p>sudo apt-get install tesseract-ocr-eng tesseract-ocr-chi-sim</p><p><a href="http://www.zmonster.me/2015/04/17/tesseract-install-usage.html" target="_blank" rel="noopener">Tesseract:安装与命令行使用</a></p><h1 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h1><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看可用的 "语言"</span></span><br><span class="line">$ tesseract --list-langs</span><br></pre></td></tr></table></figure><h2 id="Tesseract识别图片"><a href="#Tesseract识别图片" class="headerlink" title="Tesseract识别图片"></a>Tesseract识别图片</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># from a TIFF image with Tesseract OCR</span></span><br><span class="line">$ tesseract test.png <span class="built_in">test</span></span><br></pre></td></tr></table></figure><h2 id="Tesseract识别tiff"><a href="#Tesseract识别tiff" class="headerlink" title="Tesseract识别tiff"></a>Tesseract识别tiff</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 识别tiff文档，默认是英语</span></span><br><span class="line">$ tesseract test.tiff <span class="built_in">test</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 识别非英语文档</span></span><br><span class="line">tesseract test.tiff -l [lan] test.txt</span><br></pre></td></tr></table></figure><h2 id="Tesseract识别pdf"><a href="#Tesseract识别pdf" class="headerlink" title="Tesseract识别pdf"></a>Tesseract识别pdf</h2><p>步骤:<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1. 转换pdf到tiff(或其他格式)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 2.</span></span><br></pre></td></tr></table></figure></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ tesseract test.pdf <span class="built_in">test</span></span><br><span class="line">Tesseract Open Source OCR Engine v3.02 with Leptonica</span><br><span class="line">Error <span class="keyword">in</span> pixReadStream: Unknown format: no pix returned</span><br><span class="line">Error <span class="keyword">in</span> pixRead: pix not <span class="built_in">read</span></span><br><span class="line">Unsupported image <span class="built_in">type</span>.</span><br></pre></td></tr></table></figure><p>tesseract不能直接识别pdf，一般需要借助工具转化成tiff，然后再识别。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ convert test.pdf test.tiff</span><br><span class="line">$ tesseract test.tiff <span class="built_in">test</span></span><br><span class="line">Tesseract Open Source OCR Engine v3.02 with Leptonica</span><br><span class="line">Error <span class="keyword">in</span> pixReadFromTiffStream: can<span class="string">'t handle bpp &gt; 32</span></span><br><span class="line"><span class="string">Error in pixReadStreamTiff: pix not read</span></span><br><span class="line"><span class="string">Error in pixReadStream: tiff: no pix returned</span></span><br><span class="line"><span class="string">Error in pixRead: pix not read</span></span><br><span class="line"><span class="string">Unsupported image type.</span></span><br></pre></td></tr></table></figure><p>tesseract不能够读取bpp &gt; 32的tiff文件。因此我们转为8bit的tiff文件。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ convert test.pdf -depth 8 test.tiff</span><br><span class="line">$ tesseract test.tiff output</span><br></pre></td></tr></table></figure><p>现在能够正常识别了。</p><h1 id="训练"><a href="#训练" class="headerlink" title="训练"></a>训练</h1><p>参考 <a href="https://www.jianshu.com/p/31afd7fc5813" target="_blank" rel="noopener">https://www.jianshu.com/p/31afd7fc5813</a></p><h2 id="准备训练集"><a href="#准备训练集" class="headerlink" title="准备训练集"></a>准备训练集</h2><h1 id="评价"><a href="#评价" class="headerlink" title="评价"></a>评价</h1><ul><li>图像预处理<br>Tesseract目的不是作为OCR软件，而仅仅是<code>OCR engine</code>。Tesseract在图像预处理方面很弱，如果想得到比较好的识别效果，需要使用者<a href="https://github.com/tesseract-ocr/tesseract/wiki/ImproveQuality" target="_blank" rel="noopener">自己做图片预处理</a>。然而一般多数OCR软件都会集成图片预处理模块，比如Nuance。</li></ul><p>估计怕做的太好，让商业软件</p><p>#</p>]]></content>
      
      <categories>
          
          <category> ML </category>
          
          <category> applications </category>
          
          <category> vision </category>
          
          <category> OCR </category>
          
          <category> Tesseract-OCR </category>
          
      </categories>
      
      
        <tags>
            
            <tag> OCR </tag>
            
            <tag> Tesseract </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>单播，组播(多播)，广播以及任播</title>
      <link href="/pub/dddac94c/"/>
      <url>/pub/dddac94c/</url>
      <content type="html"><![CDATA[<h1 id="路由形式"><a href="#路由形式" class="headerlink" title="路由形式"></a>路由形式</h1><ul><li>单播（原文：unicast）是指数据包在计算机网络的传输中，目的地址为单一目标的一种传输方式。它是现今网络应用最为广泛，通常所使用的网络协议或服务大多采用单播传输，例如一切基于TCP的协议。</li><li>任播（英语：anycast）是一种网络定址和路由的策略，使得资料可以根据路由拓扑来决定送到“最近”或“最好”的目的地。<br>-</li></ul><table style="background-color:white; float:center; margin:1em; border:thin solid black; clear:both; text-align:center;"><tbody><tr><th style="background-color:#CCCCCC; border-bottom:thin solid gray;"><p><a href="https://zh.wikipedia.org/wiki/%E8%B7%AF%E7%94%B1" title="路由" target="_blank" rel="noopener">路由</a>形式<br> <a class="image" href="https://zh.wikipedia.org/wiki/File:Cast.svg" target="_blank" rel="noopener"><img alt="Cast.svg" data-file-height="750" data-file-width="1125" height="67" src="//upload.wikimedia.org/wikipedia/commons/thumb/c/cf/Cast.svg/100px-Cast.svg.png" srcset="//upload.wikimedia.org/wikipedia/commons/thumb/c/cf/Cast.svg/150px-Cast.svg.png 1.5x, //upload.wikimedia.org/wikipedia/commons/thumb/c/cf/Cast.svg/200px-Cast.svg.png 2x" width="100"></a></p></th><th style="margin:1em; border-bottom:thin solid gray;"><p><a class="mw-selflink selflink">任播</a><br> <a class="image" href="https://zh.wikipedia.org/wiki/File:Anycast.svg" target="_blank" rel="noopener"><img alt="Anycast.svg" data-file-height="750" data-file-width="1125" height="67" src="//upload.wikimedia.org/wikipedia/commons/thumb/4/43/Anycast.svg/100px-Anycast.svg.png" srcset="//upload.wikimedia.org/wikipedia/commons/thumb/4/43/Anycast.svg/150px-Anycast.svg.png 1.5x, //upload.wikimedia.org/wikipedia/commons/thumb/4/43/Anycast.svg/200px-Anycast.svg.png 2x" width="100"></a></p></th><th style="margin:1em; border-bottom:thin solid gray;"><p><a href="https://zh.wikipedia.org/wiki/%E5%BB%A3%E6%92%AD_(%E7%B6%B2%E8%B7%AF)" title="广播 (网络)" target="_blank" rel="noopener">广播</a><br> <a class="image" href="https://zh.wikipedia.org/wiki/File:Broadcast.svg" target="_blank" rel="noopener"><img alt="Broadcast.svg" data-file-height="750" data-file-width="1125" height="67" src="//upload.wikimedia.org/wikipedia/commons/thumb/d/dc/Broadcast.svg/100px-Broadcast.svg.png" srcset="//upload.wikimedia.org/wikipedia/commons/thumb/d/dc/Broadcast.svg/150px-Broadcast.svg.png 1.5x, //upload.wikimedia.org/wikipedia/commons/thumb/d/dc/Broadcast.svg/200px-Broadcast.svg.png 2x" width="100"></a></p></th><th style="margin:1em; border-bottom:thin solid gray;"><p><a href="https://zh.wikipedia.org/wiki/%E5%A4%9A%E6%92%AD" title="多播" target="_blank" rel="noopener">多播</a><br> <a class="image" href="https://zh.wikipedia.org/wiki/File:Multicast.svg" target="_blank" rel="noopener"><img alt="Multicast.svg" data-file-height="750" data-file-width="1125" height="67" src="//upload.wikimedia.org/wikipedia/commons/thumb/3/30/Multicast.svg/100px-Multicast.svg.png" srcset="//upload.wikimedia.org/wikipedia/commons/thumb/3/30/Multicast.svg/150px-Multicast.svg.png 1.5x, //upload.wikimedia.org/wikipedia/commons/thumb/3/30/Multicast.svg/200px-Multicast.svg.png 2x" width="100"></a></p></th><th style="margin:1em; border-bottom:thin solid gray;"><p><a href="https://zh.wikipedia.org/wiki/%E5%96%AE%E6%92%AD" title="单播" target="_blank" rel="noopener">单播</a><br> <a class="image" href="https://zh.wikipedia.org/wiki/File:Unicast.svg" target="_blank" rel="noopener"><img alt="Unicast.svg" data-file-height="750" data-file-width="1125" height="67" src="//upload.wikimedia.org/wikipedia/commons/thumb/7/75/Unicast.svg/100px-Unicast.svg.png" srcset="//upload.wikimedia.org/wikipedia/commons/thumb/7/75/Unicast.svg/150px-Unicast.svg.png 1.5x, //upload.wikimedia.org/wikipedia/commons/thumb/7/75/Unicast.svg/200px-Unicast.svg.png 2x" width="100"></a></p></th><th style="margin:1em;"><p><a href="https://zh.wikipedia.org/wiki/Geocast" title="Geocast" target="_blank" rel="noopener">geocast</a><br> <a class="image" href="https://zh.wikipedia.org/wiki/File:Geocast.svg" target="_blank" rel="noopener"><img alt="Geocast.svg" data-file-height="750" data-file-width="1125" height="67" src="//upload.wikimedia.org/wikipedia/commons/thumb/6/6a/Geocast.svg/100px-Geocast.svg.png" srcset="//upload.wikimedia.org/wikipedia/commons/thumb/6/6a/Geocast.svg/150px-Geocast.svg.png 1.5x, //upload.wikimedia.org/wikipedia/commons/thumb/6/6a/Geocast.svg/200px-Geocast.svg.png 2x" width="100"></a></p></th></tr></tbody></table><p>bgp anycast就是<br>利用一个（多个） as号码在不同的地区广播相同的一个ip段。<br>利用bgp的寻路原则，短的as path 会选成最优路径（bgp寻路原则之n），从而优化了访问速度。<br>其实bgp anycast是不同服务器用了相同的ip地址。</p><p>阿里的DNS 就是使用了BGP AnyCast<br>“其实bgp anycast是不同服务器用了相同的ip地址。”</p><h2 id="BGP-Anycast-和-IP-Anycast-有区别吗？"><a href="#BGP-Anycast-和-IP-Anycast-有区别吗？" class="headerlink" title="BGP Anycast 和 IP Anycast  有区别吗？"></a>BGP Anycast 和 IP Anycast  有区别吗？</h2><p>BGP Anycast相较于IP Anycast多了BGP AS，也就是说宣告的这段IP拥有独立的AS号，属于独立的自治域。</p><h2 id="不同服务器用相同地址，不会冲突吗？"><a href="#不同服务器用相同地址，不会冲突吗？" class="headerlink" title="不同服务器用相同地址，不会冲突吗？"></a>不同服务器用相同地址，不会冲突吗？</h2><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="http://colobu.com/2014/10/21/udp-and-unicast-multicast-broadcast-anycast/" target="_blank" rel="noopener">http://colobu.com/2014/10/21/udp-and-unicast-multicast-broadcast-anycast/</a></p><h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><p>广播，是面向什么范围的广播？局域网？世界所有计算机？</p><p>ARP广播，比特币中的广播，</p>]]></content>
      
      <categories>
          
          <category> CS </category>
          
          <category> network </category>
          
          <category> 网络协议-OSI七层模型 </category>
          
          <category> 5. 第三层 网络层 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 单播 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>如何托管你的网站</title>
      <link href="/pub/65131a14/"/>
      <url>/pub/65131a14/</url>
      <content type="html"><![CDATA[<h1 id="Host-网站托管"><a href="#Host-网站托管" class="headerlink" title="Host - 网站托管"></a>Host - 网站托管</h1><p>web hosting (service)可以被翻译为：网站托管。这里的host，类似于“主持、主办、提供”的含义。</p><p>大体分Iaas和PaaS两种</p><ul><li>IaaS：云主机(或虚拟机) - 权限大，费用贵<ul><li>阿里云主机、Google云主机(GCE)、腾讯云主机等</li></ul></li><li>PaaS：云平台(运行软件的平台) - 权限小，便宜或免费<ul><li>动态网站托管平台：SAE、GAE等</li><li>静态网站托管平台：github pages服务、coding pages服务</li></ul></li></ul><!-- Saas：云应用(软件)。我们的网站本身就是应用级别的，要搭建在平台或主机上。--><blockquote><p>注意区分：<br>github的仓库是版本控制软件，是github提供的SaaS服务。<br>github的Pages服务用于网站托管，是github提供的PaaS服务。</p></blockquote><p>多数个人博客采用的Pages服务来托管</p><!--github仓库属于软件级别，里面的代码。我们的网站在github仓库，则作为软件级别的子内容。--><h2 id="关于静态网站-动态网站"><a href="#关于静态网站-动态网站" class="headerlink" title="关于静态网站 动态网站"></a>关于静态网站 动态网站</h2><p>静态网站建站现在有很多快速的技术和平台，但静态是优点也有缺点，由于是静态的，一些动态的内容如评论、计数等等模块就需要借助外来平台，评论有“多说”、“disqus”等，计数有“百度统计”、“google统计”、“不蒜”，实时聊天有“”，</p><h2 id="云主机-贵"><a href="#云主机-贵" class="headerlink" title="云主机 - 贵"></a>云主机 - 贵</h2><h2 id="GAE-限额免费"><a href="#GAE-限额免费" class="headerlink" title="GAE - 限额免费"></a>GAE - 限额免费</h2><p>Google App Engine是Google提供的基于Google数据中心的开发、托管网络应用程序的平台，每个 Google App Engine 应用程序都可使用1GB存储空间和每天1G的流量，GAE对于使用资源有各种限制，跑动态网站往往会配置不够用，但如果网站使用纯粹的静态HTML建立，那么这种网站还是可以支持较大的访问量。</p><p>GAE网站的<code>免费额度</code>限制主要是：文件总容量小于1G，文件数量少于1万个，每天流量小于1G，由于静态网站对于CPU消耗很少，因此CPU的运算限制可以忽略，通常来说，这样的配额对于普通中小型网站已经足够了。</p><h2 id="Pages服务-免费-适合纯静态网站-简单"><a href="#Pages服务-免费-适合纯静态网站-简单" class="headerlink" title="Pages服务 - 免费 - 适合纯静态网站 - 简单"></a>Pages服务 - 免费 - 适合纯静态网站 - 简单</h2><h1 id="图片服务器"><a href="#图片服务器" class="headerlink" title="图片服务器"></a>图片服务器</h1><h2 id="图片服务器的优势"><a href="#图片服务器的优势" class="headerlink" title="图片服务器的优势"></a>图片服务器的优势</h2><p>总得来说，部署图片服务器有以下几点好处：</p><ul><li>分担 Web 服务器的 I/O 负载 - 将耗费资源的图片服务分离出来，提高服务器的性能和稳定性</li><li>能够专门对图片服务器进行优化 - 为图片服务设置有针对性的缓存方案，减少带宽成本，提高访问速度</li><li>提高网站的可扩展性 - 通过增加图片服务器，提高图片吞吐能力</li></ul><h2 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h2><p>案例：又拍云存储<br>又拍云是通用的大规模存储服务，主要为用户提供静态文件存储以及 CDN 加速的服务。</p><p>又拍云在静态文件存储方面有多年的技术经验，一直专注于静态文件存储处理领域。</p><p>又拍云存储在全国各地有 26 个 CDN 节点 ， 300 多台服务器以及电信、联通、移动和教育网四线带宽，能够让用户以极低的价格获得可靠、安全和快速的基础存储服务。</p>]]></content>
      
      <categories>
          
          <category> CS </category>
          
          <category> web </category>
          
          <category> site-dev </category>
          
          <category> host </category>
          
      </categories>
      
      
        <tags>
            
            <tag> github </tag>
            
            <tag> blog </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>将Hexo博客到同时部署到Github和Coding实现全球快速访问。</title>
      <link href="/pub/41fcf36a/"/>
      <url>/pub/41fcf36a/</url>
      <content type="html"><![CDATA[<p>coding.net采用https<br>github pages怎样采用https呢？</p><h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>多线，指多条解析线路(isp)。</p><p>如果访问量特别大，可以多线部署，比如分别部署电信、网通等多条线路，或者不同省份的线路。这里我们仅采用国内线路、海外线路两种。</p><p>一个主机头可以分别解析不同的线路、不同IP，当用户访问网站的时候，智能DNS会判断出他们的线路并解析给他们对应线路的IP，以达到最快的访问速度</p><h2 id="配置hexo的-config文件"><a href="#配置hexo的-config文件" class="headerlink" title="配置hexo的_config文件"></a>配置hexo的_config文件</h2><p>这样在执行hexo deploy命令时就会同时部署到github和coding，由于之前已经配置了ssh，所以这里并不需要输密码 非常方便。</p><h2 id="DNS解析的配置"><a href="#DNS解析的配置" class="headerlink" title="DNS解析的配置"></a>DNS解析的配置</h2><p><img src="/images/raw/建站 - DNS解析 - 配置.png"></p><p>主要配置:<br><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">记录类型</span>  <span class="string">解析线路(isp)</span>  <span class="string">记录值</span></span><br><span class="line"><span class="string">CNAME</span>    <span class="string">世界</span>           <span class="string">xu-song.github.io</span>  <span class="comment"># 海外线路采用github page</span></span><br><span class="line"><span class="string">CNAME</span>    <span class="string">默认</span>           <span class="string">xu-song.coding.me</span>  <span class="comment"># 国内线路采用coding page</span></span><br></pre></td></tr></table></figure></p><h2 id="在coding和github绑定自己的域名"><a href="#在coding和github绑定自己的域名" class="headerlink" title="在coding和github绑定自己的域名"></a>在coding和github绑定自己的域名</h2><h2 id="如何测试"><a href="#如何测试" class="headerlink" title="如何测试"></a>如何测试</h2><p>方式一：<a href="http://tool.chinaz.com/dns/" target="_blank" rel="noopener">http://tool.chinaz.com/dns/</a><br>可测试 DNS 服务器的可用性和响应时间</p><p><img src="/images/raw/建站 - DNS双线部署 - 服务器测速.png"></p><p>美国、香港、台湾已经是解析的github的地址，国内的dns解析的是coding的地址。</p><p>方式二：<a href="http://ce.cloud.360.cn/" target="_blank" rel="noopener">http://ce.cloud.360.cn/</a></p><p>方式三：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">chrome://dns/</span><br><span class="line">查看DNS解析的地址</span><br><span class="line"></span><br><span class="line">chrome://net-internals/#dns</span><br><span class="line">更多功能请参考</span><br><span class="line"></span><br><span class="line">chrome://chrome-urls/</span><br></pre></td></tr></table></figure></p><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>以上方式，github的</p><h1 id="双线部署方案"><a href="#双线部署方案" class="headerlink" title="双线部署方案"></a>双线部署方案</h1><p>方案列表：</p><ol><li>Github + Coding + DNS双线解析。简单，但github不能对独立域名配置HTTPS</li><li>Github + CloudFlare + Coding + DNS双线解析。实现双线部署，双线HTTPS</li></ol><h2 id="如何对js-image等资源设置多线CDN？"><a href="#如何对js-image等资源设置多线CDN？" class="headerlink" title="如何对js image等资源设置多线CDN？"></a>如何对js image等资源设置多线CDN？</h2><p>比如有些google的js国内访问不到，需要采用国内的镜像CDN资源。</p><p>另外，图片、js、css等静态文件可以使用CDN加速，一些公共的js、css可以使用一些公共CDN，比如百度CDN，其余资源可以上传到七牛云来加速。</p><h2 id="如何在html页面动态显示连接线路？"><a href="#如何在html页面动态显示连接线路？" class="headerlink" title="如何在html页面动态显示连接线路？"></a>如何在html页面动态显示连接线路？</h2><p>根据访问的路线，动态显示Hosted by Coding Pages 或者 Github Pages。</p><p>dns解析过程在页面解析之前。。前端无法获取到这个信息。</p><h1 id="Update"><a href="#Update" class="headerlink" title="Update"></a>Update</h1><p>为了双线部署，且启用 SSL 。当前版本采用了</p><ul><li>国内线路：万网NDS +  Coding_Pages(提供Lets’ Encrypt免费SSL证书)</li><li>境外线路：万网DNS + CloudFlare_Name_Server(提供CDN+CloudFlare免费SSL证书) + Github_Pages</li></ul>]]></content>
      
      <categories>
          
          <category> CS </category>
          
          <category> web </category>
          
          <category> site-dev </category>
          
          <category> host </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 建站 </tag>
            
            <tag> github </tag>
            
            <tag> blog </tag>
            
            <tag> pages </tag>
            
            <tag> https </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>DNS解析实例之 Coding Pages</title>
      <link href="/pub/2902c89e/"/>
      <url>/pub/2902c89e/</url>
      <content type="html"><![CDATA[<h2 id="coding-page跳转至首页"><a href="#coding-page跳转至首页" class="headerlink" title="coding page跳转至首页"></a>coding page跳转至首页</h2><p>DNS配置<br><img src="/images/raw/建站 - DNS解析 - 配置.png"></p><p>coding.net域名配置<br><img src="/images/raw/建站 - Coding Pages - 域名配置.png"></p><p><code>首选</code>域名，一次到达</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ wget https://blog.eson.org</span><br><span class="line"><span class="comment"># 这个不需要重定向</span></span><br><span class="line">--2018-03-02 18:51:26--  https://blog.eson.org/</span><br><span class="line">Resolving blog.eson.org (blog.eson.org)... 107.150.121.91, 107.150.121.231, 103.72.147.89, ...</span><br><span class="line">Connecting to blog.eson.org (blog.eson.org)|107.150.121.91|:443... connected.</span><br><span class="line">HTTP request sent, awaiting response... 200 OK</span><br><span class="line">Length: 72536 (71K) [text/html]</span><br><span class="line">Saving to: ‘index.html.1’</span><br></pre></td></tr></table></figure><p><code>跳转至首页</code>的域名，采用301跳转</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">$ wget xusong.vip</span><br><span class="line">--2018-03-02 17:35:28--  http://xusong.vip/</span><br><span class="line"><span class="comment"># dns解析xusong.vip，根据CNAME记录得到xu-song.coding.me。</span></span><br><span class="line"><span class="comment"># 然后解析xu-song.coding.me对应的服务器IP。</span></span><br><span class="line"><span class="comment"># 返回“301跳转到 http://blog.eson.org/”</span></span><br><span class="line">Resolving xusong.vip (xusong.vip)... 103.72.145.7, 23.91.101.50, 103.218.240.147, ...</span><br><span class="line">Connecting to xusong.vip (xusong.vip)|103.72.145.7|:80... connected.</span><br><span class="line">HTTP request sent, awaiting response... 301 Moved Permanently</span><br><span class="line">Location: http://blog.eson.org/ [following]</span><br><span class="line"><span class="comment"># DNS解析http站点，返回“301跳转至https页面”</span></span><br><span class="line">--2018-03-02 17:35:29--  http://blog.eson.org/</span><br><span class="line">Resolving blog.eson.org (blog.eson.org)... 103.72.147.211, 103.72.145.7, 23.91.101.50, ...</span><br><span class="line">Reusing existing connection to xusong.vip:80.</span><br><span class="line">HTTP request sent, awaiting response... 301 Moved Permanently</span><br><span class="line">Location: https://blog.eson.org/ [following]</span><br><span class="line"><span class="comment"># DNS解析https站点，返回页面内容</span></span><br><span class="line">--2018-03-02 17:35:31--  https://blog.eson.org/</span><br><span class="line">Connecting to blog.eson.org (blog.eson.org)|103.72.147.211|:443... connected.</span><br><span class="line">HTTP request sent, awaiting response... 200 OK</span><br><span class="line">Length: 72536 (71K) [text/html]</span><br><span class="line">Saving to: ‘index.html’</span><br></pre></td></tr></table></figure><p>不加https协议，会首先301跳转到https站点。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">$ wget blog.eson.org</span><br><span class="line"><span class="comment"># 默认是访问 http://blog.eson.org，返回301重定向 https://blog.eson.org/</span></span><br><span class="line">--2018-03-02 18:50:27--  http://blog.eson.org/</span><br><span class="line">Resolving blog.eson.org (blog.eson.org)... 36.255.221.66, 107.150.121.91, 107.150.121.231, ...</span><br><span class="line">Connecting to blog.eson.org (blog.eson.org)|36.255.221.66|:80... connected.</span><br><span class="line">HTTP request sent, awaiting response... 301 Moved Permanently</span><br><span class="line">Location: https://blog.eson.org/ [following]</span><br><span class="line"><span class="comment">#</span></span><br><span class="line">--2018-03-02 18:50:28--  https://blog.eson.org/</span><br><span class="line">Connecting to blog.eson.org (blog.eson.org)|36.255.221.66|:443... connected.</span><br><span class="line">HTTP request sent, awaiting response... 200 OK</span><br><span class="line">Length: 72536 (71K) [text/html]</span><br><span class="line">Saving to: ‘index.html’</span><br></pre></td></tr></table></figure><p>直接访问coding pages页面，要跳转2次，一次302，一次301<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">$ wget xu-song.coding.me</span><br><span class="line"><span class="comment">#</span></span><br><span class="line">--2018-03-02 18:58:45--  http://xu-song.coding.me/</span><br><span class="line">Resolving xu-song.coding.me (xu-song.coding.me)... 23.91.97.251, 103.218.241.74, 103.72.147.211, ...</span><br><span class="line">Connecting to xu-song.coding.me (xu-song.coding.me)|23.91.97.251|:80... connected.</span><br><span class="line">HTTP request sent, awaiting response... 302 Found</span><br><span class="line">Location: http://blog.eson.org/ [following]</span><br><span class="line"><span class="comment">#</span></span><br><span class="line">--2018-03-02 18:58:46--  http://blog.eson.org/</span><br><span class="line">Resolving blog.eson.org (blog.eson.org)... 103.72.147.211, 103.72.145.7, 23.91.101.50, ...</span><br><span class="line">Reusing existing connection to xu-song.coding.me:80.</span><br><span class="line">HTTP request sent, awaiting response... 301 Moved Permanently</span><br><span class="line">Location: https://blog.eson.org/ [following]</span><br><span class="line"><span class="comment">#</span></span><br><span class="line">--2018-03-02 18:58:46--  https://blog.eson.org/</span><br><span class="line">Connecting to blog.eson.org (blog.eson.org)|103.72.147.211|:443... connected.</span><br><span class="line">HTTP request sent, awaiting response... 200 OK</span><br><span class="line">Length: 72536 (71K) [text/html]</span><br><span class="line">Saving to: ‘index.html.3’</span><br></pre></td></tr></table></figure></p>]]></content>
      
      <categories>
          
          <category> CS </category>
          
          <category> network </category>
          
          <category> 网络协议-OSI七层模型 </category>
          
          <category> 1. 第七层 应用层 </category>
          
          <category> DNS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> network </tag>
            
            <tag> dns </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>metric 距离度量</title>
      <link href="/pub/7a1905e5/"/>
      <url>/pub/7a1905e5/</url>
      <content type="html"><![CDATA[<p>什么时候采用均方差，什么时候采用cross entropy？</p><h2 id="连个任意向量的距离"><a href="#连个任意向量的距离" class="headerlink" title="连个任意向量的距离"></a>连个任意向量的距离</h2><p>L1 L2</p><p>L2距离，更改坐标系，距离不变。<br>L1距离，更改坐标系，距离会变。coordinate dependency</p><p>有特殊意义的，可以用L1. 没有特殊意义的向量，最好用L2。</p><p><a href="http://vision.stanford.edu/teaching/cs231n-demos/knn/" target="_blank" rel="noopener">http://vision.stanford.edu/teaching/cs231n-demos/knn/</a></p><h2 id="两个概率的距离"><a href="#两个概率的距离" class="headerlink" title="两个概率的距离"></a>两个概率的距离</h2><ul><li>cross entropy</li><li>kl divergence</li><li>word mover distance<ul><li>WMD for document distance</li><li>Wasserstein GAN (W-GAN)<br>-</li></ul></li></ul>]]></content>
      
      <categories>
          
          <category> ML </category>
          
          <category> machine learning 传统方法 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Hexo中的SEO技巧</title>
      <link href="/pub/8b29356c/"/>
      <url>/pub/8b29356c/</url>
      <content type="html"><![CDATA[<h2 id="关于keywords"><a href="#关于keywords" class="headerlink" title="关于keywords"></a>关于keywords</h2><p>为每个post添加tag，因为tag会被放入页面的<code>keywords</code></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&#123;% if page.keywords %&#125;</span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"keywords"</span> <span class="attr">content</span>=<span class="string">"&#123;&#123; page.keywords &#125;&#125;"</span> /&gt;</span></span><br><span class="line">&#123;% elif page.tags and page.tags.length %&#125;</span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"keywords"</span> <span class="attr">content</span>=<span class="string">"&#123;% for tag in page.tags %&#125;&#123;&#123; tag.name &#125;&#125;,&#123;% endfor %&#125;"</span> /&gt;</span></span><br></pre></td></tr></table></figure><p>每个页面 keywords 的选择顺序，是按照如下优先顺序进行</p><ol><li>page 中定义的 keywords</li><li>page 中定义的 tags</li><li>_config.yml 中定义的 keywords (hexo中定义的keyword，不是theme的config)</li></ol><p>源码<br><a href="https://github.com/hexojs/hexo/blob/master/lib/plugins/helper/open_graph.js" target="_blank" rel="noopener">https://github.com/hexojs/hexo/blob/master/lib/plugins/helper/open_graph.js</a></p><p><a href="https://github.com/theme-next/hexo-theme-next/blob/master/layout/_partials/head/head-unique.swig" target="_blank" rel="noopener">https://github.com/theme-next/hexo-theme-next/blob/master/layout/_partials/head/head-unique.swig</a></p><p>建议tags标签和keywords标签都加。由于keywords在页面不会展示，因此添加更自由，添加面向SEO的标签。</p><h2 id="关于robots-txt-和-sitemap-xml"><a href="#关于robots-txt-和-sitemap-xml" class="headerlink" title="关于robots.txt 和 sitemap.xml"></a>关于robots.txt 和 sitemap.xml</h2><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="http://www.restran.net/2017/05/02/hexo-custom-html-meta-keywords/" target="_blank" rel="noopener">http://www.restran.net/2017/05/02/hexo-custom-html-meta-keywords/</a></p>]]></content>
      
      <categories>
          
          <category> CS </category>
          
          <category> web </category>
          
          <category> site-dev </category>
          
          <category> seo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
            <tag> domain </tag>
            
            <tag> SEO </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>【机器学习系列】特征工程</title>
      <link href="/pub/48f2c2f6/"/>
      <url>/pub/48f2c2f6/</url>
      <content type="html"><![CDATA[<h1 id="特征类别"><a href="#特征类别" class="headerlink" title="特征类别"></a>特征类别</h1><h2 id="离散特征"><a href="#离散特征" class="headerlink" title="离散特征"></a>离散特征</h2><h2 id="连续特征-continuous-features"><a href="#连续特征-continuous-features" class="headerlink" title="连续特征 (continuous features)"></a>连续特征 (continuous features)</h2><p>Bucketization turns a continuous column into a categorical column. This transformation lets you use continuous features in feature crosses, or learn cases where specific value ranges have particular importance.</p><h3 id="Bucketization"><a href="#Bucketization" class="headerlink" title="Bucketization"></a>Bucketization</h3><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">age_buckets = tf.feature_column.bucketized_column(</span><br><span class="line">    age, boundaries=[<span class="number">18</span>, <span class="number">25</span>, <span class="number">30</span>, <span class="number">35</span>, <span class="number">40</span>, <span class="number">45</span>, <span class="number">50</span>, <span class="number">55</span>, <span class="number">60</span>, <span class="number">65</span>])</span><br></pre></td></tr></table></figure><p>为什么要<code>Bucketization</code>?</p><h2 id="类别特征-Categorical-features"><a href="#类别特征-Categorical-features" class="headerlink" title="类别特征 Categorical features"></a>类别特征 Categorical features</h2><ul><li>文本中的word<blockquote><p>图像中的像素点，不是。因为具有大小有意义。</p></blockquote></li></ul><p>通常被转化为稀疏向量。(比如FM中对user_id的处理，NLP中的one-hot表达，)</p><p>比如<br> ‘eye_color’的’brown’表示为[1, 0, 0], ‘blue’ 表示为[0, 1, 0] and ‘green’表示为[0, 0, 1].</p><p>称之为稀疏向量，因为多数情况下向量维度高，仅只有一个非零值。</p><blockquote><p>为什么不用一个点表示？比如表示成 1 2 3？这样只占用一个维度。</p></blockquote><p>典型的特征处理方法</p><ul><li>one-hot处理</li><li>还有hash-bucket处理</li></ul><h3 id="挑战"><a href="#挑战" class="headerlink" title="挑战"></a>挑战</h3><ol><li><strong>未知的类别</strong><ul><li>可采用<code>categorical_column_with_hash_bucket()</code></li></ul></li><li>ss</li></ol><h1 id="特征工程"><a href="#特征工程" class="headerlink" title="特征工程"></a>特征工程</h1><p>Base Feature Column</p><p>通常原始特征表达能力不够，通常大家会在原始特征的基础上人工设计一些特征。特征设计的好坏对整个系统至关重要。设计的好，效果好，外接简单的分类器或其他模型就能够取得较好的效果。因此工业界很青睐这种方法。</p><h2 id="Feature-Crosses"><a href="#Feature-Crosses" class="headerlink" title="Feature Crosses"></a>Feature Crosses</h2><p>组合特征，这仅仅适用于sparser特征.产生的依然是sparsor特征</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sport_x_city = tf.feature_column.crossed_column(</span><br><span class="line">    [&quot;sport&quot;, &quot;city&quot;], hash_bucket_size=int(1e4))</span><br></pre></td></tr></table></figure><h2 id=""><a href="#" class="headerlink" title="#"></a>#</h2><h2 id="挑战-amp-缺陷"><a href="#挑战-amp-缺陷" class="headerlink" title="挑战 &amp; 缺陷"></a>挑战 &amp; 缺陷</h2><ol><li>特征工程</li></ol><h1 id="特征选择"><a href="#特征选择" class="headerlink" title="特征选择"></a>特征选择</h1><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li><a href="https://www.tensorflow.org/tutorials/wide_and_deep" target="_blank" rel="noopener">Wide &amp; Deep Learning Tutorial | TensorFlow</a> |  <a href="https://github.com/tensorflow/models/tree/master/official/wide_deep" target="_blank" rel="noopener">code</a><ul><li>浅层模型(比如LR)要提高效果，一般会提前大量的人工特征，即wide模型</li><li>DNN一般采用end-to-end的模型，建立<code>原始特征--&gt;label</code>的映射。</li><li>wide &amp; deep则是结合两者的有点。</li></ul></li></ul>]]></content>
      
      <categories>
          
          <category> ML </category>
          
          <category> machine learning 传统方法 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>广义线性模型</title>
      <link href="/pub/59c3166/"/>
      <url>/pub/59c3166/</url>
      <content type="html"><![CDATA[<h1 id="logistic-regression"><a href="#logistic-regression" class="headerlink" title="logistic regression"></a>logistic regression</h1><p>逻辑回归</p><p>  = 最小二乘法。</p><p>最小二乘法(Least squares)的线性回归中，我们的目标方程</p><h1 id="ridge-regression"><a href="#ridge-regression" class="headerlink" title="ridge regression"></a>ridge regression</h1><p>岭回归</p><h1 id="二范数-L2正则"><a href="#二范数-L2正则" class="headerlink" title="二范数 L2正则"></a>二范数 L2正则</h1><p>相当于对参数加高斯先验</p><h1 id="L1正则"><a href="#L1正则" class="headerlink" title="L1正则"></a>L1正则</h1><p>相当于对参数加拉普拉斯先验。</p>]]></content>
      
      <categories>
          
          <category> ML </category>
          
          <category> machine learning 传统方法 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Coding Pages托管静态博客-原理浅析</title>
      <link href="/pub/d2f02b9b/"/>
      <url>/pub/d2f02b9b/</url>
      <content type="html"><![CDATA[<p>参考 DNS解析实例-ESON</p><blockquote><p>github page不支持多个域名，因此不存在重定向</p></blockquote><h2 id="301，302-区别"><a href="#301，302-区别" class="headerlink" title="301，302 区别"></a>301，302 区别</h2><h3 id="对于用户"><a href="#对于用户" class="headerlink" title="对于用户"></a>对于用户</h3><p>301，302对用户来说没有区别，他们看到效果只是一个跳转，浏览器中旧的URL变成了新的URL。页面跳到了这个新的url指向的地方。</p><h3 id="对于引擎及站长"><a href="#对于引擎及站长" class="headerlink" title="对于引擎及站长"></a>对于引擎及站长</h3><h4 id="302-redirect-302-代表暂时性转移-Temporarily-Moved-临时跳转"><a href="#302-redirect-302-代表暂时性转移-Temporarily-Moved-临时跳转" class="headerlink" title="302 redirect: 302 代表暂时性转移(Temporarily Moved ) 临时跳转"></a>302 redirect: 302 代表暂时性转移(Temporarily Moved ) 临时跳转</h4><p>302转向可能会有URL规范化及网址劫持的问题。可能被搜索引擎判为可疑转向，甚至认为是作弊。</p><p>302重定向和网址劫持（URL hijacking）有什么关系呢？这要从搜索引擎如何处理302转向说起。从定义来说，从网址A做一个302重定向到网址B时，主机服务器的隐含意思是网址A随时有可能改主意，重新显示本身的内容或转向其他的地方。大部分的搜索引擎在大部分情况下，当收到302重定向时，一般只要去抓取目标网址就可以了，也就是说网址B。</p><p>实际上如果搜索引擎在遇到302转向时，百分之百的都抓取目标网址B的话，就不用担心网址URL劫持了。问题就在于，有的时候搜索引擎，尤其是Google，并不能总是抓取目标网址。为什么呢？比如说，有的时候A网址很短，但是它做了一个302重定向到B网址，而B网址是一个很长的乱七八糟的URL网址，甚至还有可能包含一些问号之类的参数。很自然的，A网址更加用户友好，而B网址既难看，又不用户友好。这时Google很有可能会仍然显示网址A。</p><p>由于搜索引擎排名算法只是程序而不是人，在遇到302重定向的时候，并不能像人一样的去准确判定哪一个网址更适当，这就造成了网址URL劫持的可能性。也就是说，一个不道德的人在他自己的网址A做一个302重定向到你的网址B，出于某种原因， Google搜索结果所显示的仍然是网址A，但是所用的网页内容却是你的网址B上的内容，这种情况就叫做网址URL劫持。你辛辛苦苦所写的内容就这样被别人偷走了。</p><p>DNS解析有一条 显性URL-将域名302重定向到另外一个地址。</p><h4 id="301-redirect-301-代表永久性转移-Permanently-Moved-，"><a href="#301-redirect-301-代表永久性转移-Permanently-Moved-，" class="headerlink" title="301 redirect: 301 代表永久性转移(Permanently Moved)，"></a>301 redirect: 301 代表永久性转移(Permanently Moved)，</h4><p>当网页A用301重定向转到网页B时，搜索引擎可以肯定网页A永久的改变位置，或者说实际上不存在了，搜索引擎就会把网页B当作唯一有效目标。<br>301的好处是:</p><ul><li>第一， 没有网址规范化问题。</li><li>第二， 也很重要的，网页A的PR网页级别会传到网页B。</li></ul><p>变更网站域名建议直接做301重定向，UEL跳转不利于SEO蜘蛛本身不喜欢，运气不好还会被判作弊<br>当网页A用301重定向到网页B时，搜索引擎可以肯定网页A永久的改变位置，或者说实际上不存在了，搜索引擎就会把网页B当作唯一有效目标。<br>好处是，第一没有网址规划问题；第二，网页A的PR网页级别会传到网页B。</p><h2 id="大家常用的301-302"><a href="#大家常用的301-302" class="headerlink" title="大家常用的301 302"></a>大家常用的301 302</h2><h3 id="301"><a href="#301" class="headerlink" title="301"></a>301</h3><p>t.cn<br>知乎跳转<br>dns解析跳转<br>coding page跳转主页</p><h2 id="如何实现转发"><a href="#如何实现转发" class="headerlink" title="如何实现转发"></a>如何实现转发</h2><ul><li>DNS可配置 302转发</li><li>apache / nginx 配置文件中写转发规则，rewrite xxx yyy 301</li><li>写一个 index.html 文件，里面写 meta refresh 跳转规则</li></ul>]]></content>
      
      <categories>
          
          <category> CS </category>
          
          <category> web </category>
          
          <category> site-dev </category>
          
          <category> host </category>
          
          <category> coding-pages </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git </tag>
            
            <tag> blog </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>修宪 - 2018</title>
      <link href="/pub/275d8a6f/"/>
      <url>/pub/275d8a6f/</url>
      <content type="html"><![CDATA[<ul><li><a href="http://cn.github.io/constitution/1982-12-04.html" target="_blank" rel="noopener">中华人民共和国宪法 (1982-12-04)</a></li><li><a href="http://cn.github.io/constitution/2004-03-14.html" target="_blank" rel="noopener">中华人民共和国宪法 (2004-03-14)</a></li></ul><h1 id="2018年修宪"><a href="#2018年修宪" class="headerlink" title="2018年修宪"></a>2018年修宪</h1><p>全名：<a href="https://zh.wikipedia.org/wiki/%E4%B8%AD%E5%8D%8E%E4%BA%BA%E6%B0%91%E5%85%B1%E5%92%8C%E5%9B%BD%E5%AE%AA%E6%B3%95%E4%BF%AE%E6%AD%A3%E6%A1%88_(2018%E5%B9%B4" target="_blank" rel="noopener">《中华人民共和国宪法修正案》（2018年）</a>)</p><ul><li>2017年9月29日 - 成立宪法修改小组<!--宪法修改小组，由张德江任组长，栗战书、王沪宁任副组长。同年10月18日，中共十九大召开，栗战书及王沪宁当选新一届政治局常委--></li><li>2018年1月30日 - 由人大常委会提请申报成功，全票通过《中华人民共和国宪法修正案（草案）》</li><li>2018年2月25日 - 由<a href="http://www.xinhuanet.com/politics/2018-02/25/c_1122451187.htm" target="_blank" rel="noopener">新华社</a>和新闻联播于公布 《中国共产党中央委员会关于修改宪法部分内容的建议》</li></ul><p><a href="https://github.com/cn/constitution/pull/2/commits/8115484d1848d309f68c709d8ea176374b2b1160" target="_blank" rel="noopener">划重点</a></p><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">第七十九条</span><br><span class="line"><span class="deletion">- 中华人民共和国主席、副主席每届任期同全国人民代表大会每届任期相同，连续任职不得超过两届。</span></span><br><span class="line"><span class="addition">+ 中华人民共和国主席、副主席每届任期同全国人民代表大会每届任期相同。</span></span><br><span class="line"></span><br><span class="line"><span class="deletion">- 在马克思列宁主义、毛泽东思想、邓小平理论和“三个代表”重要思想指引下</span></span><br><span class="line"><span class="addition">+ 在马克思列宁主义、毛泽东思想、邓小平理论、“三个代表”重要思想、科学发展观、习近平新时代中国特色社会主义思想指引下</span></span><br><span class="line"></span><br><span class="line">第六十三条 全国人民代表大会有权罢免下列人员：</span><br><span class="line">   主席、副主席、国务院总理、副总理、军事委员会主席、最高人民法院院长、最高人民检察院检察长</span><br><span class="line"><span class="addition">+ （四）国家监察委员会主任；</span></span><br></pre></td></tr></table></figure><ul><li>宪法第七十九条第三款，删除<code>“国家主席、副主席连续任职不得超过两届”</code>，而引起国际关注。外界普遍将之视为邓小平时代提出的“废除干部领导职务终身制”的结束。</li><li>宪法序言增写<code>“科学发展观”</code>、<code>“习近平新时代中国特色社会主义思想”</code>及<code>“富强民主文明和谐美丽的社会主义现代化强国”</code>字样</li></ul><h2 id="关于-监察机关-国家监察委员会"><a href="#关于-监察机关-国家监察委员会" class="headerlink" title="关于 监察机关 国家监察委员会"></a>关于 监察机关 国家监察委员会</h2><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="addition">+ 第一百二十三条 中华人民共和国各级监察委员会是国家的监察机关。</span></span><br><span class="line"><span class="addition">+ 第一百二十四条 中华人民共和国设立国家监察委员会和地方各级监察委员会。监察委员会由下列人员组成</span></span><br><span class="line"><span class="addition">+  主任，</span></span><br><span class="line"><span class="addition">+  副主任若干人，</span></span><br><span class="line"><span class="addition">+  委员若干人。</span></span><br><span class="line"><span class="addition">+  监察委员会主任每届任期同本级人民代表大会每届任期相同。国家监察委员会主任连续任职不得超过两届。</span></span><br></pre></td></tr></table></figure><h1 id="关于修宪历史"><a href="#关于修宪历史" class="headerlink" title="关于修宪历史"></a>关于修宪历史</h1><p>中国现行宪法制定于1982年。当时，为废除实际存在的领导职务终身制，吸取文革个人崇拜的教训，宪法规定了国家主席连续任职不得超过两届，在客观上限定了中国国家元首任职不能超过十年。</p><p>中共于1988年、1993年、1999年、2004年对现行宪法进行了四次修改</p><h2 id="1988年修宪：为“私营经济”正名"><a href="#1988年修宪：为“私营经济”正名" class="headerlink" title="1988年修宪：为“私营经济”正名"></a>1988年修宪：为“私营经济”正名</h2><h2 id="1993年修宪"><a href="#1993年修宪" class="headerlink" title="1993年修宪"></a>1993年修宪</h2><p>1993年，中共总书记、中央军委主席江泽民接替杨尚昆出任国家主席，定下了总书记、国家主席、中央军委主席“三位一体”的最高领导模式。</p><p>国家的奋斗目标，则由建设“高度文明、高度民主的社会主义国家”变为建设“富强、民主、文明的社会主义国家”。两个字的增加、两个词顺序的变化，看似微小，却深意可见。</p><p>“市场经济”一词的入宪、“计划经济”一词的淡出。</p><h2 id="1999年修宪：为“法治”鼓与呼"><a href="#1999年修宪：为“法治”鼓与呼" class="headerlink" title="1999年修宪：为“法治”鼓与呼"></a>1999年修宪：为“法治”鼓与呼</h2><p>“依法治国”。</p><h2 id="2004-第四次修改，"><a href="#2004-第四次修改，" class="headerlink" title="2004- 第四次修改，"></a>2004- 第四次修改，</h2><h2 id="关于连任"><a href="#关于连任" class="headerlink" title="关于连任"></a>关于连任</h2><ul><li><p>根据邓小平在1980年提倡的“废除干部领导职务终身制”，重新设立的国家主席和副主席任期为五年一届，连任不能超过两届。</p></li><li><p>党总书记、军委主席是中国政治体系中拥有最大权力的两个职务，没有连任次数的限制。</p></li></ul><h1 id="扩展阅读"><a href="#扩展阅读" class="headerlink" title="扩展阅读"></a>扩展阅读</h1><ul><li><a href="http://mp.weixin.qq.com/s?__biz=MjM5MjAxNDM4MA==&amp;mid=2666189516&amp;idx=1&amp;sn=fe2efe7f762a87af40c681ea05d73e27&amp;chksm=bdb2bb8f8ac5329948e860b02b22c00037801602187791f0c0be1fc1600af85fcb24d45abf40&amp;mpshare=1" target="_blank" rel="noopener">修宪前后完整对比</a></li><li><a href="https://www.zhihu.com/question/22349148" target="_blank" rel="noopener">为什么美国的 1787 宪法可以至今沿用?</a></li></ul>]]></content>
      
      <categories>
          
          <category> others </category>
          
          <category> politics </category>
          
          <category> china </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 宪法 </tag>
            
            <tag> 国家监察委员会 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>禁止搜索引擎收录的方法</title>
      <link href="/pub/c429c70d/"/>
      <url>/pub/c429c70d/</url>
      <content type="html"><![CDATA[<h1 id="什么是robots协议"><a href="#什么是robots协议" class="headerlink" title="什么是robots协议"></a>什么是robots协议</h1><p>Robots协议（也称为爬虫协议、机器人协议等）的全称是“网络爬虫排除标准”（Robots Exclusion Protocol），网站通过Robots协议告诉搜索引擎哪些页面可以抓取，哪些页面不能抓取。搜索引擎抓取网站内容前会先抓取robots.txt，据此“自觉地”抓取或者不抓取该网页内容，其目的是保护网站数据和敏感信息、确保用户个人信息和隐私不被侵犯。</p><p>需要注意的是robots协议并非是规范，只是行业内一个约定俗成的协议。什么意思呢?Robots协议不是什么技术壁垒，而只是一种互相尊重的协议，好比私家花园的门口挂着“闲人免进”，尊重者绕道而行，不尊重者依然可以推门而入，比如说360。</p><p>如果网站有数据需要保密，必需采取技术措施，比如说：用户验证，加密，ip拦截，访问频率控制等。</p><h1 id="为什么要禁止搜索引擎收录"><a href="#为什么要禁止搜索引擎收录" class="headerlink" title="为什么要禁止搜索引擎收录"></a>为什么要禁止搜索引擎收录</h1><ol><li>某些路径下是个人隐私或者网站管理使用，不想被搜索引擎抓取</li><li>不喜欢某个搜索引擎，不愿意被他抓取，最有名的就是之前淘宝不希望被百度抓取</li><li>流量有限或者需要付费，希望搜索引擎抓的温柔点。</li><li>阻止竞争抓取自己的网站内容，比如搜索引擎之间相互屏蔽，360</li></ol><h1 id="robots的屏蔽恩怨历史"><a href="#robots的屏蔽恩怨历史" class="headerlink" title="robots的屏蔽恩怨历史"></a>robots的屏蔽恩怨历史</h1><p>汇总</p><div class="table-container"><table><thead><tr><th></th><th>百度</th><th>google</th><th>bing</th><th>备注</th></tr></thead><tbody><tr><td>淘宝</td><td>×</td><td>√</td><td>√</td><td>不屏蔽google，因为google不做淘宝的竞价排名。另外还能作为淘宝流量入口</td></tr><tr><td>京东</td><td>√</td><td>√</td><td>√</td><td></td></tr><tr><td></td><td></td><td></td><td></td><td></td></tr><tr><td>微信公众平台</td><td></td><td></td><td></td><td></td></tr><tr><td>社交网络—开放空间</td><td></td><td></td><td></td><td></td></tr><tr><td>weibo</td><td></td><td></td><td></td><td></td></tr><tr><td>facebook</td><td></td><td></td><td></td><td></td></tr><tr><td>twitter</td><td></td><td></td><td></td><td></td></tr><tr><td>社交网络—隐私空间</td><td></td><td></td><td></td><td></td></tr><tr><td>qq空间</td><td></td><td></td><td></td><td></td></tr><tr><td>微信朋友圈</td><td></td><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td><td></td><td></td></tr><tr><td>baidu、google</td><td>×</td><td>×</td><td>×</td><td>搜索引擎，屏蔽一切搜索引擎爬虫</td></tr><tr><td></td><td></td><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td><td></td></tr></tbody></table></div><h2 id="github-屏蔽百度、搜狗、360等"><a href="#github-屏蔽百度、搜狗、360等" class="headerlink" title="github - 屏蔽百度、搜狗、360等"></a>github - 屏蔽百度、搜狗、360等</h2><h3 id="为什么屏蔽百度"><a href="#为什么屏蔽百度" class="headerlink" title="为什么屏蔽百度"></a>为什么屏蔽百度</h3><blockquote><p>We are currently blocking the Baidu user agent from crawling GitHub Pages sites in response to this user agent being responsible for an excessive amount of requests, which was causing availability issues for other GitHub customers.</p><p>This is unlikely to change any time soon, so if you need the Baidu user agent to be able to crawl your site you will need to host it elsewhere.</p><p>— by <a href="http://jerryzou.com/posts/feasibility-of-allowing-baiduSpider-for-Github-Pages/" target="_blank" rel="noopener">Github Support</a> Jerry’s blog</p></blockquote><p>即百度爬虫爬得太猛烈，已经对很多 Github 用户造成了可用性的问题了，而禁用百度爬虫这一举措可能会一直持续下去。</p><p>白名单中竟然有 EtaoSpider。why？<br>为什么百度中搜索<code>site:github.io</code>有结果？</p><p><code>www.github.com</code>中的<a href="www.github.com/robots.txt">robots.txt</a><br><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">User-agent:</span> <span class="string">Googlebot</span>   <span class="comment"># google yandex等都在白名单。</span></span><br><span class="line"><span class="attr">Allow:</span> <span class="string">/*/*/tree/master</span></span><br><span class="line"><span class="attr">Allow:</span> <span class="string">/*/*/blob/master</span></span><br><span class="line"></span><br><span class="line"><span class="attr">User-agent:</span> <span class="string">*</span>   </span><br><span class="line"><span class="attr">Allow:</span> <span class="string">/humans.txt</span></span><br><span class="line"><span class="attr">Disallow:</span> <span class="string">/</span>      <span class="comment"># 百度不在白名单，即整个站点屏蔽百度</span></span><br></pre></td></tr></table></figure></p><p>除设置了robots.txt之外，github后台服务器还会检查HTTP请求的UA，如果是百度就返回403 forbidden。</p><h2 id="电商"><a href="#电商" class="headerlink" title="电商"></a>电商</h2><h3 id="淘宝-屏蔽百度"><a href="#淘宝-屏蔽百度" class="headerlink" title="淘宝 - 屏蔽百度"></a>淘宝 - 屏蔽百度</h3><ul><li>争夺流量入口<br>-</li><li>.</li></ul><p>2008年淘宝屏蔽了百度搜索引擎，自此用户再也无法从百度直接搜索到关于淘宝的信息。</p><p>淘宝网站曾经屏蔽百度搜索爬虫，禁止百度搜索引擎抓取淘宝网站的网页内容，淘宝官方的解释是“杜绝不良商家欺诈”。</p><p>首先，在08年9月淘宝先屏蔽了百度搜索，使得当我们在百度搜索淘宝产品名时，百度返回不到有效信息。导致普通网民在进行网上购物行为时，会直接选择登陆淘宝网，用站内搜索进行，从上网入口上讲，淘宝这样就让网民一步到位了，而不是单单记住百度这个工具，淘宝的流量肯定会水涨船高，带来的好处也不言而明。</p><p>如果当初淘宝没有屏蔽百度，不多说：最起码30%的购物搜索会来自百度。淘宝屏蔽百度以后，淘宝真正的成为了购物的第一入口。</p><p>淘宝主页<code>www.taobao.com</code>的<a href="www.taobao.com/robots.txt">robots.txt</a><br><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">User-agent:</span> <span class="string">Baiduspider</span></span><br><span class="line"><span class="attr">Allow:</span> <span class="string">/article</span></span><br><span class="line"><span class="attr">Allow:</span> <span class="string">/oshtml</span></span><br><span class="line"><span class="attr">Disallow:</span> <span class="string">/product/</span>  <span class="comment"># 禁止百度抓取www.taobao.com/product/</span></span><br><span class="line"><span class="attr">Disallow:</span> <span class="string">/</span>          <span class="comment"># 屏蔽网站其他路径</span></span><br><span class="line"></span><br><span class="line"><span class="attr">User-Agent:</span> <span class="string">Googlebot</span></span><br><span class="line"><span class="attr">Allow:</span> <span class="string">/article</span></span><br><span class="line"><span class="attr">Allow:</span> <span class="string">/oshtml</span></span><br><span class="line"><span class="attr">Allow:</span> <span class="string">/product</span>   <span class="comment"># 对google很宽松，即开放google入口，</span></span><br><span class="line"><span class="attr">Allow:</span> <span class="string">/spu</span></span><br><span class="line"><span class="attr">Allow:</span> <span class="string">/dianpu</span></span><br><span class="line"><span class="attr">Allow:</span> <span class="string">/oversea</span></span><br><span class="line"><span class="attr">Allow:</span> <span class="string">/list</span></span><br><span class="line"><span class="attr">Disallow:</span> <span class="string">/</span></span><br></pre></td></tr></table></figure></p><p>淘宝商品页面<code>item.taobao.com</code>的<a href="https://item.taobao.com/robots.txt" target="_blank" rel="noopener">robot.txt</a></p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">User-agent:</span> <span class="string">Baiduspider</span>   <span class="comment"># 百度，你被完全屏蔽了</span></span><br><span class="line"><span class="attr">Disallow:</span> <span class="string">/</span></span><br><span class="line"></span><br><span class="line"><span class="attr">User-Agent:</span> <span class="string">Googlebot</span>     <span class="comment"># 对google和bing开放</span></span><br><span class="line"><span class="attr">Allow:</span> <span class="string">/item.htm</span></span><br><span class="line"></span><br><span class="line"><span class="attr">User-agent:</span> <span class="string">Bingbot</span></span><br><span class="line"><span class="attr">Allow:</span> <span class="string">/item.htm</span></span><br></pre></td></tr></table></figure><p>搜索示例：</p><ol><li>关键词搜索 - 百度<ul><li><code>洗面奶 淘宝</code> 搜不到淘宝的商品。</li><li><code>洗面奶 京东</code> 能搜到京东的商品。</li></ul></li><li>站点搜索 - 百度<ul><li><code>site:www.taobao.com 洗面奶</code> 竟然能搜索<code>www.taobao.com/product/</code>中的页面，点进去是无效商品链接</li><li><code>site:www.jd.com 洗面奶</code> 能搜到京东的商品</li></ul></li></ol><h3 id="京东-屏蔽一淘-阿里-惠惠-网易"><a href="#京东-屏蔽一淘-阿里-惠惠-网易" class="headerlink" title="京东 - 屏蔽一淘(阿里) 惠惠(网易)"></a>京东 - 屏蔽一淘(阿里) 惠惠(网易)</h3><p>京东和阿里向来水火不容，京东不准用户使用支付宝支付，也因为新浪和阿里的关系不准用户用新浪微博登录。2011年10月，京东和当年淘宝屏蔽百度一样，毅然屏蔽了一淘搜索。失去京东这么大的一个电商平台，一淘可谓流年不顺。</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">User-agent:</span> <span class="string">*</span></span><br><span class="line"><span class="attr">Disallow:</span> <span class="string">/?*</span></span><br><span class="line"><span class="attr">Disallow:</span> <span class="string">/pop/*.html</span></span><br><span class="line"><span class="attr">Disallow:</span> <span class="string">/pinpai/*.html?*</span></span><br><span class="line"></span><br><span class="line"><span class="attr">User-agent:</span> <span class="string">EtaoSpider</span>  <span class="comment"># 屏蔽一淘</span></span><br><span class="line"><span class="attr">Disallow:</span> <span class="string">/</span></span><br><span class="line"></span><br><span class="line"><span class="attr">User-agent:</span> <span class="string">HuihuiSpider</span> <span class="comment"># 屏蔽惠惠购物助手</span></span><br><span class="line"><span class="attr">Disallow:</span> <span class="string">/</span></span><br></pre></td></tr></table></figure><p>阿里旗下自家的比价产品一淘网曾因抓取京东的商品数据而被京东通过代码进行干扰，刘强东亦亲自出来抨击一淘网，但是嘴仗一时痛快，最终的结果却是一淘至今仍然可以索引京东，而京东的抗争只能是停止与支付宝的合作。</p><p>为什么taobao不屏蔽惠惠购物助手？</p><p>这是阿里抛出的交易筹码，即如果比价软件想要全年抓取天猫淘宝等站的数据，作为与我这边发放通行证的交换，比价软件需要遵从的是在“双十一”期间主动阉割，否则就会尝到终身制的闭门羹。</p><p>参考—<a href="https://www.zhihu.com/question/37369996" target="_blank" rel="noopener">如何看待惠惠购物助手被迫在双十一期间停止比价功能？</a></p><h3 id="amazon"><a href="#amazon" class="headerlink" title="amazon"></a>amazon</h3><h2 id="社交网络-媒体"><a href="#社交网络-媒体" class="headerlink" title="社交网络/媒体"></a>社交网络/媒体</h2><h3 id="QQ空间"><a href="#QQ空间" class="headerlink" title="QQ空间"></a>QQ空间</h3><p>QQ空间自05年诞生时就没有开放给百度与谷歌，和Facebook一样封闭。QQ的逻辑是要将QQ空间打造成一个巨大的闭环，唯一的搜索只能是旗下的搜搜。</p><p>2012年的时候，QQ空间也终于向百度与谷歌开放。</p><p>现在网友多数将自己的空间设置的为加密空间、非好友不能访问，所以里面的日志是没办法搜索；</p><h3 id="新浪微博"><a href="#新浪微博" class="headerlink" title="新浪微博"></a>新浪微博</h3><h3 id="微信公众平台-屏蔽所有"><a href="#微信公众平台-屏蔽所有" class="headerlink" title="微信公众平台 - 屏蔽所有"></a>微信公众平台 - 屏蔽所有</h3><p>微信做了公众账号后，积累了大量高质量的作者和文章。为了对这种优质数据进行独家保护，微信利用robot协议，不允许所有搜索引擎进行内容抓取。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">User-Agent:</span> <span class="string">*</span></span><br><span class="line"><span class="attr">Allow:</span> <span class="string">/$</span></span><br><span class="line"><span class="attr">Allow:</span> <span class="string">/debug/</span>   <span class="comment"># 微信公众平台接口调试工具</span></span><br><span class="line"><span class="attr">Allow:</span> <span class="string">/qa/</span>  </span><br><span class="line"><span class="attr">Allow:</span> <span class="string">/wiki/</span></span><br><span class="line"><span class="attr">Allow:</span> <span class="string">/cgi-bin/loginpage</span></span><br><span class="line"><span class="attr">Disallow:</span> <span class="string">/</span>     <span class="comment"># 公众号文章</span></span><br></pre></td></tr></table></figure><p>后来，腾讯投资搜狗，开放微信数据供搜狗搜索独家使用，<a href="http://weixin.sogou.com/" target="_blank" rel="noopener">搜狗 微信搜素</a>，将微信的公众号文章嵌入了搜狗搜索中。</p><h2 id="Facebook-屏蔽谷歌搜索"><a href="#Facebook-屏蔽谷歌搜索" class="headerlink" title="Facebook -  屏蔽谷歌搜索"></a>Facebook -  屏蔽谷歌搜索</h2><p>Facebook屏蔽谷歌的原因也很简单，用户在Facebook上产生的内容势必会有能够带来商业价值的数据并且同时也涉及到用户隐私，所以Facebook也同样不会将这些数据轻易交付给第三方的。facebook至今仍然屏蔽谷歌搜索。</p><h2 id="新闻站点"><a href="#新闻站点" class="headerlink" title="新闻站点"></a>新闻站点</h2><h3 id="默多克旗下新闻-屏蔽谷歌搜索，后来又开放"><a href="#默多克旗下新闻-屏蔽谷歌搜索，后来又开放" class="headerlink" title="默多克旗下新闻 - 屏蔽谷歌搜索，后来又开放"></a>默多克旗下新闻 - 屏蔽谷歌搜索，后来又开放</h3><p>从传统媒体起家的默多克，对于搜索引擎的态度相当不友善，默多克曾说<code>搜索引擎是“网络寄生虫”</code>。</p><p>默多克原话“他们是Google,他们是微软,他们是Ask.com,他们不应该免费获得内容,我想我们一直睡着了.”而默多克在09年开始展开计划，对谷歌等搜索引擎展开行动，对旗下多家新闻网站屏蔽搜索爬虫。</p><p>谷歌的回应也很简单明了”如果贵站不想在谷歌上出现，请修改贵站的robots文件即可“。不过到了2012年，默多克就投降了，<code>默多克向谷歌认输，重新允许搜索抓取报纸网站</code>。其实默多克的想法还是停留在传统的付费阅读的思维上，缺少对网络的深刻洞察。</p><h2 id="搜索引擎-互相屏蔽-偷抓"><a href="#搜索引擎-互相屏蔽-偷抓" class="headerlink" title="搜索引擎 - 互相屏蔽 - 偷抓"></a>搜索引擎 - 互相屏蔽 - 偷抓</h2><p>sogou、baidu、360、google</p><p><a href="http://tech.163.com/14/0807/12/A31UJS5P000915BD.html" target="_blank" rel="noopener">百度诉360违反Robots协议 一审判360赔偿70万</a><br>360方面认为，Robots协议并不具有任何法律效力，而是百度利用了Robots协议自设白名单，谷歌、微软必应、雅虎、搜狗、SOSO等搜索引擎均可以抓取这些内容，唯独禁止360搜索抓取，属于打压竞争对手，涉嫌违反《反垄断法》。</p><p><a href="http://lusongsong.com/blog/post/1472.html" target="_blank" rel="noopener">网曝百度不顾robots协议擅自抓取微信内容</a> baidu通过大量抓取<a href="weixin.sogou.com">搜狗中的微信数据</a>，将其放入搜索结果中，用于提升自己的搜索体验。</p><p><a href="https://www.zhihu.com/question/38937716" target="_blank" rel="noopener">百度违反 Robots 协议抓搜狗数据，有图有真相有撕逼 - 知乎</a></p><p>搜狗与360曾互诉对方不正当竞争，并提出千万级别的索赔。</p><p>sogou偷爬baidu，baidu偷爬搜狗</p><p><a href="http://weixin.sogou.com" target="_blank" rel="noopener">http://weixin.sogou.com</a></p><p><a href="http://lusongsong.com/reed/732.html" target="_blank" rel="noopener">2013年，百度诉奇虎360违反“Robots协议”抓取、复制其网站内容的不正当竞争行为一案，索赔金额高达一亿元</a></p><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="https://www.huxiu.com/article/21696.html" target="_blank" rel="noopener">虎嗅-盘点那些robots的屏蔽恩怨历史</a></p><h1 id="如果搜索引擎不遵守robot协议呢？"><a href="#如果搜索引擎不遵守robot协议呢？" class="headerlink" title="如果搜索引擎不遵守robot协议呢？"></a>如果搜索引擎不遵守robot协议呢？</h1><p>搜索引擎不遵守robot协议，对网站都抓，会违法吗？</p><p>robot协议是规定还是法律，不遵守robot协议是道德问题还是法律问题？<br>robots.txt 协议不是法律法规，也不是行业规范。但是一个搜索引擎声称自己遵守 robots.txt 协议那就有道德责任遵守。</p><h2 id="ss"><a href="#ss" class="headerlink" title="ss"></a>ss</h2><h1 id="如何在技术上反爬虫"><a href="#如何在技术上反爬虫" class="headerlink" title="如何在技术上反爬虫"></a>如何在技术上反爬虫</h1><p>检查UA</p><h1 id="s"><a href="#s" class="headerlink" title="s"></a>s</h1>]]></content>
      
      <categories>
          
          <category> CS </category>
          
          <category> web </category>
          
          <category> site-dev </category>
          
          <category> seo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> web </tag>
            
            <tag> 搜索引擎 </tag>
            
            <tag> 域名 </tag>
            
            <tag> robot协议 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>如何解决百度爬虫无法爬取搭建在Github上的个人博客的问题</title>
      <link href="/pub/51a8c99e/"/>
      <url>/pub/51a8c99e/</url>
      <content type="html"><![CDATA[<h2 id="现状-amp-原因"><a href="#现状-amp-原因" class="headerlink" title="现状 &amp; 原因"></a>现状 &amp; 原因</h2><h3 id="github做了什么。"><a href="#github做了什么。" class="headerlink" title="github做了什么。"></a>github做了什么。</h3><ul><li><code>robots.txt</code> 中屏蔽了baidu</li><li>即使百度爬虫无视robots协议强抓github，github也会通过<code>检查UA</code>，返回<code>403 forbidden</code>，即<code>拒绝访问</code>。(当然如果要想强抓是拦不住的，伪装一下UA即可)</li></ul><h3 id="造成的现状"><a href="#造成的现状" class="headerlink" title="造成的现状"></a>造成的现状</h3><ul><li>robots.txt 失效</li><li>sitemap 失效</li></ul><blockquote><p>原因：github在robots.txt中屏蔽了百度，百度默认不抓取github的内容。</p></blockquote><ul><li>主动提交失效</li><li>自动提交失效</li><li>手动提交失效</li></ul><blockquote><p>Github是通过 UA 来判定百度爬虫并返回 403 Forbidden 的</p><p>而百度爬虫的UA一般固定为 Mozilla/5.0 (compatible; Baiduspider/2.0; +<a href="http://www.baidu.com/search/spider.html" target="_blank" rel="noopener">http://www.baidu.com/search/spider.html</a>)</p><p>即使向百度提交了页面，github服务器一看UA是百度爬虫，就直接拒绝访问</p></blockquote><h3 id="如何解决"><a href="#如何解决" class="headerlink" title="如何解决"></a>如何解决</h3><ol><li>换其他host服务器，比如coding.net</li><li>CDN<ul><li>百度爬虫不要直接向 Github 的服务器发送请求，而是通过 CDN 边缘服务器的缓存来抓取网站的内容。边缘服务器本身是不会关心 UA 的，所以问题就迎刃而解了。</li><li><a href="http://jerryzou.com/posts/feasibility-of-allowing-baiduSpider-for-Github-Pages/" target="_blank" rel="noopener">也不靠谱</a></li><li><a href="https://www.dozer.cc/2015/06/github-pages-and-cdn.html" target="_blank" rel="noopener">https://www.dozer.cc/2015/06/github-pages-and-cdn.html</a></li></ul></li></ol><p><a href="https://www.zhihu.com/question/30898326" target="_blank" rel="noopener">https://www.zhihu.com/question/30898326</a></p>]]></content>
      
      <categories>
          
          <category> CS </category>
          
          <category> web </category>
          
          <category> site-dev </category>
          
          <category> seo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 爬虫 </tag>
            
            <tag> 搜索引擎 </tag>
            
            <tag> robots协议 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>经典的web编辑器--CKEditor</title>
      <link href="/pub/fae97115/"/>
      <url>/pub/fae97115/</url>
      <content type="html"><![CDATA[<h1 id="快速搭建CKEditor"><a href="#快速搭建CKEditor" class="headerlink" title="快速搭建CKEditor"></a>快速搭建CKEditor</h1><p><a href="https://cdn.ckeditor.com/" target="_blank" rel="noopener">CKEditor CDN</a></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"utf-8"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">title</span>&gt;</span>CKEditor<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"https://cdn.ckeditor.com/4.8.0/standard/ckeditor.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">textarea</span> <span class="attr">name</span>=<span class="string">"editor1"</span>&gt;</span><span class="tag">&lt;/<span class="name">textarea</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="undefined">CKEDITOR.replace( 'editor1' );</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>保存为html，双击打开即可。<br><a href="https://blog.eson.org/demos/ckeditor/">Online Demo</a></p><h1 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h1><p><a href="https://github.com/ckeditor/ckeditor-dev" target="_blank" rel="noopener">https://github.com/ckeditor/ckeditor-dev</a></p><h2 id="CKFinder"><a href="#CKFinder" class="headerlink" title="CKFinder"></a>CKFinder</h2><p>没有CKFinder，CKEditor作为一个编辑器，也是可以正常使用的，但是无法在编辑器里浏览服务器上的用户上传文件。所以要整合CKFinder。</p><p>需要后台服务器。(用于文件上传、存储)。支持java php .net等语言</p><h1 id="其他编辑器"><a href="#其他编辑器" class="headerlink" title="其他编辑器"></a>其他编辑器</h1><ul><li>Tinymce</li><li>为知笔记也不错，但不开源</li></ul><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.ibm.com/developerworks/cn/web/1012_moying_ckeditor/index.html" target="_blank" rel="noopener">https://www.ibm.com/developerworks/cn/web/1012_moying_ckeditor/index.html</a></p>]]></content>
      
      <categories>
          
          <category> CS </category>
          
          <category> tools </category>
          
          <category> formatting </category>
          
          <category> html-富文本编辑器 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>路由器</title>
      <link href="/pub/5799c0b3/"/>
      <url>/pub/5799c0b3/</url>
      <content type="html"><![CDATA[<h3 id="路由器是怎样做到连接不同网络的？用到的关键技术有什么？"><a href="#路由器是怎样做到连接不同网络的？用到的关键技术有什么？" class="headerlink" title="路由器是怎样做到连接不同网络的？用到的关键技术有什么？"></a>路由器是怎样做到连接不同网络的？用到的关键技术有什么？</h3><p>路由器的好处是为不同类型的物理网络提供连接：以太网、令牌环网、点对点的链接和FDDI（光纤分布式数据接口）等等。</p><p>现在网关这个术语只用来表示应用层网关：一个连接两种不同协议族的进程（例如，TCP/IP和IBM的SNA），它为某个特定的应用程序服务（常常是电子邮件或文件传输）。</p><p>不在同一</p><p><img title="路由器连接两个网络" alt="="路由器连接两个网络"" src="/images/raw/TCP%20IP%20-%20%E8%B7%AF%E7%94%B1%E5%99%A8%E8%BF%9E%E6%8E%A5%E4%B8%A4%E4%B8%AA%E7%BD%91%E7%BB%9C%20-%20TCPIP%E8%AF%A6%E8%A7%A3.PNG">  </p><p>应用层和运输层使用端到端（End-to-end）协议。在<br>图中，只有端系统需要这两层协议。但是，网络层提供的却是逐跳（ Hop-by-hop）协议，两个端系统和每个中间系统都要使用它。</p>]]></content>
      
      <categories>
          
          <category> CS </category>
          
          <category> network </category>
          
          <category> 网络协议-OSI七层模型 </category>
          
          <category> 5. 第三层 网络层 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>网络分层</title>
      <link href="/pub/5e6131fb/"/>
      <url>/pub/5e6131fb/</url>
      <content type="html"><![CDATA[<h2 id="Overview"><a href="#Overview" class="headerlink" title="Overview"></a>Overview</h2><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><table border="1" cellpadding="1" cellspacing="1"><thead><tr><th scope="row">&nbsp;</th><th scope="col">数据单元/格式</th><th scope="col">TCP/IP层</th><th scope="col">OSI层</th><th scope="col">功能</th><th scope="col">TCP/IP协议族</th><th scope="col">典型设备</th></tr></thead><tbody><tr><th colspan="1" rowspan="4" scope="row">主机层</th><td colspan="1" rowspan="3">Dagta(数据)</td><td colspan="1" rowspan="3">应用层</td><td>7. 应用层</td><td>网络进程到应用程序。针对特定应用规定各层协议、时序、表示等，进行封装。在端系统中用软件来实现，如HTTP等</td><td>DHCP、Telnet、FTP、HTTP、SNMP、DNS</td><td>网关</td></tr><tr><td>6. 表示层</td><td>数据表示形式，加密和解密，把机器相关的数据转换成独立于机器的数据。规定数据的格式化表示，数据格式的转换等</td><td>&nbsp;</td><td>&nbsp;</td></tr><tr><td>5. 会话层</td><td>主机间通讯，管理应用程序之间的会话。规定通信时序；数据交换的定界、同步，创建检查点等</td><td>&nbsp;</td><td>&nbsp;</td></tr><tr><td>Segments(数据段)</td><td>传输层</td><td>4. 传输层</td><td>在网络的各个节点之间可靠的分发数据包。所有传输遗留问题；复用；流量控制；可靠</td><td>TCP UDP TLS/SSL</td><td>&nbsp;</td></tr><tr><th colspan="1" rowspan="3" scope="row">媒介层</th><td>&nbsp;</td><td>网络层 Internet</td><td>3. 网络层</td><td>负责IP地址。在网络的各个节点之间进行地址分配、路由和(不一定可靠的)分发报文。路由(IP寻址)；拥塞控制分割和重新组合数据包</td><td>IP ICMP BGP RIP</td><td>路由器</td></tr><tr><td>Bit/Frame数据帧</td><td colspan="1" rowspan="2">链路层</td><td>2. 数据链路层</td><td>负责MAC地址。一个可靠的点对点数据直链。检错与纠错(CRC码)；多路访问；寻址</td><td>WiFi ARP</td><td>交换机、网桥、网卡</td></tr><tr><td>Bit 比特流</td><td>1.物理层</td><td>一个(不一定可靠的)点对点数据直链。定义机械特性；电气特性；功能特性；过程特性</td><td>&nbsp;</td><td>调制解调器、中继器、集线器、同轴电缆、双绞线</td></tr></tbody></table><p><a href="https://en.wikipedia.org/wiki/Internet_protocol_suite" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Internet_protocol_suite</a></p><p><a href="https://www.novell.com/documentation/nw65/ntwk_ipv4_nw/data/hbnuubtt.html" target="_blank" rel="noopener">Overview of TCP/IP Protocol</a></p><image src="/images/raw/TCP%20IP%20-%204LayerModel%20-%20novell.com.gif"><h2 id="Architectural-Overview-of-the-TCP-IP-Protocol-Suite"><a href="#Architectural-Overview-of-the-TCP-IP-Protocol-Suite" class="headerlink" title="Architectural Overview of the TCP/IP Protocol Suite"></a><a href="https://technet.microsoft.com/en-us/library/bb726993.aspx" target="_blank" rel="noopener">Architectural Overview of the TCP/IP Protocol Suite</a></h2><image src="/images/raw/TCP%20IP%20-%20architecture%20-%20Microsoft.gif"><h2 id="Overview-of-TCP-IP-protocols-摘自《Unix网络编程-chapter2》"><a href="#Overview-of-TCP-IP-protocols-摘自《Unix网络编程-chapter2》" class="headerlink" title="Overview of TCP/IP protocols,摘自《Unix网络编程 chapter2》"></a>Overview of TCP/IP protocols,摘自《Unix网络编程 chapter2》</h2><image src="/images/raw/TCP%20IP%20-%20overview%20-%20unix%20network%20programing.gif"><h2 id="七层-应用层"><a href="#七层-应用层" class="headerlink" title="七层 应用层"></a>七层 应用层</h2><p>应用层（Application Layer）提供为应用软件而设的界面，以设置与另一应用软件之间的通信。<br>针对某个特定的用户应用程序（FTP、Telnet等）<br>比如</p><ul><li>HTTP Client与HTTP Server通信。</li><li>DNS client与DNS Server通信。</li></ul><h2 id="六层-表示层"><a href="#六层-表示层" class="headerlink" title="六层 表示层"></a>六层 表示层</h2><p>表示层（Presentation Layer）把数据转换为能与接收者的系统格式兼容并适合传输的格式。</p><h2 id="五层-会话层"><a href="#五层-会话层" class="headerlink" title="五层 会话层"></a>五层 会话层</h2><p>会话层（Session Layer）负责在数据传输中设置和维护电脑网络中两台电脑之间的通信连接。</p><h2 id="四层-传输层"><a href="#四层-传输层" class="headerlink" title="四层 传输层"></a>四层 传输层</h2><p>传输层（Transport Layer）把传输表头（TH）加至数据以形成数据包。传输表头包含了所使用的协议等发送信息。例如:传输控制协议（TCP）等。</p><p>TCP使用不可靠的IP服务，但是它提供一种可靠的运输层服务；UDP为应用程序接收和发送数据报。但是UDP是不可靠的，它不保证数据报能安全无误的到达目的地。</p><h2 id="三层-网络层"><a href="#三层-网络层" class="headerlink" title="三层 网络层"></a>三层 网络层</h2><p>在计算机网络中进行通信的两个计算机之间可能会经过很多个数据链路，也可能还要经过很多通信子网。网络层的任务就是选择合适的网间路由和交换结点，确保数据及时传送。网络层将解封数据链路层收到的帧，提取数据包，包中封装有网络层包头，其中含有逻辑地址信息- -源站点和目的站点地址的网络地址。</p><p>IP是网际层的主要协议，同时被TCP和UDP使用；ICMP是IP的附属协议。IP层用它来与其他主机或路由器交换错误报文和其他重要的信息；IGMP是Internet组管理协议。它用来把一个UDP数据报多播到多个主机。</p><p>数据的路径选择(分组的<code>选路</code>)、转发，将网络表头（NH）加至数据包，以形成分组。网络表头包含了网络数据。例如:互联网协议（IP）等。</p><h3 id="寻址"><a href="#寻址" class="headerlink" title="寻址"></a>寻址</h3><p>路由器<code>根据IP地址进行寻址</code>，通过路由表路由协议产生</p><p>对网络层而言使用IP地址来唯一标识互联网上的设备，网络层依靠IP地址进行相互通信。</p><h3 id="路由-转发"><a href="#路由-转发" class="headerlink" title="路由/转发"></a>路由/转发</h3><p>在同一个网络中的内部通信并不需要网络层设备，仅仅靠数据链路层就可以完成相互通信，对于不同的网络之间相互通信则必须借助路由器等三层设备。</p><p>数据包的转发，<code>不在同一个局域网</code>，他们彼此之间是不认识的，那么就不得不通过其他媒介，寻找到适当的方式才可以传输数据。</p><h2 id="二层-链路层"><a href="#二层-链路层" class="headerlink" title="二层 链路层"></a>二层 链路层</h2><p>二层<code>交换</code>，只能解决<code>同一个局域网</code>(彼此认识，mac地址)内的数据交换。</p><p><code>物理地址寻址</code>、数据的成帧、流量控制、数据的检错、重发等</p><p>网络层（Network Layer）决定数据的路径选择和转寄，将网络表头（NH）加至数据包，以形成分组。网络表头包含了网络数据。例如:互联网协议（IP）等。</p><p>设备驱动程序及接口卡</p><p>ARP（地址解析协议）和RARP（逆地址解析协议）是某些网络接口使用的特殊协议，用来转换IP层和网络接口层使用的地址。</p><p>交换机<code>根据MAC地址寻址</code>，通过站表选择路由，站表的建立和维护由交换机自动进行</p><h2 id="一层-物理层"><a href="#一层-物理层" class="headerlink" title="一层 物理层"></a>一层 物理层</h2><p>物理层（Physical Layer）在局部局域网上传送帧，它负责管理电脑通信设备和网络媒体之间的互通。包括了针脚、电压、线缆规范、集线器、中继器、网卡、主机适配器等</p><h2 id="疑问"><a href="#疑问" class="headerlink" title="疑问"></a>疑问</h2><p><strong>为什么要平行层通信？</strong><br>因为其它层看不懂该协议。(其他协议看不懂)</p><p>我觉得，也可以理解成相邻层之间的协议。比如</p><p>web中的后台与前台协定的数据格式，是不同层之间的协议。因为后台数据是给前台用的，前台http。</p><p>网络协议中，相邻层之间的</p><p><strong>VPN算在哪个层？算网路协议吗？</strong><br>按道理应该算协议，客户端和服务端都要遵守的约定。应该算在应用层吧。—by xs</p><p>vpn在IP层工作，而ss在TCP层工作</p><p><strong>proxy</strong>算在哪个层？<br>应用层吧，至少socket之上</p><p><strong>html5提出的websocket协议</strong><br>属于应用层</p><h2 id="待看-其他参考"><a href="#待看-其他参考" class="headerlink" title="待看/其他参考"></a>待看/其他参考</h2><ul><li><a href="https://zh.wikipedia.org/wiki/OSI模型" target="_blank" rel="noopener">OSI-7层模型-wiki</a></li><li><a href="https://zh.wikipedia.org/wiki/网络传输协议" target="_blank" rel="noopener">网络传输协议-四层模型-wiki</a></li><li><a href="https://www.zhihu.com/question/38517040" target="_blank" rel="noopener">所有的网络请求底层协议是不是都是TCP/IP？</a></li><li><a href="https://uploadfiles.nowcoder.net/images/20170810/1767727_1502362836481_1CFEC006B29CBAEA6AFED26AB43D16A7" target="_blank" rel="noopener">ss</a></li></ul></image></image></image>]]></content>
      
      <categories>
          
          <category> CS </category>
          
          <category> network </category>
          
          <category> 网络协议-OSI七层模型 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> network </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>反演 百度DNS解析规则</title>
      <link href="/pub/b7c755c3/"/>
      <url>/pub/b7c755c3/</url>
      <content type="html"><![CDATA[<!--反函数：inverse function (or anti-function[1]) is a function that "reverses" another function反编译：DNS解析：host--ip，，DNS的逆应该是ip--host.ARP（地址解析协议） RARP（逆地址解析协议），DNS中是不是也有逆？正向 ：DNS解析规则 -- 解析结果。逆向：解析结果--解析规则--><h2 id="Overview"><a href="#Overview" class="headerlink" title="Overview"></a>Overview</h2><p>域名系统（DNS）是一种用于 TCP/IP应用程序的分布式数据库，它提供主机名字和IP地址之间的转换及有关电子邮件的选路信息。</p><p>通常情况下，我们是先设定DNS解析规则，然后ISP(供应商)依据指定的解析规则进行DNS解析。同样，我们通过测试解析结果，也可以反推DNS解析规则。本文以百度首页为例，分析其DNS解析规则。</p><p>DNS地址解析器的核心功能能</p><ul><li>gethostbyname  主机名—&gt;ip   </li><li>gethostbyaddr  ip—主机名</li></ul><p><strong>分析方式一：</strong><br>通过抓包，分析DNS查询和响应报文。每个响应报文对应一条DNS解析规则，通过一条或者多条记录才能完成DNS解析。</p><p><strong>分析方式二：</strong><br>一堆命令，见参考博客。</p><p>参考 <a href="https://aslibra.com/blog/post/use_dig_dns_check.php" target="_blank" rel="noopener">https://aslibra.com/blog/post/use_dig_dns_check.php</a><br><a href="https://www.jianshu.com/p/71f61652ec23" target="_blank" rel="noopener">通过dig命令理解DNS</a><br><a href="http://roclinux.cn/?p=2449" target="_blank" rel="noopener">dig挖出DNS的秘密</a></p><h2 id="百度DNS解析规则"><a href="#百度DNS解析规则" class="headerlink" title="百度DNS解析规则"></a>百度DNS解析规则</h2><div class="table-container"><table><thead><tr><th>编号</th><th>主机记录</th><th>记录类型</th><th>解析线路(isp)</th><th>记录值</th><th>TTL值(不定)</th><th>备注</th><th></th></tr></thead><tbody><tr><td>1</td><td>www.baidu.com</td><td>CNAME</td><td>—</td><td>www.a.shifen.com</td><td>268</td><td></td><td></td></tr><tr><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>2</td><td>www.a.shifen.com</td><td>CNAME</td><td>—</td><td>www.wshifen.com</td><td>271</td><td></td><td></td></tr><tr><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>3</td><td>www.wshifen.com</td><td>A</td><td>新加坡 百度</td><td>45.113.192.101</td><td>160</td><td>“1-2-[3</td><td>4]”</td></tr><tr><td>4</td><td>www.wshifen.com</td><td>A</td><td>北京电信</td><td>220.181.111.188</td><td>160</td><td></td><td></td></tr><tr><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td></td><td>wshifen.com</td><td>NS</td><td>—</td><td>ns1.wshifen.com</td><td>163</td><td>很多name server</td><td></td></tr><tr><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td></td><td>baidu.com</td><td>A</td><td>北京移动</td><td>111.13.101.208</td><td></td><td>见解析方式二</td><td></td></tr><tr><td></td><td>baidu.com</td><td>A</td><td>北京联通…</td><td>123.125.114.144</td><td></td><td></td><td></td></tr><tr><td></td><td>baidu.com</td><td>SOA</td><td>—</td><td>dns.baidu.com</td><td>900</td><td>见解析方式四</td><td></td></tr><tr><td></td><td>baidu.com</td><td>NS</td><td>—</td><td>ns1.baidu.com</td><td></td><td></td><td></td></tr><tr><td></td><td>baidu.com</td><td>NS</td><td>—</td><td>ns2.baidu.com</td><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td></td><td>dns.baidu.com</td><td>A</td><td></td><td>202.108.22.220</td><td>67498</td><td>这里只有一个A记录吗？为什么TTL这么高？</td><td></td></tr><tr><td></td><td>ns1.baidu.com</td><td>A</td><td></td><td>202.108.22.220</td><td>27780</td><td>为什么和上个记录同IP？</td><td></td></tr><tr><td></td><td>ns2.baidu.com</td><td>A</td><td></td><td>61.135.165.235</td><td>86400</td><td></td><td></td></tr><tr><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td></td><td>shifen.com.</td><td>NS</td><td></td><td>ns1.baidu.com</td><td></td><td></td><td></td></tr><tr><td></td><td>shifen.com.</td><td>A</td><td></td><td>202.108.250.218</td><td></td><td></td><td></td></tr><tr><td></td><td>shifen.com</td><td>SOA</td><td></td><td>dns.shifen.com</td><td></td><td>dig shifen.com soa</td><td></td></tr><tr><td></td><td>dns.shifen.com</td><td>A</td><td></td><td>202.108.250.228</td><td></td><td>dig dns.shifen.com</td><td></td></tr><tr><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td></td><td>a.shifen.com</td><td>NS</td><td>—</td><td>ns1.a.shifen.com</td><td>397</td><td>见解析方式五</td><td></td></tr><tr><td></td><td>ns1.a.shifen.com</td><td>A</td><td></td><td>61.135.165.224</td><td>600</td><td></td></tr></tbody></table></div><blockquote><p>注：所有解析路线由ip.cn提供。</p></blockquote><p>www.wshifen.com  没有NS记录，没有SOA记录。<br><code>dig www.wshifen.com ns</code>。没有answer，即没有ns记录<br><code>dig wshifen.com ns</code>，有answer</p><p>解析方式一: 1—&gt;2 （www.baidu.com，查询类型A，即查询IPv4地址）<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 一会功夫变成102了</span></span><br><span class="line"><span class="comment"># DNS响应一般为多个ip，后续连接只用一个ip</span></span><br><span class="line">$ ping www.baidu.com</span><br><span class="line">PING www.wshifen.com (45.113.192.102) 56(84) bytes of data.</span><br><span class="line">64 bytes from 45.113.192.102: icmp_seq=1 ttl=43 time=87.3 ms</span><br><span class="line"></span><br><span class="line">$ wget www.baidu.com</span><br><span class="line">--2018-03-08 11:30:32--  http://www.baidu.com/</span><br><span class="line">Resolving www.baidu.com (www.baidu.com)... 45.113.192.102, 45.113.192.101</span><br><span class="line">Connecting to www.baidu.com (www.baidu.com)|45.113.192.102|:80... connected.</span><br><span class="line">HTTP request sent, awaiting response... 200 OK</span><br><span class="line"></span><br><span class="line">$ dig www.baidu.com</span><br><span class="line">;; QUESTION SECTION:</span><br><span class="line">;www.baidu.com.                 IN      A</span><br><span class="line"></span><br><span class="line">;; ANSWER SECTION:</span><br><span class="line">www.baidu.com.          337     IN      CNAME   www.a.shifen.com.</span><br><span class="line">www.a.shifen.com.       191     IN      CNAME   www.wshifen.com.</span><br><span class="line">www.wshifen.com.        110     IN      A       45.113.192.102</span><br><span class="line">www.wshifen.com.        110     IN      A       45.113.192.101</span><br></pre></td></tr></table></figure></p><p>解析方式二：9  （baidu.com，查询类型A）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 这种域名一般情况下是不能做cname解析的，只能用A记录</span></span><br><span class="line">$ ping baidu.com</span><br><span class="line">PING baidu.com (111.13.101.208) 56(84) bytes of data.</span><br><span class="line">64 bytes from 111.13.101.208: icmp_seq=1 ttl=45 time=13.8 ms</span><br><span class="line"></span><br><span class="line"><span class="comment"># DNS中没有对baidu.com做CNAME记录，貌似。</span></span><br><span class="line"><span class="comment"># 为什么浏览器重定向到http://www.baidu.com/？ 后面章节会介绍</span></span><br><span class="line">$ wget baidu.com</span><br><span class="line">--2018-03-08 11:32:10--  http://baidu.com/</span><br><span class="line">Resolving baidu.com (baidu.com)... 111.13.101.208, 220.181.57.216</span><br><span class="line">Connecting to baidu.com (baidu.com)|111.13.101.208|:80... connected.</span><br><span class="line">HTTP request sent, awaiting response... 200 OK</span><br><span class="line"></span><br><span class="line"><span class="comment">#</span></span><br><span class="line">$ dig baidu.com</span><br><span class="line">;; QUESTION SECTION:</span><br><span class="line">;baidu.com.                     IN      A</span><br><span class="line"></span><br><span class="line">;; ANSWER SECTION:</span><br><span class="line">baidu.com.              345     IN      A       111.13.101.208</span><br><span class="line">baidu.com.              345     IN      A       220.181.57.216</span><br></pre></td></tr></table></figure><p>解析方式三: 1—&gt;5—&gt;8  （www.baidu.com，查询类型AAAA，即查询IPv6地址）</p><p>请求路线：</p><ul><li>www.baidu.com 未找到AAAA记录，走CNAME记录1</li><li>www.a.shifen.com 未找到AAAA记录，走CNAME记录5</li><li>www.wshifen.com 找到NS记录，返回</li></ul><p>抓包内容<br><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 目前使用IPv6的还是极少数，所以得不到AAAA记录的。</span></span><br><span class="line"><span class="comment"># DNS响应报文中的资源记录部分：回答字段、授权字段和附加信息字段，均采用一种称为资源记录RR（ Resource Record）的相同格式。</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="string">Domain</span> <span class="string">Name</span> <span class="string">System</span> <span class="string">(response)</span></span><br><span class="line"><span class="attr">    Questions:</span> <span class="number">1</span></span><br><span class="line">    <span class="string">Answer</span> <span class="attr">RRs:</span> <span class="number">2</span></span><br><span class="line">    <span class="string">Authority</span> <span class="attr">RRs:</span> <span class="number">1</span></span><br><span class="line">    <span class="string">Additional</span> <span class="attr">RRs:</span> <span class="number">0</span></span><br><span class="line">    <span class="string">Queries</span></span><br><span class="line">        <span class="string">www.baidu.com:</span> <span class="string">type</span> <span class="string">AAAA,</span> <span class="string">class</span> <span class="string">IN</span></span><br><span class="line">    <span class="string">Answers</span> <span class="comment"># 回答字段</span></span><br><span class="line">        <span class="string">www.baidu.com:</span> <span class="string">type</span> <span class="string">CNAME,</span> <span class="string">class</span> <span class="string">IN,</span> <span class="string">cname</span> <span class="string">www.a.shifen.com</span></span><br><span class="line"><span class="attr">            Name:</span> <span class="string">www.baidu.com</span></span><br><span class="line"><span class="attr">            Type:</span> <span class="string">CNAME</span> <span class="string">(Canonical</span> <span class="string">NAME</span> <span class="string">for</span> <span class="string">an</span> <span class="string">alias)</span> <span class="string">(5)</span></span><br><span class="line"><span class="attr">            CNAME:</span> <span class="string">www.a.shifen.com</span></span><br><span class="line">        <span class="string">www.a.shifen.com:</span> <span class="string">type</span> <span class="string">CNAME,</span> <span class="string">class</span> <span class="string">IN,</span> <span class="string">cname</span> <span class="string">www.wshifen.com</span></span><br><span class="line"><span class="attr">            Name:</span> <span class="string">www.a.shifen.com</span></span><br><span class="line"><span class="attr">            Type:</span> <span class="string">CNAME</span> <span class="string">(Canonical</span> <span class="string">NAME</span> <span class="string">for</span> <span class="string">an</span> <span class="string">alias)</span> <span class="string">(5)</span></span><br><span class="line"><span class="attr">            Class:</span> <span class="string">IN</span> <span class="string">(0x0001)</span></span><br><span class="line">            <span class="string">Time</span> <span class="string">to</span> <span class="attr">live:</span> <span class="number">271</span></span><br><span class="line">            <span class="string">Data</span> <span class="attr">length:</span> <span class="number">14</span></span><br><span class="line"><span class="attr">            CNAME:</span> <span class="string">www.wshifen.com</span></span><br><span class="line">    <span class="string">Authoritative</span> <span class="string">nameservers</span>  <span class="comment"># 授权字段</span></span><br><span class="line">        <span class="string">wshifen.com:</span> <span class="string">type</span> <span class="string">SOA,</span> <span class="string">class</span> <span class="string">IN,</span> <span class="string">mname</span> <span class="string">ns1.wshifen.com</span></span><br><span class="line"><span class="attr">            Name:</span> <span class="string">wshifen.com</span></span><br><span class="line"><span class="attr">            Type:</span> <span class="string">SOA</span> <span class="string">(Start</span> <span class="string">Of</span> <span class="string">a</span> <span class="string">zone</span> <span class="string">of</span> <span class="string">Authority)</span> <span class="string">(6)</span></span><br><span class="line">            <span class="string">Primary</span> <span class="string">name</span> <span class="attr">server:</span> <span class="string">ns1.wshifen.com</span> <span class="string">baidu_dns_master.baidu.com</span></span><br></pre></td></tr></table></figure></p><p>dig 内容<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ dig www.baidu.com AAAA</span><br><span class="line">;; QUESTION SECTION:</span><br><span class="line">;www.baidu.com.                 IN      AAAA</span><br><span class="line"></span><br><span class="line">;; ANSWER SECTION:</span><br><span class="line">www.baidu.com.          4       IN      CNAME   www.a.shifen.com.</span><br><span class="line">www.a.shifen.com.       174     IN      CNAME   www.wshifen.com.</span><br><span class="line"></span><br><span class="line">;; AUTHORITY SECTION:</span><br><span class="line">wshifen.com.            250     IN      SOA     ns1.wshifen.com. baidu_dns_master.baidu.com. 1803080001 60 30 2592000 3600</span><br></pre></td></tr></table></figure></p><p>解析方式四：11  （baidu.com，查询类型AAAA）<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Domain Name System (response)</span><br><span class="line">    Questions: 1</span><br><span class="line">    Answer RRs: 0</span><br><span class="line">    Authority RRs: 1</span><br><span class="line">    Queries</span><br><span class="line">        baidu.com: <span class="built_in">type</span> AAAA, class IN</span><br><span class="line">    Authoritative nameservers</span><br><span class="line">        baidu.com: <span class="built_in">type</span> SOA, class IN, mname dns.baidu.com</span><br><span class="line">            Name: baidu.com</span><br><span class="line">            Type: SOA (Start Of a zone of Authority) (6)</span><br><span class="line">            Primary name server: dns.baidu.com</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ dig baidu.com AAAA</span><br><span class="line">;; QUESTION SECTION:</span><br><span class="line">;baidu.com.                     IN      AAAA</span><br><span class="line"></span><br><span class="line">;; AUTHORITY SECTION:</span><br><span class="line">baidu.com.              4581    IN      SOA     dns.baidu.com. sa.baidu.com. 2012138564 300 300 2592000 7200</span><br></pre></td></tr></table></figure><p>解析方式五: 12  （www.a.shifen.com，查询类型AAAA）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ dig www.a.shifen.com AAAA</span><br><span class="line">;; QUESTION SECTION:</span><br><span class="line">;www.a.shifen.com.              IN      AAAA</span><br><span class="line"></span><br><span class="line">;; ANSWER SECTION:</span><br><span class="line">www.a.shifen.com.       34      IN      CNAME   www.wshifen.com.</span><br><span class="line"></span><br><span class="line">;; AUTHORITY SECTION:</span><br><span class="line">wshifen.com.            235     IN      SOA     ns1.wshifen.com. baidu_dns_master.baidu.com. 1803080001 60 30 2592000 3600</span><br></pre></td></tr></table></figure></p><h2 id="疑问-amp-剖析"><a href="#疑问-amp-剖析" class="headerlink" title="疑问 &amp; 剖析"></a>疑问 &amp; 剖析</h2><h3 id="编号1中，别名www-a-shifen-com的作用"><a href="#编号1中，别名www-a-shifen-com的作用" class="headerlink" title="编号1中，别名www.a.shifen.com的作用"></a>编号1中，别名www.a.shifen.com的作用</h3><p>觉得没啥用啊。看看网上的说法：</p><ul><li>使用CNAME有个好处就是，我IP地址去做改动的时候不需要去DNS运营商上面做改动，只需要自己的服务器做改动就好，方便自己的域名与实际IP地址做对应。    —觉得没什么道理啊</li></ul><ul><li>百度弄的一个域名保护壳。？</li><li>CDN加速节点？</li></ul><p>逆向思维吧。如果没什么用，为什么要保留呢？是不是还有点作用？</p><h3 id="编号2-3中，多条A记录的作用"><a href="#编号2-3中，多条A记录的作用" class="headerlink" title="编号2,3中，多条A记录的作用"></a>编号2,3中，多条A记录的作用</h3><ul><li>可用于多线智能解析，为了每条线路（电信、联通/网通、移动等）上的用户都能最快访问站点</li><li>可用于简单的<a href="https://cloud.tencent.com/document/product/302/9069" target="_blank" rel="noopener">负载均衡</a>(dns轮询)</li><li>可HA(高可用)</li></ul><h3 id="关于返回主机-IP-的策略"><a href="#关于返回主机-IP-的策略" class="headerlink" title="关于返回主机(IP)的策略"></a>关于返回主机(IP)的策略</h3><p>考虑的因素有：</p><ul><li><a href="https://cloud.tencent.com/document/product/302/8643" target="_blank" rel="noopener">智能解析线路</a> 用户所在网络的网络运行商类型、区域</li><li>距离—跳数</li></ul><p>当我一个IP到DNS上面请求DNS域名解析的时候，DNS系统会根据你的IP地址所到达的域名对应的IP地址中路由跳数最小的那个IP地址作为访问的IP地址，具体你可以用LINUX的NSLOOKUP来查看域名所对应的IP地址，然后用PC的TRACERT的功能把所有DNS解析出来的IP地址进行跳数记录，然后在访问该域名，查看具体是哪个地址解析给你的PC。</p><h3 id="为什么无法直接访问www-a-shifen-com"><a href="#为什么无法直接访问www-a-shifen-com" class="headerlink" title="为什么无法直接访问www.a.shifen.com"></a>为什么无法直接访问www.a.shifen.com</h3><image src="/images/raw/HTTP%20-%20Wireshark%20-%20www.a.shifen.com.png"><p>流程：</p><ul><li>[x] [1,2,3,4] - DNS解析</li><li>[x] [5,6,7] - 三次握手，建立TCP连接</li><li>[x] [8] - 发送HTTP Get请求</li><li>[ ] [9] - 服务器返回RST复位信号，强制关闭TCP连接</li></ul><p>服务器成功收到了HTTP Get请求，后台逻辑认为这个连接不符合规范()。所谓baidu定义的规范那应该就是服务器检查host，非<code>baidu.com</code>或<code>s</code>就拒绝访问。</p><h3 id="抓包貌似看不到整个路由，是吗？如何分析整个路由？"><a href="#抓包貌似看不到整个路由，是吗？如何分析整个路由？" class="headerlink" title="抓包貌似看不到整个路由，是吗？如何分析整个路由？"></a>抓包貌似看不到整个路由，是吗？如何分析整个路由？</h3><p>。。</p><h3 id="为什么访问-baidu-com-会跳转到-www-baidu-com-？"><a href="#为什么访问-baidu-com-会跳转到-www-baidu-com-？" class="headerlink" title="为什么访问 baidu.com 会跳转到 www.baidu.com ？"></a>为什么访问 baidu.com 会跳转到 www.baidu.com ？</h3><p><code>baidu.com</code>返回的页面如下：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"refresh"</span> <span class="attr">content</span>=<span class="string">"0;url=http://www.baidu.com/"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>表示0秒之后跳转到<code>www.baidu.com</code>主页。这种叫做<code>HTML redirections</code>。并非30X 重定向。<a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Redirections" target="_blank" rel="noopener">参考</a></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.zhihu.com/question/36891472/answer/69455356" target="_blank" rel="noopener">https://www.zhihu.com/question/36891472/answer/69455356</a></p><p><a href="http://skyrover.me/2017/02/19/BAIDU%E7%9A%84DNS%E8%A7%A3%E6%9E%90/" target="_blank" rel="noopener">http://skyrover.me/2017/02/19/BAIDU%E7%9A%84DNS%E8%A7%A3%E6%9E%90/</a></p></image>]]></content>
      
      <categories>
          
          <category> CS </category>
          
          <category> network </category>
          
          <category> 网络协议-OSI七层模型 </category>
          
          <category> 1. 第七层 应用层 </category>
          
          <category> DNS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> network </tag>
            
            <tag> dns </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>矢量图的制作</title>
      <link href="/pub/ac890a3f/"/>
      <url>/pub/ac890a3f/</url>
      <content type="html"><![CDATA[<h2 id="矢量图制作"><a href="#矢量图制作" class="headerlink" title="矢量图制作"></a>矢量图制作</h2><p>入门级(并不低级)：</p><ul><li>powerpoint: 首先group元素，然后save as png/emf。如需要svg，可再用Inkscape转化。</li><li>visio:</li><li>Inkscape 功能貌似很强大，但我用过它的格式转化功能。<a href="https://colah.github.io/posts/2015-08-Understanding-LSTMs/" target="_blank" rel="noopener">实例图片</a></li></ul><p>专业级：</p><ul><li>Adobe Illustrator</li><li>Corel Draw</li><li><a href="http://www.texample.net/tikz/" target="_blank" rel="noopener">TeX and PGF/TikZ</a> <a href="https://github.com/MarkLodato/visual-git-guide" target="_blank" rel="noopener">示例</a></li></ul><h3 id="流程图"><a href="#流程图" class="headerlink" title="流程图"></a>流程图</h3><p>visio<br>iGrafx（流程图）</p><p>online工具:</p><ul><li><a href="http://picresize.com/" target="_blank" rel="noopener">http://picresize.com/</a></li><li>Google Drawings  — web-based diagramming</li><li><a href="https://tool.lu/favicon/" target="_blank" rel="noopener">https://tool.lu/favicon/</a>  16<em>16 32</em>32 转化<h2 id="ico制作"><a href="#ico制作" class="headerlink" title="ico制作"></a>ico制作</h2></li></ul>]]></content>
      
      <categories>
          
          <category> CS </category>
          
          <category> tools </category>
          
          <category> 绘图工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 矢量图 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>GRU的源码实现</title>
      <link href="/pub/c79f2f90/"/>
      <url>/pub/c79f2f90/</url>
      <content type="html"><![CDATA[<h1 id="GRU的实现源码"><a href="#GRU的实现源码" class="headerlink" title="GRU的实现源码"></a>GRU的实现源码</h1><h2 id="GRU-tensorflow"><a href="#GRU-tensorflow" class="headerlink" title="GRU-tensorflow"></a>GRU-tensorflow</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">call</span><span class="params">(self, inputs, state)</span>:</span></span><br><span class="line">  <span class="string">"""Gated recurrent unit (GRU) with nunits cells."""</span></span><br><span class="line"></span><br><span class="line">  gate_inputs = math_ops.matmul(</span><br><span class="line">      array_ops.concat([inputs, state], <span class="number">1</span>), self._gate_kernel)</span><br><span class="line">  gate_inputs = nn_ops.bias_add(gate_inputs, self._gate_bias)</span><br><span class="line"></span><br><span class="line">  value = math_ops.sigmoid(gate_inputs)</span><br><span class="line">  r, u = array_ops.split(value=value, num_or_size_splits=<span class="number">2</span>, axis=<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">  r_state = r * state</span><br><span class="line"></span><br><span class="line">  candidate = math_ops.matmul(</span><br><span class="line">      array_ops.concat([inputs, r_state], <span class="number">1</span>), self._candidate_kernel)</span><br><span class="line">  candidate = nn_ops.bias_add(candidate, self._candidate_bias)</span><br><span class="line"></span><br><span class="line">  c = self._activation(candidate)</span><br><span class="line">  new_h = u * state + (<span class="number">1</span> - u) * c</span><br><span class="line">  <span class="keyword">return</span> new_h, new_h</span><br></pre></td></tr></table></figure><h2 id="pytorch"><a href="#pytorch" class="headerlink" title="pytorch"></a>pytorch</h2><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li><a href="http://colah.github.io/posts/2015-08-Understanding-LSTMs/" target="_blank" rel="noopener">Understanding LSTM Networks | colah</a></li><li><a href="https://arxiv.org/abs/1412.3555" target="_blank" rel="noopener">Empirical Evaluation of Gated Recurrent Neural Networks on Sequence Modeling</a></li><li><a href="https://towardsdatascience.com/lecture-evolution-from-vanilla-rnn-to-gru-lstms-58688f1da83a" target="_blank" rel="noopener">Evolution: from vanilla RNN to GRU &amp; LSTMs</a></li></ul>]]></content>
      
      <categories>
          
          <category> ML </category>
          
          <category> deep learning </category>
          
          <category> model </category>
          
          <category> RNN </category>
          
      </categories>
      
      
        <tags>
            
            <tag> deep learning </tag>
            
            <tag> gru </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>【深度学习-模型系列】长短期记忆 LSTM （从RNN到LSTM）</title>
      <link href="/pub/a6941437/"/>
      <url>/pub/a6941437/</url>
      <content type="html"><![CDATA[<!-- the implementation of LSTM --><h1 id="传统方法-History"><a href="#传统方法-History" class="headerlink" title="传统方法 History"></a>传统方法 History</h1><p>error signals “flowing backwards in time” tend to either <code>blow up</code> or <code>vanish</code>。</p><p><a href="https://www.zhihu.com/question/49812013" target="_blank" rel="noopener">bp算法中为什么会产生梯度消失？ | 知乎</a></p><h1 id="LSTM"><a href="#LSTM" class="headerlink" title="LSTM"></a>LSTM</h1><p>LSTM网络是RNN的一种，专门设计用于解决long-term dependency/memory问题，1997年由 Hochreiter &amp; Schmidhuber提出。<br>由于独特的设计结构，LSTM适合于处理和预测时间序列中间隔和延迟非常长的重要事件。<br><!-- Long Short Term Memory networks – usually just called “LSTMs” – are a special kind of RNN, capable of learning long-term dependencies.  --></p><p>名字：long short-term memory<br>意思是vanilla RNN是short-term memory，sequence太长，</p><p>LSTM的核心：</p><ul><li>cell + gate, cel<br>用于解决传统RNN中的梯度消失问题 (Gradient Vanish)</li></ul><ul><li><p><strong>LSTM只能避免RNN的梯度消失</strong>（gradient vanishing）；</p></li><li><p>梯度膨胀(gradient explosion)不是个严重的问题，一般靠裁剪后的优化算法即可解决，比如gradient clipping（如果梯度的范数大于某个给定值，将梯度同比收缩）。下面简单说说LSTM如何避免梯度消失.</p></li><li>梯度弥散是什么鬼？</li></ul><p>cell: memory_cell</p><h2 id="关于gate-以及梯度消失问题"><a href="#关于gate-以及梯度消失问题" class="headerlink" title="关于gate 以及梯度消失问题"></a>关于gate 以及梯度消失问题</h2><!-- vanishing gradient over time,或者 The Problem of Long-Term Dependencies--><p>包括：input gate, output gate, forget gate</p><p>gate，即阀门，是一种开关。取值范围[0,1]，0表示关闭，1表示通行</p><!-- 备用图片 http://www.solidswiki.com/images/3/34/Gate_valves.gif --><image width="50%" src="https://i.makeagif.com/media/7-27-2015/OLkiOf.gif"><blockquote><p>Gates are a way to optionally let information through.</p></blockquote><p>待看</p><ul><li>An Empirical Exploration of Recurrent Network Architectures.</li><li>Empirical Evaluation of Gated Recurrent Neural Networks on Sequence Modeling.</li></ul><h3 id="梯度消失问题—直观解释"><a href="#梯度消失问题—直观解释" class="headerlink" title="梯度消失问题—直观解释"></a>梯度消失问题—直观解释</h3><!-- In theory, RNNs are absolutely capable of handling “long-term dependencies.” --><image title="d" src="/images/raw/NN - RNN - vanish gradient problem - alex.png" width="70%"><p>传统RNN中存在的梯度消失。<br><!-- conventional RNN: 1. The sensitivity of the input valus decays overtime 2. The network forgets the previous input--></p><h3 id="梯度消失-—-产生的原因"><a href="#梯度消失-—-产生的原因" class="headerlink" title="梯度消失 — 产生的原因"></a>梯度消失 — 产生的原因</h3><p>本质原因就是因为矩阵高次幂导致的</p><p>在多层网络中，影响梯度大小的因素主要有两个：权重和激活函数的偏导。</p><p>深层的梯度是多个激活函数偏导乘积的形式来计算，如果这些激活函数的偏导比较小（小于1）或者为0，那么梯度随时间很容易vanishing；相反，如果这些激活函数的偏导比较大（大于1），那么梯度很有可能就会exploding。因而，梯度的计算和更新非常困难。</p><p><a href="https://www.zhihu.com/question/34878706" target="_blank" rel="noopener">https://www.zhihu.com/question/34878706</a></p><p>参考:</p><ul><li><a href="http://www.wildml.com/2015/10/recurrent-neural-networks-tutorial-part-3-backpropagation-through-time-and-vanishing-gradients/" target="_blank" rel="noopener">BP Through Time and Vanishing Gradients</a></li><li><a href="https://www.cs.toronto.edu/~graves/phd.pdf#page=45" target="_blank" rel="noopener">Chapter 4: LSTM | Supervised Sequence Labelling with Recurrent Neural Networks</a></li><li><a href="https://medium.com/mlreview/understanding-lstm-and-its-diagrams-37e2f46f1714" target="_blank" rel="noopener">关于valve的比喻</a></li></ul><!-- we fist introduce the interface, then the implementation  --><h2 id="梯度消失问题-—-解决方案"><a href="#梯度消失问题-—-解决方案" class="headerlink" title="梯度消失问题 — 解决方案"></a>梯度消失问题 — 解决方案</h2><p>使用一个合适激活函数，它的梯度在一个合理的范围。LSTM使用gate function，有选择的让一部分信息通过。gate是由一个sigmoid单元和一个逐点乘积操作组成，sigmoid单元输出1或0，用来判断通过还是阻止，然后训练这些gate的组合。所以，<strong>当gate是打开的（梯度接近于1），梯度就不会vanish。并且sigmoid不超过1，那么梯度也不会explode</strong>。</p><image title="LSTM Gate" width="70%" src="/images/raw/NN - LSTM gate - colah.png"><h2 id="梯度消失问题-—-LSTM是如何避免的"><a href="#梯度消失问题-—-LSTM是如何避免的" class="headerlink" title="梯度消失问题 — LSTM是如何避免的"></a>梯度消失问题 — LSTM是如何避免的</h2><p>1、当gate是关闭的，那么就会阻止对当前信息的改变，这样以前的依赖信息就会被学到。2、当gate是打开的时候，并不是完全替换之前的信息，而是在之前信息和现在信息之间做加权平均。所以，无论网络的深度有多深，输入序列有多长，只要gate是打开的，网络都会记住这些信息。</p><!-- https://www.cc.gatech.edu/~san37/img/dl/grad_lstm.png --><p><image title="the preservation over time of gradient information by LSTM" width="70%" src="/images/raw/NN - LSTM - preservation of gradient - alex.png"><br><!-- LSTM: 1. The cell remember the input as long as it wants 2. The output can be used anytime it wants--></image></p><p>上面这个例子中，数据从实心1向后传递。通过gate的配合，成功在节点4和6输出该数据。<strong>数据流(梯度)不会因long-term传输而消失</strong>，有效解决RNN的梯度消失问题。即<strong>梯度保持</strong></p><ul><li>当gate是关闭的，那么就会阻止对当前信息的改变，这样以前的依赖信息就会被学到。</li><li>当gate是打开的时候，并不是完全替换之前的信息，而是在之前信息和现在信息之间做加权平均。所以，无论网络的深度有多深，输入序列有多长，只要gate是打开的，网络都会记住这些信息。</li></ul><p><strong>参考</strong></p><ul><li><a href="http://www.bioinf.jku.at/publications/older/2604.pdf#page=5" target="_blank" rel="noopener">LSTM | Sepp Hochreiter 1997</a></li></ul><h1 id="LSTM-接口设计"><a href="#LSTM-接口设计" class="headerlink" title="LSTM: 接口设计"></a>LSTM: 接口设计</h1><h1 id=""><a href="#" class="headerlink" title="#"></a>#</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">output, (h_n, c_n) = lstm(input, (h_0, c_0))  <span class="comment"># pytorch的接口 hidden=(h,c)</span></span><br><span class="line">new_h, (new_c, new_h) = lstm(inputs, (c, h))  <span class="comment"># tensorflow的接口，其中state=(c, h)</span></span><br></pre></td></tr></table></figure><p>LSTM可以看做有两个隐状态h和c，对应的隐层就是一个Tuple。<br>这里可以对比RNN的接口。</p><p><strong>为什么lstm代码里和有些图里，习惯吧output称作h(hidden)？</strong><br><a href="https://zhuanlan.zhihu.com/p/28919765" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/28919765</a><br>接口(对LSTM的封装)要具有良好的扩展性(水平扩展-sequence，垂直扩展-stack)。<br>在stack lstm中，下一层的out对接上一层的input，在深度模型的概念里这就是隐含层hidden的作用，所以命名为hidden。</p><p>但是呢，作为一个cell，我还是觉得叫output比较好。追根溯源，谁第一个采用hidden命名的？</p><p><strong>为什么lstm代码里要把(c, h)封装成一个tuple？</strong><br>这样设计的目的是为了兼容RNN的接口(毕竟LSTM属于RNN的一种)。</p><ul><li><a href="https://github.com/pytorch/pytorch/blob/master/torch/nn/modules/rnn.py#L346" target="_blank" rel="noopener">pytorch 源码 - LSTM</a></li><li><a href="https://github.com/tensorflow/tensorflow/blob/master/tensorflow/python/ops/rnn_cell_impl.py#L553" target="_blank" rel="noopener">tensorflow源码 - BasicLSTMCell</a></li></ul><h2 id="example-应用示例"><a href="#example-应用示例" class="headerlink" title="example 应用示例"></a>example 应用示例</h2><p><a href="https://www.tensorflow.org/tutorials/recurrent" target="_blank" rel="noopener">应用示例—基于lstm的语言模型</a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">lstm = tf.contrib.rnn.BasicLSTMCell(lstm_size)</span><br><span class="line"><span class="comment"># current_batch_of_words不是sequence，只是</span></span><br><span class="line"><span class="keyword">for</span> current_batch_of_words <span class="keyword">in</span> words:  </span><br><span class="line">  <span class="comment"># 这里的输入和输出都是符号，类型是tf.placeholder，lstm参数是tf.variable</span></span><br><span class="line">  output, state = lstm(current_batch_of_words, state)</span><br></pre></td></tr></table></figure><h1 id="LSTM-实现"><a href="#LSTM-实现" class="headerlink" title="LSTM: 实现"></a>LSTM: 实现</h1><p>In order to make the learning process tractable, it is common practice to create an “unrolled” version of the network, which contains a <strong>fixed number (num_steps) of LSTM inputs and outputs</strong>. The model is then trained on this finite approximation of the RNN. This can be implemented by feeding inputs of length num_steps at a time and performing a backward pass after each such input block.</p><p>为什么要限定长度?<br>对于任意长度的序列，BP算法计算复杂，因此采用固定长度的序列。</p><h2 id="LSTM-tensorflow实现"><a href="#LSTM-tensorflow实现" class="headerlink" title="LSTM: tensorflow实现"></a>LSTM: tensorflow实现</h2><image src="/images/raw/NN - LSTM - tensorflow with Equation - colah.png"><p>tensorflow源码 - <a href="https://github.com/tensorflow/tensorflow/blob/master/tensorflow/python/ops/rnn_cell_impl.py#L553" target="_blank" rel="noopener">BasicLSTMCell</a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 源码精简版</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">call</span><span class="params">(self, inputs, state)</span>:</span></span><br><span class="line">  <span class="string">"""Run one step of LSTM.</span></span><br><span class="line"><span class="string">  Args:</span></span><br><span class="line"><span class="string">    inputs: `2-D` tensor with shape `[batch_size, input_size]`. 是单个时间节点的batch样本</span></span><br><span class="line"><span class="string">    state:</span></span><br><span class="line"><span class="string">  Returns:</span></span><br><span class="line"><span class="string">    hidden state, new state ().</span></span><br><span class="line"><span class="string">  """</span></span><br><span class="line">  c, h = state</span><br><span class="line">  gate_inputs = math_ops.matmul(</span><br><span class="line">      array_ops.concat([inputs, h], <span class="number">1</span>), self._kernel)</span><br><span class="line">  gate_inputs = nn_ops.bias_add(gate_inputs, self._bias)</span><br><span class="line">  <span class="comment"># i = input_gate, j = new_input, f = forget_gate, o = output_gate</span></span><br><span class="line">  i, j, f, o = array_ops.split(</span><br><span class="line">      value=gate_inputs, num_or_size_splits=<span class="number">4</span>, axis=one)</span><br><span class="line"></span><br><span class="line">  forget_bias_tensor = constant_op.constant(self._forget_bias, dtype=f.dtype)</span><br><span class="line"></span><br><span class="line">  <span class="comment"># update</span></span><br><span class="line">  new_c = add(multiply(c, sigmoid(add(f, forget_bias_tensor))),</span><br><span class="line">              multiply(sigmoid(i), self._activation(j)))</span><br><span class="line">  new_h = multiply(self._activation(new_c), sigmoid(o))</span><br><span class="line">  new_state = LSTMStateTuple(new_c, new_h)</span><br><span class="line">  <span class="keyword">return</span> new_h, new_state</span><br></pre></td></tr></table></figure><h2 id="pytorch"><a href="#pytorch" class="headerlink" title="pytorch"></a>pytorch</h2><p>包装的好复杂，参考 <a href="https://blog.ddlee.cn/2017/05/29/LSTM-Pytorch%E5%AE%9E%E7%8E%B0/" target="_blank" rel="noopener">https://blog.ddlee.cn/2017/05/29/LSTM-Pytorch%E5%AE%9E%E7%8E%B0/</a></p><h1 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h1><p>关于静态图和动态图？</p><p>gate是点，还是向量？<br>向量， decides what parts of the cell state we’re going to output</p><h2 id="其他参考"><a href="#其他参考" class="headerlink" title="其他参考"></a>其他参考</h2><ul><li><a href="http://colah.github.io/posts/2015-08-Understanding-LSTMs/" target="_blank" rel="noopener">通俗经典之作—Understanding LSTM Networks</a></li><li><a href="http://arxiv.org/abs/1409.2329" target="_blank" rel="noopener">BasicLSTMCell对应的paper—Recurrent Neural Network Regularization</a></li><li><a href="https://www.cs.toronto.edu/~graves/phd.pdf" target="_blank" rel="noopener">Supervised Sequence Labelling with Recurrent Neural Networks</a></li><li><a href="https://www.jiqizhixin.com/articles/2017-01-16-6" target="_blank" rel="noopener">地平线语音战略与研究</a></li></ul><h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><p>黄畅：我补充一点。关于 LSTM，不管你是单向的、双向的、摞一起的、不摞一起的，其实都有一个问题：<strong>信息传导的约束很强</strong>。换句话说，不管是做前向预测还是后向 BP（反向传播），一个信息从左边到右边，或者从开始到结束，都要经过很长的路径。而且在<strong>整个过程中，会有很多非线性的变化</strong>，尤其是 LSTM 这种典型的、很容易进入自我限制状态的模型。经过很多次这样的事情，就导致整个<strong>优化变得异常困难</strong>。这个结构天生就使得优化变得非常困难。</p><p>这是 LSTM 的弊病，它的结构设计有很大限制性。你可以类比一些其他结构，比如 ResNet，它通过建立 free-way 的方式，人为地架了很多 <strong>short-pass</strong>（短路径），使得本来在网络上距离很远的两个单元之间建立一些高速的快速通道。直观的理解就是可以让它们之间的信息沟通更加顺畅，减轻我前面说的那个问题。</p><p>更进一步，你会发现在语音识别中有人用<strong>完整的 CNN 替代 LSTM</strong>，包括讯飞、微软、百度。刚开始的时候 CNN 用得很浅，只是作为基本的局部表达，后来发现可以用 <strong>CNN 不断堆积</strong>，而且堆的很有技巧。在计算量不显著增加的情况下，这样就可以<strong>用 CNN 覆盖很大的语境</strong>。</p><p>就是说优化算法本身也许没有很好的进步，但是通过网络结构的设计可以规避目前主要基于 SGD 的优化算法难以解决的 LSTM 问题，直接构造一个更适合目前优化算法去优化的网络结构。所以本质上很难说哪个结构更好，你只能说这个结构更适合现在主流的这种优化方法。</p><p>其实论文出来时我稍微看了一点，它本质上好像和 attention model 很像。attention model 的概念是不管语境是怎么传过来的，总是有选择的看所有东西，做决策（比如生成一个词）的时候有选择的去做。这时候会产生一个 attention mask，这可以理解成一个 gate，封住一些不想看的东西，保留想看的。</p><p>这个在图像和 NLP 里面已经得到很好的验证。NLP、语音、图像其实都是相通的，你会发现很多思想、结构、设计理念会越来越相似。这也给了我们信心，让我们可以实现语音图像识别一体化交互，用一套统一的专用架构去做解决各种各样的问题。</p></image></image></image></image>]]></content>
      
      <categories>
          
          <category> ML </category>
          
          <category> deep learning </category>
          
          <category> model </category>
          
          <category> RNN </category>
          
      </categories>
      
      
        <tags>
            
            <tag> gradient vanish </tag>
            
            <tag> lstm </tag>
            
            <tag> rnn </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>【深度学习-模型系列】递归神经网络 RNN (从HMM到RNN)</title>
      <link href="/pub/d66c7262/"/>
      <url>/pub/d66c7262/</url>
      <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><blockquote><p>递归神经网络（RNN）是两种人工神经网络的总称。一种是时间递归神经网络（recurrent neural network），另一种是结构递归神经网络（recursive neural network）。<br>时间递归神经网络的神经元间连接构成矩阵，而结构递归神经网络利用相似的神经网络结构递归构造更为复杂的深度网络。RNN一般指代时间递归神经网络。单纯递归神经网络因为无法处理随着递归，权重指数级爆炸或消失的问题（Vanishing gradient problem），难以捕捉长期时间关联；而结合不同的LSTM可以很好解决这个问题。[1][2]<br>—— 维基百科</p></blockquote><ul><li>recurrent</li><li>recursive</li><li>feedforward</li></ul><h2 id="序列建模的发展史"><a href="#序列建模的发展史" class="headerlink" title="序列建模的发展史"></a>序列建模的发展史</h2><ul><li>Memoryless models for sequences</li><li>Markov:  bi-gram, tri-gram, n-gram<ul><li>严格的独立性假设条件，<strong>无法建模任意长度的上下文信息</strong>。</li><li>n-gram矩阵太大，太稀疏，(2-gram也很大很稀疏)。怎样解决？词典大小$V$，</li><li>详见HMM博客</li></ul></li><li>HMM</li><li>RNN<ul><li>HMM转移概率矩阵太大，这里可以认为是对其降维。</li></ul></li><li>LSTM</li></ul><p><strong>RNN与HMM</strong></p><p>基本结构上是挺像的，都是通过hidden state 的演化来刻画 序列间的依赖关系</p><p>RNN与HMM的本质区别是RNN没有马尔科夫假设，可以考虑很长的历史信息。</p><ol><li>隐状态的表示: hmm是onehot, RNN是分布表示，RNN的表示能力强很多，或者说在面对高维度时，表示效率更高。类似nlp里，对单个token的表示，一种是onehot, 一种是word vector 。</li><li>隐状态的演化方式: hmm是线性的，RNN是高度非线性。</li><li>在垂直方向上，实际中的lstm还会增加depth, 来增加不同层面的抽象表示，也会使得表示能力指数增加，随着depth 增加。</li></ol><p>RNN也是基于马尔可夫假设的，当前的隐状态仅依赖前一个时刻的隐状态。在有马尔可夫假设的模型中，不代表距离超过1的两个状态是无依赖的。</p><p>印象中有paper证明， 在HMM中两个状态的依赖关系随距离指数衰减，而在RNN中是power law decay.  也就是大家通常说的 rnn可以略好的刻画 long term dependency.</p><p>另，SLAM中还有种算法跟hmm类似，kalman filter.</p><p>作者：a88i99<br>链接：<a href="https://www.zhihu.com/question/57396443/answer/263019702" target="_blank" rel="noopener">https://www.zhihu.com/question/57396443/answer/263019702</a><br>来源：知乎<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p><h2 id="RNN-Overview"><a href="#RNN-Overview" class="headerlink" title="RNN Overview"></a>RNN Overview</h2><ul><li>狭义上的RNN，指vanilla RNN。</li><li>广义上的RNN，lstm gru等都属于RNN框架。</li></ul><p>该文章针对广义上的RNN。</p><p>RNN的形式有很多种</p><image title="展开的(unrolled) RNN" src="/images/raw/NN - RNN - overview.png"><p>该图的总结很好，大部分应用都可归入该框架。具体的应用可参考<a href="http://karpathy.github.io/2015/05/21/rnn-effectiveness/" target="_blank" rel="noopener">karpathy</a><br><!-- 框架之外的模型: attention --></p><p>核心:<br><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">out, hidden = lstm(input, hidden)  <span class="comment"># 来自pytorch的抽象</span></span><br></pre></td></tr></table></figure></p><p>名词解释:</p><ul><li>hidden 也叫cell, hidden_state, cell_state。它是forget的关键</li><li>out 也叫 output，</li><li>hidden</li><li>cell</li><li>output在stack RNN中也叫hidden</li></ul><p>output = new_state =</p><p>Most basic RNN:<br><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">output = new_state = act(W * input + U * state + B)</span><br></pre></td></tr></table></figure></p><p><a href="https://www.quora.com/How-is-the-hidden-state-h-different-from-the-memory-c-in-an-LSTM-cell" target="_blank" rel="noopener">https://www.quora.com/How-is-the-hidden-state-h-different-from-the-memory-c-in-an-LSTM-cell</a></p><p>vanilla RNN中没有cell，所以hidden=cell=out<br>LSTM中</p><h2 id="RNN的高层抽象"><a href="#RNN的高层抽象" class="headerlink" title="RNN的高层抽象"></a>RNN的高层抽象</h2><blockquote><p>抽象不是实现，是API。由整体到局部，可把RNN当做一个黑盒子，有需求的情况下再细看其具体实现。</p></blockquote><h3 id="keras的RNN抽象"><a href="#keras的RNN抽象" class="headerlink" title="keras的RNN抽象"></a>keras的RNN抽象</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">keras.layers.RNN(cell, return_sequences=<span class="keyword">False</span>, return_state=<span class="keyword">False</span>, go_backwards=<span class="keyword">False</span>, stateful=<span class="keyword">False</span>, unroll=<span class="keyword">False</span>)</span><br><span class="line"><span class="comment"># return_sequences: 是否返回整个序列out</span></span><br><span class="line"><span class="comment"># return_state: 是否返回整个序列的hidden</span></span><br></pre></td></tr></table></figure><p><a href="https://github.com/keras-team/keras/blob/master/examples/imdb_lstm.py#L41" target="_blank" rel="noopener">应用示例—lstm用于二分类</a>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">model = Sequential()</span><br><span class="line">model.add(Embedding(num_words, <span class="number">128</span>))  <span class="comment"># 输入整个sequence</span></span><br><span class="line">model.add(LSTM(<span class="number">128</span>, dropout=<span class="number">0.2</span>, recurrent_dropout=<span class="number">0.2</span>)) <span class="comment"># 输出最后一个cell的output</span></span><br><span class="line">model.add(Dense(<span class="number">1</span>, activation=<span class="string">'sigmoid'</span>)) <span class="comment"># 二分类</span></span><br></pre></td></tr></table></figure><p>这是上图中的<code>many to one</code>模式。</p><ul><li>关于</li><li>关于静态图：sequence的数目固定为80</li></ul><details>  <summary>[应用示例--基于lstm的seq2seq](https://github.com/keras-team/keras/blob/master/examples/lstm_seq2seq.py)</summary>  <div>  <figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Define an input sequence and process it.</span></span><br><span class="line">encoder_inputs = Input(shape=(<span class="keyword">None</span>, num_encoder_tokens))</span><br><span class="line">encoder = LSTM(latent_dim, return_state=<span class="keyword">True</span>)</span><br><span class="line">encoder_outputs, state_h, state_c = encoder(encoder_inputs)</span><br><span class="line"><span class="comment"># We discard `encoder_outputs` and only keep the states.</span></span><br><span class="line">encoder_states = [state_h, state_c]</span><br><span class="line"></span><br><span class="line"><span class="comment"># Set up the decoder, using `encoder_states` as initial state.</span></span><br><span class="line">decoder_inputs = Input(shape=(<span class="keyword">None</span>, num_decoder_tokens))</span><br><span class="line"><span class="comment"># We set up our decoder to return full output sequences,</span></span><br><span class="line"><span class="comment"># and to return internal states as well. We don't use the</span></span><br><span class="line"><span class="comment"># return states in the training model, but we will use them in inference.</span></span><br><span class="line">decoder_lstm = LSTM(latent_dim, return_sequences=<span class="keyword">True</span>, return_state=<span class="keyword">True</span>)</span><br><span class="line">decoder_outputs, _, _ = decoder_lstm(decoder_inputs,</span><br><span class="line">                                     initial_state=encoder_states)</span><br><span class="line">decoder_dense = Dense(num_decoder_tokens, activation=<span class="string">'softmax'</span>)</span><br><span class="line">decoder_outputs = decoder_dense(decoder_outputs)</span><br></pre></td></tr></table></figure>  <div></div></div></details><details>  <summary>[应用示例--基于lstm的attention-seq2seq](https://github.com/keras-team/keras/blob/master/examples/lstm_seq2seq.py)</summary>  <p><code>  </code></p></details><p>keras是对整个sequence做的抽象。因为keras是面向tensorflow和theano的静态图做的封装。</p><h3 id="pytorch的RNN抽象"><a href="#pytorch的RNN抽象" class="headerlink" title="pytorch的RNN抽象"></a>pytorch的RNN抽象</h3><p>应用示例—基于lstm的<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># for a sequence inputs</span></span><br><span class="line"><span class="keyword">for</span> input <span class="keyword">in</span> inputs:</span><br><span class="line">  <span class="comment"># Step through the sequence one element at a time</span></span><br><span class="line">  out, hidden = lstm(input, hidden)</span><br></pre></td></tr></table></figure></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">output, (h_n, c_n) = lstm(input, (h_0, c_0))</span><br></pre></td></tr></table></figure><p>pytorch是动态图，会随着inputsequence</p><p><a href="https://github.com/pytorch/pytorch/blob/master/torch/nn/modules/rnn.py#L346" target="_blank" rel="noopener">源码实现</a></p><h2 id="tensorflow的抽象"><a href="#tensorflow的抽象" class="headerlink" title="tensorflow的抽象"></a>tensorflow的抽象</h2><p><a href="https://www.tensorflow.org/tutorials/recurrent" target="_blank" rel="noopener">示例—基于lstm的语言模型</a></p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">lstm = tf.contrib.rnn.BasicLSTMCell(lstm_size)</span><br><span class="line">output, state = lstm(words, state) <span class="comment"># 这里的输入和输出都是符号，类型是tf.placeholder，lstm参数是tf.variable</span></span><br></pre></td></tr></table></figure><p><a href="https://github.com/tensorflow/tensorflow/blob/master/tensorflow/python/ops/rnn_cell_impl.py#L476" target="_blank" rel="noopener">BasicLSTMCell源码</a></p><h2 id="基于RNN的变形（mainstream-variation）"><a href="#基于RNN的变形（mainstream-variation）" class="headerlink" title="基于RNN的变形（mainstream variation）"></a>基于RNN的变形（mainstream variation）</h2><h3 id="cell"><a href="#cell" class="headerlink" title="cell"></a>cell</h3><h3 id="cascade-rnn"><a href="#cascade-rnn" class="headerlink" title="cascade rnn"></a>cascade rnn</h3><p>char-rnn + word rnn (Finding Function in Form: Compositional Character Models for Open Vocabulary Word Representation)<br>char-cnn + word rnn (Exploring the Limits of Language Modeling)</p><h2 id="sequence-labeling"><a href="#sequence-labeling" class="headerlink" title="sequence labeling"></a>sequence labeling</h2><p>Part-of-speech Tagging</p><h2 id="attention"><a href="#attention" class="headerlink" title="attention"></a>attention</h2><h2 id="rnn-new-trends"><a href="#rnn-new-trends" class="headerlink" title="rnn new trends"></a>rnn new trends</h2><h2 id="未分类"><a href="#未分类" class="headerlink" title="未分类"></a>未分类</h2><p>recurrent highway network</p><h1 id="框架-总结"><a href="#框架-总结" class="headerlink" title="框架 总结"></a>框架 总结</h1><p><code>Sequence Modeling</code>按照架构一般分为：</p><ol><li>Encoder 架构<ul><li>Sequence Classification</li><li>Sequence Labeling/Prediction</li></ul></li><li>Deep Encoder 架构</li><li>Encoder – Decoder 架构<br><br>其中input和output都是sequence的架构，又叫<code>seq2seq</code><ul><li><strong>encoder</strong>:<ul><li>CNN：图片一般采用CNN，文本也可以采用CNN</li><li>RNN:</li></ul></li><li><strong>decoder</strong>:<ul><li><strong>simple decoder</strong>: 通常是LSTM作为解码器<sup><a href="#fn_seq2seq-NN" id="reffn_seq2seq-NN">seq2seq-NN</a></sup><sup><a href="#fn_seq2seq-MT" id="reffn_seq2seq-MT">seq2seq-MT</a></sup><sup><a href="#fn_seq2seq-Conversation" id="reffn_seq2seq-Conversation">seq2seq-Conversation</a></sup>. encodes the “meaning” of the input sequence into a single vector of a fixed dimensionality. Then another deep LSTM to decode the target sequence from the vector. (only last output of the encoder. This last output is sometimes called the <code>context vector</code> as it encodes context from the entire sequence.<br>map the input sequence)<br><br><strong>缺陷</strong>：只用了一个vector(<code>context vector</code>)表征输入序列压力太大(it carries the burden of encoding the entire sentence).<br><br><strong>解决</strong>: 整个序列都用<br><br> 1. 一个简单的方式是<a href="http://deeplearning.net/tutorial/lstm.html" target="_blank" rel="noopener">对序列vector取均值</a>，高大上点叫<code>mean pooling</code><br><br> 2. 对序列vector线性加权。难点：加权系数怎么来？因为这是不定长序列，不能像DNN那样放一个全连接参数W让模型去学。于是就出现了attention，以及self-attention。</li><li><strong>attention decoder</strong>: LSTM+attention<br><br> The decoder decides parts of the source sentence to pay attention to.<br><br> It relieves the encoder from the burden of having to encode all information in the source sentence into a fixedlength vector.<br><br><br>Attention allows the decoder network to “focus” on a different part of the encoder’s outputs for every step of the decoder’s own outputs. First we calculate a set of <code>attention weights</code>.</li></ul></li></ul></li></ol><p>列个表，input和output</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><blockquote id="fn_RNN"><sup>RNN</sup>. <a href="http://karpathy.github.io/2015/05/21/rnn-effectiveness/" target="_blank" rel="noopener">The Unreasonable Effectiveness of Recurrent Neural Networks</a><a href="#reffn_RNN" title="Jump back to footnote [RNN] in the text."> &#8617;</a></blockquote><blockquote id="fn_seq2seq-NN"><sup>seq2seq-NN</sup>. <a href="http://papers.nips.cc/paper/5346-sequence-to-sequence-learning-with-neural-networks.pdf" target="_blank" rel="noopener">Sequence to Sequence Learning with Neural Networks | nips 2014</a><a href="#reffn_seq2seq-NN" title="Jump back to footnote [seq2seq-NN] in the text."> &#8617;</a></blockquote><blockquote id="fn_seq2seq-MT"><sup>seq2seq-MT</sup>. <a href="https://arxiv.org/abs/1406.1078" target="_blank" rel="noopener">Learning Phrase Representations using RNN Encoder-Decoder for Statistical Machine Translation | EMNLP 2014</a><a href="#reffn_seq2seq-MT" title="Jump back to footnote [seq2seq-MT] in the text."> &#8617;</a></blockquote><blockquote id="fn_seq2seq-Conversation"><sup>seq2seq-Conversation</sup>. <a href="https://arxiv.org/abs/1506.05869" target="_blank" rel="noopener">A Neural Conversational Model</a><a href="#reffn_seq2seq-Conversation" title="Jump back to footnote [seq2seq-Conversation] in the text."> &#8617;</a></blockquote><p>[]: <a href="http://mp.weixin.qq.com/s?__biz=MzIwOTc2MTUyMg==&amp;mid=2247484029&amp;idx=1&amp;sn=c93b5eddec33dc29dc172a5ea0d76822&amp;chksm=976fa7e0a0182ef61e36d1c32aa0706c4e81e1762a7ee2554165beecde929b72cf026c5b7a64&amp;mpshare=1&amp;scene=23&amp;srcid=0503qzbJeq0QB0eiZo0vAnMr#rd" target="_blank" rel="noopener">吴恩达《序列模型》精炼笔记 — 循环神经网络（RNN）</a></p></image>]]></content>
      
      <categories>
          
          <category> ML </category>
          
          <category> deep learning </category>
          
          <category> model </category>
          
          <category> RNN </category>
          
      </categories>
      
      
        <tags>
            
            <tag> rnn </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>微信网页版 聊天原理</title>
      <link href="/pub/855d5922/"/>
      <url>/pub/855d5922/</url>
      <content type="html"><![CDATA[<h2 id="Overview"><a href="#Overview" class="headerlink" title="Overview"></a>Overview</h2><p>微信网页版聊天，未采用websocket，而是基于long polling(长轮询)。</p><h2 id="客户端消息发送"><a href="#客户端消息发送" class="headerlink" title="客户端消息发送"></a>客户端消息发送</h2><h2 id="客户端消息接收（伪服务端推送）"><a href="#客户端消息接收（伪服务端推送）" class="headerlink" title="客户端消息接收（伪服务端推送）"></a>客户端消息接收（伪服务端推送）</h2><ol><li>客户端间隔性发送http请求（每隔）<a href="https://res.wx.qq.com/a/wx_fed/webwx/res/static/js/index_ca360ff.js" target="_blank" rel="noopener">源码</a>; <a href="https://github.com/BitMindLab/wx.qq.com/blob/master/res.wx.qq.com/a/wx_fed/webwx/res/static/js/index_ca360ff.js" target="_blank" rel="noopener">beauty后的源码</a></li><li>服务端对该请求延时返回，强制建立长连接</li><li>当服务端有需要推送的消息，即时在已建立的长连接中返回http response</li><li>客户端收到response后，立即发送一个新的http request</li><li>goto 2</li></ol><h3 id="客户端发送http-request"><a href="#客户端发送http-request" class="headerlink" title="客户端发送http request"></a>客户端发送http request</h3><p>客户端间隔性发送ajax请求</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Request URL:https://webpush.wx.qq.com/cgi-bin/mmwebwx-bin/synccheck?</span><br><span class="line">Referrer Policy:no-referrer-when-downgrade</span><br><span class="line"></span><br><span class="line"># Query String Parameters</span><br><span class="line">r:151**</span><br><span class="line">skey:@crypt_d8e**</span><br><span class="line">sid:a5ne**</span><br><span class="line">uin:1709**</span><br><span class="line">deviceid:e2387***</span><br><span class="line">synckey:1_677803136|2_677803**</span><br><span class="line">_:1517**</span><br></pre></td></tr></table></figure><p>这是一个服务器端强制保持的长连接。</p><h2 id="待看"><a href="#待看" class="headerlink" title="待看"></a>待看</h2><ul><li><a href="https://github.com/geeeeeeeeek/electronic-wechat" target="_blank" rel="noopener">网页微信的封装，直接在 Electron 里加载微信的网页版，并向其中注入一些代码</a></li><li><p><a href="https://github.com/geeeeeeeeek/electronic-wechat/issues/2" target="_blank" rel="noopener">网页版微信抓包+注入实现表情贴纸显示</a></p></li><li><p><a href="https://github.com/nodeWechat/wechat4u" target="_blank" rel="noopener">微信网页版的 JavaScript 实现，兼容Node和浏览器，微信机器人</a></p></li><li><a href="https://github.com/Urinx/WeixinBot" target="_blank" rel="noopener">微信网页版的 Python 实现，包含终端版微信及微信机器人</a></li><li><a href="https://github.com/geeeeeeeeek/WeChatLuckyMoney" target="_blank" rel="noopener">微信抢红包插件—基于安卓</a></li><li><p><a href="https://www.zhihu.com/question/66554815" target="_blank" rel="noopener">微信聊天功能使用了什么协议？</a></p><p>原理 教程</p></li><li><a href="https://github.com/WeMobileDev/article/blob/master/%E5%9F%BA%E4%BA%8ETLS1.3%E7%9A%84%E5%BE%AE%E4%BF%A1%E5%AE%89%E5%85%A8%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AEmmtls%E4%BB%8B%E7%BB%8D.md" target="_blank" rel="noopener">基于TLS1.3的微信安全通信协议mmtls介绍.—-by 微信员工</a></li></ul><h2 id="疑问"><a href="#疑问" class="headerlink" title="疑问"></a>疑问</h2><h3 id="为什么不采用websocket"><a href="#为什么不采用websocket" class="headerlink" title="为什么不采用websocket?"></a>为什么不采用websocket?</h3><p>websocket占用资源多？不安全？socket连接数限制？低端浏览器不支持？手机浏览器不支持？<br>知乎说，是因为懒</p>]]></content>
      
      <categories>
          
          <category> CS </category>
          
          <category> web </category>
          
          <category> 服务器推送 </category>
          
          <category> 非websocket的例子 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> web </tag>
            
            <tag> 推送 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>关于websocket</title>
      <link href="/pub/5f589e78/"/>
      <url>/pub/5f589e78/</url>
      <content type="html"><![CDATA[<p>websocket属于服务器推送技术的一种。<br>HTML5定义了 WebSocket 协议，以及相关的编程API，能更好的实现双向通信且节省服务器资源和带宽。</p><blockquote><p> WebSocket 实际上指的是一种协议，与我们熟知的 Http 协议是同等的一个网络协议。用网络模型结构来解释的话， WebSocket 和 Http 协议都属于 应用层协议，两者都基于传输层协议 TCP。</p></blockquote><p>http协议  http://<br>ftp协议   ftp://<br>websocket协议 ws://</p><p>Websocket是基于HTTP协议的，或者说借用了HTTP的协议来完成一部分握手。<br>在握手阶段是一样的</p><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>以前的网站为了实现推送功能，使用的方法都是轮询。所谓的轮询就是在特定的时间间隔（例如1秒），由浏览器向服务器发出一个 Http request，然后服务器返回最新的数据给客户端浏览器，从而给出一种服务端实时推送的假象。由于Http Request的Header（请求头）很长,而传输的数据可能很短就只占一点点，每次请求消耗的带宽大部分都消耗在 Header上。从网上资料得知后来还有改进的轮询方法叫做 Comet，使用 Ajax。但这种技术虽然可达到双向通信，但依然需要发出请求，而且在Comet中，普遍采用了长链接，这也会大量消耗服务器带宽和资源。</p><h2 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h2><ol><li>首先WebSocket 服务器启动，并监听端口</li><li>客户端new websocket(dfd)，建立连接</li></ol><h2 id="客户端的API-js"><a href="#客户端的API-js" class="headerlink" title="客户端的API (js)"></a>客户端的API (js)</h2><p>不同浏览器有不同的实现，但都提供的javascript API，所以客户端API都类似，或者可以统一API。</p><h2 id="服务端的实现"><a href="#服务端的实现" class="headerlink" title="服务端的实现"></a>服务端的实现</h2><p>websocket服务器则因语言不同而提供不同的调用方式。</p><p>是叫实现，还是应该叫封装？</p><ul><li>基于java的实现<ul><li><a href="https://github.com/BitMindLab/tomcat-example/tree/master/WEB-INF/classes/websocket/" target="_blank" rel="noopener">tomcat的websocket实现</a></li><li><a href="">jetty的websocket实现</a></li></ul></li><li>基于nodejs的实现<ul><li>服务器端的socket.io，搭配客户端js库<code>socket.io-client</code></li></ul></li><li>基于python的实现</li><li>基于shell的实现<ul><li>WebSocketd</li></ul></li></ul><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">GET /chat HTTP/1.1</span><br><span class="line">Host: server.example.com</span><br><span class="line">Upgrade: websocket      <span class="comment">## 这个就是Websocket的核心了，告诉Apache、Nginx等服务器：注意啦，窝发起的是Websocket协议，快点帮我找到对应的助理处理~不是那个老土的HTTP。</span></span><br><span class="line">Connection: Upgrade    <span class="comment">##</span></span><br><span class="line">Sec-WebSocket-Key: x3JJHMbDL1EzLkh9GBhXDw==</span><br><span class="line">Sec-WebSocket-Protocol: chat, superchat</span><br><span class="line">Sec-WebSocket-Version: 13</span><br><span class="line">Origin: http://example.com</span><br></pre></td></tr></table></figure><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="http://www.ruanyifeng.com/blog/2017/05/websocket.html" target="_blank" rel="noopener">http://www.ruanyifeng.com/blog/2017/05/websocket.html</a></li><li><p><a href="https://en.wikipedia.org/wiki/Comparison_of_WebSocket_implementations" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Comparison_of_WebSocket_implementations</a></p></li><li><p><a href="https://github.com/abbshr/abbshr.github.io/issues/22" target="_blank" rel="noopener">学习WebSocket协议—从顶层到底层的实现原理</a></p></li><li><p><a href="https://www.zhihu.com/question/20215561" target="_blank" rel="noopener">WebSocket 是什么原理？为什么可以实现持久连接？</a>  —-很赞</p></li><li><p><a href="https://juejin.im/entry/5a5c559c518825734859ee5e" target="_blank" rel="noopener">理论联系实际：从零理解WebSocket的通信原理、协议格式、安全性</a></p></li></ul><h2 id="疑问"><a href="#疑问" class="headerlink" title="疑问"></a>疑问</h2><ul><li>websocket是依赖TCP吗？</li></ul><h4 id="如何debug-websocket？"><a href="#如何debug-websocket？" class="headerlink" title="如何debug websocket？"></a>如何debug websocket？</h4><p><strong>方式一：在chrome inspect中查看websocket连接</strong></p><p>network下的WS选项可以查看websocket连接。<br>能看到Request连接:wss://echo.websocket.org/<br>在frame中能看到明文数据，wss竟然也是明文传输</p><p><a href="https://kaazing.com/inspecting-websocket-traffic-with-chrome-developer-tools/" target="_blank" rel="noopener">超详细教程</a></p><p><strong>方式二：通过chrome console中命令查看</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var webSocket = new WebSocket(&apos;ws://address:port&apos;);</span><br><span class="line">webSocket.onmessage = function(data) &#123; console.log(data); &#125;</span><br></pre></td></tr></table></figure></p><p><strong>方式三：在chrome internal里查看</strong></p><p>chrome://net-internals/#sockets</p><p><strong>方式四：通过抓包查看</strong></p><p>见network/tools/wireshark/抓包</p><h4 id="如何查看websocket发送的数据？"><a href="#如何查看websocket发送的数据？" class="headerlink" title="如何查看websocket发送的数据？"></a>如何查看websocket发送的数据？</h4><p>浏览器inspect能看到websocket连接，为什么没看到发送的数据包？<br>那么通过抓包总能够看到吧。</p><ul><li>websocket的实现原理是什么？在TCP的基础上做了什么？加了header？</li></ul><h2 id="online-demo"><a href="#online-demo" class="headerlink" title="online demo"></a>online demo</h2><ul><li><a href="https://socket.io/demos/chat/" target="_blank" rel="noopener">socket.io的在线聊天室</a></li><li><a href="http://www.websocket.org/echo.html" target="_blank" rel="noopener">webSocket.org Echo demo</a></li></ul><h1 id=""><a href="#" class="headerlink" title="#"></a>#</h1><h1 id="-1"><a href="#-1" class="headerlink" title="#"></a>#</h1>]]></content>
      
      <categories>
          
          <category> CS </category>
          
          <category> web </category>
          
          <category> 服务器推送 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> html5 </tag>
            
            <tag> websocket </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>【Markdown系列】marked渲染器</title>
      <link href="/pub/c5991053/"/>
      <url>/pub/c5991053/</url>
      <content type="html"><![CDATA[<p>hexo博客默认采用marked引擎进行markdown解析。</p><p><a href="https://marked.js.org/demo/" target="_blank" rel="noopener">online demo</a></p>]]></content>
      
      <categories>
          
          <category> CS </category>
          
          <category> tools </category>
          
          <category> formatting </category>
          
          <category> markdown </category>
          
      </categories>
      
      
        <tags>
            
            <tag> markdown </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>【Markdown系列】语法进阶 (Advanced Markdown Tips)</title>
      <link href="/pub/7c655851/"/>
      <url>/pub/7c655851/</url>
      <content type="html"><![CDATA[<h1 id="Overview"><a href="#Overview" class="headerlink" title="Overview"></a>Overview</h1><!--## Inline HTMLYou can also use raw HTML in your Markdown, and it'll mostly work pretty well.--><p><code>markdown</code>语法简单方便，但要实现复杂的样式仍然要借助html标签。本文介绍常用的<code>html标签</code>，用于对<code>markdown</code>原生格式的增强。</p><!--有些markdown render不支持内嵌html--><h1 id="常用的标签"><a href="#常用的标签" class="headerlink" title="常用的标签"></a>常用的标签</h1><h2 id="折叠块-lt-summary-gt"><a href="#折叠块-lt-summary-gt" class="headerlink" title="折叠块 &lt;summary&gt;"></a>折叠块 <code>&lt;summary&gt;</code></h2><p>你和猪，打一种动物</p><details>  <summary>点击展开答案</summary>  <p> 象</p></details><p>源码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;details&gt;</span><br><span class="line">  &lt;summary&gt;点击展开答案&lt;/summary&gt;</span><br><span class="line">  &lt;p&gt; 象&lt;/p&gt;</span><br><span class="line">&lt;/details&gt;</span><br></pre></td></tr></table></figure></p><p>通常用于FAQ页面。</p><!--## click事件这个要加js，比较复杂。也有不需要js的click，--><h2 id="图片-lt-img-gt"><a href="#图片-lt-img-gt" class="headerlink" title="图片 &lt;img&gt;"></a>图片 <code>&lt;img&gt;</code></h2><p>markdown的语法不支持图片大小，位置等样式。<br><figure class="highlight md"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">![<span class="string">Alt text</span>](<span class="link">图片链接 "optional title"</span>)</span><br></pre></td></tr></table></figure></p><p>所以可采用<code>&lt;img&gt;</code>标签</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">align</span>=<span class="string">"middle"</span> <span class="attr">alt</span>=<span class="string">"=&amp;quot;alternate_text&amp;quot;"</span> <span class="attr">src</span>=<span class="string">"http://img5.2345.com/duoteimg/zixunImg/local/2016/03/18/14582940693488.gif"</span> <span class="attr">title</span>=<span class="string">"hover"</span> <span class="attr">width</span>=<span class="string">"20%"</span> /&gt;</span></span><br></pre></td></tr></table></figure><p><img align="middle" alt="图片样式" src="http://img5.2345.com/duoteimg/zixunImg/local/2016/03/18/14582940693488.gif" title="图片样式" width="20%"></p><h2 id="对齐-align"><a href="#对齐-align" class="headerlink" title="对齐 (align)"></a>对齐 (align)</h2><blockquote><p>学而不思则罔，思而不学则殆  <div style="text-align:right">—— 《论语》</div></p></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">"text-align:right"</span> &gt;</span>-- 《论语》<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="注释-comment"><a href="#注释-comment" class="headerlink" title="注释 (comment)"></a>注释 (comment)</h2><p>不在页面显示，一般写给自己看，或者写给编辑者看(比如提交issue的模板中附带的注释)</p><ul><li>方式一: 采用html注释标签    <code>&lt;!-- 这里不会显示  --&gt;</code></li><li>方式二: 直接采用&lt;标签   <code>&lt;这里不会显示&gt;</code></li></ul><p>推荐方式一</p><h2 id="代码块-code-block"><a href="#代码块-code-block" class="headerlink" title="代码块 (code block)"></a>代码块 (code block)</h2><h3 id="个性化设置code-block的样式"><a href="#个性化设置code-block的样式" class="headerlink" title="个性化设置code block的样式"></a>个性化设置<code>code block</code>的样式</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;pre&gt;sample &lt;b&gt;sample&lt;/b&gt; sample&lt;/pre&gt;</span><br></pre></td></tr></table></figure><pre>sample <b>sample</b> sample</pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;pre&gt;</span><br><span class="line">&lt;i&gt;&lt;a href=&quot;http://manpages.ubuntu.com/manpages/dapper/man1/prename.1.html&quot;&gt;rename&lt;/a&gt;&lt;/i&gt; sfds</span><br><span class="line">&lt;/pre&gt;</span><br></pre></td></tr></table></figure><pre><i><a href="http://manpages.ubuntu.com/manpages/dapper/man1/prename.1.html" target="_blank" rel="noopener">rename</a></i> sfds</pre><p><code>&lt;pre&gt;</code>标签更灵活。但是，不能显示行号，需要自定义每个元素的格式。</p><h3 id="code-block不常用的语言"><a href="#code-block不常用的语言" class="headerlink" title="code block不常用的语言"></a>code block不常用的语言</h3><p><code>diff</code>样式用的不多，但比较实用。<br><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public class Hello1</span><br><span class="line">&#123;</span><br><span class="line">   public static void Main()</span><br><span class="line">   &#123;</span><br><span class="line"><span class="deletion">-      System.Console.WriteLine("Hello, World!");</span></span><br><span class="line"><span class="addition">+      System.Console.WriteLine("Rock all night long!");</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="动态链接-link"><a href="#动态链接-link" class="headerlink" title="动态链接 (link)"></a>动态链接 (link)</h2><p>这部分属于需要动态link，需要借助<code>javascript</code>。因此需要markdown render支持（比如<a href="https://github.com/fletcher/MultiMarkdown/wiki/MultiMarkdown-Syntax-Guide#footnotes" target="_blank" rel="noopener">MultiMarkdown</a>），或者利用插件（比如<a href="https://github.com/kchen0x/hexo-reference" target="_blank" rel="noopener">hexo-reference</a>）</p><!--### section link--><h3 id="链接的集中管理"><a href="#链接的集中管理" class="headerlink" title="链接的集中管理"></a>链接的集中管理</h3><p>对link的集中管理，方便复用。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">这是[链接一][1]，这是[链接二][2]。多次引用更方便、更简洁，[链接一][1]。</span><br><span class="line"></span><br><span class="line">   [1]: http://url1</span><br><span class="line">   [2]: http://url2 &quot;这是2的标题，可以试着把指针移到链接二上&quot;</span><br></pre></td></tr></table></figure><p>这是<a href="http://url1" target="_blank" rel="noopener">链接一</a>，这是<a href="http://url2" title="还可以添加标题" target="_blank" rel="noopener">链接二</a>。多次引用更方便、更简洁，<a href="http://url1" target="_blank" rel="noopener">链接一</a>。</p><h3 id="脚注-footnote"><a href="#脚注-footnote" class="headerlink" title="脚注 (footnote)"></a>脚注 (footnote)</h3><ul><li><p>马克飞象支持footnote，它采用的<a href="https://github.com/fletcher/MultiMarkdown/wiki/MultiMarkdown-Syntax-Guide#footnotes" target="_blank" rel="noopener">MultiMarkdown</a>，已经停止开发了。</p></li><li><p><a href="https://github.com/kchen0x/hexo-reference" target="_blank" rel="noopener">https://github.com/kchen0x/hexo-reference</a></p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">basic footnote[^demo]</span><br><span class="line"></span><br><span class="line">[^demo]: basic footnote content [title](http://link)</span><br></pre></td></tr></table></figure><h3 id="link总结"><a href="#link总结" class="headerlink" title="link总结"></a>link总结</h3><p>集中link和脚注link最好都放在文档末尾。区别是，前者只提供link，后者明文显示参考文献。我更倾向于后者。</p><blockquote><p>Markdown 是一种轻量级标记语言，它允许人们使用易读易写的纯文本格式编写文档，然后转换成格式丰富的HTML页面。    —— <a href="https://zh.wikipedia.org/wiki/Markdown" target="_blank" rel="noopener">维基百科</a></p></blockquote><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><h3 id="是否支持嵌入js？"><a href="#是否支持嵌入js？" class="headerlink" title="是否支持嵌入js？"></a>是否支持嵌入js？</h3><h3 id="是否支持Markdown-Inside-HTML-Blocks"><a href="#是否支持Markdown-Inside-HTML-Blocks" class="headerlink" title="是否支持Markdown Inside HTML Blocks?"></a>是否支持Markdown Inside HTML Blocks?</h3><blockquote><p>Markdown in HTML does not work very well  —来自官方文档</p></blockquote><p><a href="https://stackoverflow.com/questions/29368902/how-can-i-wrap-my-markdown-in-an-html-div" target="_blank" rel="noopener">部分支持</a></p><ul><li>[x] <code>&lt;div&gt; *Emphasized* text. &lt;/div&gt;</code></li><li>[ ] <code>&lt;div&gt; ## dfd &lt;/div&gt;</code></li></ul><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li><a href="https://github.com/adam-p/markdown-here/wiki/Markdown-Cheatsheet" target="_blank" rel="noopener">Github-Markdown | 官方文档</a></li><li><a href="https://sourceforge.net/p/hexo/wiki/markdown_syntax/" target="_blank" rel="noopener">Hexo-Markdown | 官方文档</a></li></ul>]]></content>
      
      <categories>
          
          <category> CS </category>
          
          <category> tools </category>
          
          <category> formatting </category>
          
          <category> markdown </category>
          
      </categories>
      
      
        <tags>
            
            <tag> markdown </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>DNS解析之“记录类型”</title>
      <link href="/pub/87420f16/"/>
      <url>/pub/87420f16/</url>
      <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>域名与IP之间的对应关系，称为”记录”（record）。根据使用场景，”记录”可以分成不同的类型（type）。</p><p>资源记录(RR: Resource Record)：</p><p><a href="https://zh.wikipedia.org/wiki/%E5%9F%9F%E5%90%8D%E4%BC%BA%E6%9C%8D%E5%99%A8%E8%A8%98%E9%8C%84%E9%A1%9E%E5%9E%8B%E5%88%97%E8%A1%A8" target="_blank" rel="noopener">域名服务器记录类型列表 - 维基百科</a></p><h3 id="常见的DNS记录类型"><a href="#常见的DNS记录类型" class="headerlink" title="常见的DNS记录类型"></a>常见的DNS记录类型</h3><p><a href="https://www.alibabacloud.com/help/zh/doc-detail/58077.htm" target="_blank" rel="noopener">参考</a><br><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">A:</span>      <span class="string">将域名指向一个IPV4地址</span>  <span class="comment">#</span></span><br><span class="line"><span class="attr">CNAME:</span>  <span class="string">将域名指向另外一个域名</span>  <span class="comment"># 将域名指向另一个域名，再由另一个域名提供IP地址</span></span><br><span class="line"><span class="attr">AAAA:</span>   <span class="string">将域名指向一个IPV6地址</span>  <span class="comment"># 当您希望访问者通过IPv6地址访问您的域名时，可以使用AAAA记录。</span></span><br><span class="line"><span class="attr">NS:</span>     <span class="string">将子域名指向其他DNS服务器解析</span> <span class="comment"># 如果需要把子域名交给其他DNS服务商解析，就需要添加NS记录。</span></span><br><span class="line"><span class="attr">MX:</span>     <span class="string">将域名指向邮件服务器地址</span>  <span class="comment"># 如果需要设置邮箱，让邮箱能收到邮件，就需要添加MX记录。</span></span><br><span class="line"><span class="attr">SRV:</span>    <span class="string">记录提供特定服务的服务器</span></span><br><span class="line"><span class="string">显性URL:</span> <span class="string">将域名302重定向到另外一个地址</span></span><br><span class="line"><span class="string">隐性URL:</span> <span class="string">与显性URL类似，但是会隐藏真实目标地址</span></span><br><span class="line"><span class="string">SOA记录:</span> <span class="string">Start</span> <span class="string">of</span> <span class="string">Authority，始授权机构记录。NS用于标识多台域名解析服务器，SOA记录用于在众多NS记录中那一台是主服务器。SOA</span> <span class="string">资源记录表明此</span> <span class="string">DNS</span> <span class="string">名称服务器是为该</span> <span class="string">DNS</span> <span class="string">域中的数据的信息的最佳来源。</span></span><br><span class="line"><span class="attr">PTR:</span> <span class="string">逆向查询记录（Pointer</span> <span class="string">Record），只用于从IP地址查询域名，</span></span><br><span class="line"><span class="string">...</span></span><br></pre></td></tr></table></figure></p><h4 id="万网域名解析为什么没有301重定向？"><a href="#万网域名解析为什么没有301重定向？" class="headerlink" title="万网域名解析为什么没有301重定向？"></a>万网域名解析为什么没有301重定向？</h4><p>URL 重定向服务实际并非DNS 服务，它们在 HTTP 级别运行，而非 DNS 级别。使用URL转发的客户基本都是免费DNS的用户，当前业务暂不会投入支持。</p><p><strong>优先级</strong></p><ul><li>单独设置的域名解析优先级高于泛域名解析</li><li>NS记录优先于A记录。即，如果一个主机地址同时存在NS记录和A记录，则A记录不生效。这里的NS记录只对子域名生效。</li><li>A记录优先于CNAME记录。即如果一个主机地址同时存在A记录和CNAME记录，则CNAME记录不生效</li><li>MX记录可以通过设置优先级实现主辅服务器设置，“优先级”中的数字越小表示级别越高。也可以使用相同优先级达到负载均衡的目的</li></ul><h3 id="主机记录"><a href="#主机记录" class="headerlink" title="主机记录"></a>主机记录</h3><p>主机记录就是域名前缀，常见用法有：<br><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">www:</span> <span class="string">解析后的域名为www.aliyun.com。</span></span><br><span class="line"><span class="string">@:</span> <span class="string">直接解析主域名</span> <span class="string">aliyun.com。</span></span><br><span class="line"><span class="string">*:</span> <span class="string">泛解析，匹配其他所有域名</span> <span class="string">*.aliyun.com。</span></span><br><span class="line"><span class="attr">mail:</span> <span class="string">将域名解析为mail.aliyun.com，通常用于解析邮箱服务器。</span></span><br><span class="line"><span class="string">二级域名:</span> <span class="string">如：abc.aliyun.com，填写abc。</span></span><br><span class="line"><span class="string">手机网站:</span> <span class="string">如：m.aliyun.com，填写m。</span></span><br><span class="line"><span class="string">显性URL:</span> <span class="string">不支持泛解析（泛解析：将所有子域名解析到同一地址）</span></span><br></pre></td></tr></table></figure></p><ol><li>@和WWW是两个主机名，可以指向不同的IP(A记录)或域名(CNAME记录)</li><li>可以为一个主机添加多个A记录 (1. 实现<a href="https://www.alibabacloud.com/help/zh/doc-detail/60182.htm" target="_blank" rel="noopener">负载均衡</a>，2. 可配合解析路线进行<a href="https://www.alibabacloud.com/help/zh/doc-detail/58142.htm" target="_blank" rel="noopener">智能解析</a>)</li><li>一个主机配置了CNAME记录，就不能再为该主机配置其他任何记录 (为啥呢？) 见 <a href="https://www.alibabacloud.com/help/zh/doc-detail/58456.htm" target="_blank" rel="noopener">记录冲突判断规则</a></li></ol><p> 负载均衡的实现：负载均衡(Server Load Balancing，SLB)是指在一系列资源上面动态地分布网络负载。负载均衡可以减少网络拥塞，提高整体网络性能，提高自愈性， 并确保企业关键性应用的可用性。当相同子域名有多个目标地址时，表示轮循，可以达到负载均衡的目的，但需要虚拟主机服务商支持。</p><h3 id="解析路线"><a href="#解析路线" class="headerlink" title="解析路线"></a>解析路线</h3><p>如果多个IP，<a href="https://www.alibabacloud.com/help/zh/doc-detail/58147.htm" target="_blank" rel="noopener">搜索引擎线路</a></p><p>如果只有一个IP地址或CNAME域名，请务必选择【默认】。<br><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">默认:</span> <span class="string">必填！未匹配到智能解析线路时，返回【默认】线路设置结果。</span></span><br><span class="line"><span class="string">世界:</span> <span class="string">向除中国大陆以外的其他国家和地区，返回设置的记录值。</span> <span class="comment"># 可用于双线部署，</span></span><br><span class="line"><span class="string">搜索引擎:</span> <span class="string">向搜索引擎爬虫的DNS，返回设置的记录值。</span></span><br></pre></td></tr></table></figure></p><h3 id="TTL"><a href="#TTL" class="headerlink" title="TTL"></a>TTL</h3><p>（Time to live 的缩写</p><p>TTL为缓存时间，数值越小，修改记录各地生效时间越快。万网DNS的默认值为600，表示600秒之内不用重新查询。</p><h2 id="查看解析是否生效"><a href="#查看解析是否生效" class="headerlink" title="查看解析是否生效"></a>查看解析是否生效</h2><p>怎样查看解析是否生效？</p><h3 id="Windows-用户测试"><a href="#Windows-用户测试" class="headerlink" title="Windows 用户测试"></a>Windows 用户测试</h3><p>修改域名解析，实际上是在域名解析服务商处修改域名解析记录。修改的解析记录是否在用户端生效，既受运营商递归 DNS 服务器的直接影响，也受域名解析服务商提供的权威 DNS 服务器的间接影响。</p><p>测试本地运营商递归 DNS 服务器是否生效<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ nslookup eson.org</span><br><span class="line">服务器: ...  <span class="comment"># 一般返回的是最近的DNS服务器，</span></span><br><span class="line">Address: ...</span><br></pre></td></tr></table></figure></p><!--服务器: crl-ns1.crl.ibm.comAddress: 9.186.88.5--><p>测试域名解析服务商的权威 DNS 服务器是否生效。测试方法如下:</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ nslookup eson.org dns25.hichina.com</span><br></pre></td></tr></table></figure><h3 id="Linux测试"><a href="#Linux测试" class="headerlink" title="Linux测试"></a>Linux测试</h3><p><code>dig 要检测的域名 @dns服务器地址</code></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">$ dig eson.org</span><br><span class="line">; &lt;&lt;&gt;&gt; DiG 9.9.5-3ubuntu0.17-Ubuntu &lt;&lt;&gt;&gt; eson.org</span><br><span class="line">;; global options: +cmd</span><br><span class="line">;; Got answer:  <span class="comment"># 为什么0个answer？</span></span><br><span class="line">;; -&gt;&gt;HEADER&lt;&lt;- opcode: QUERY, status: NOERROR, id: 8309</span><br><span class="line">;; flags: qr rd ra; QUERY: 1, ANSWER: 0, AUTHORITY: 1, ADDITIONAL: 1</span><br><span class="line"></span><br><span class="line">;; OPT PSEUDOSECTION:</span><br><span class="line">; EDNS: version: 0, flags:; udp: 4096</span><br><span class="line">;; QUESTION SECTION:</span><br><span class="line">;eson.org.                      IN      A</span><br><span class="line"></span><br><span class="line">;; AUTHORITY SECTION:   <span class="comment"># 不应该啊，我已经改回阿里的name server了</span></span><br><span class="line">eson.org.               3592    IN      SOA     hugh.ns.cloudflare.com. dns.cloudflare.com. 2027227883 10000 2400 604800 3600</span><br><span class="line"></span><br><span class="line">;; Query time: 112 msec</span><br><span class="line">;; SERVER: 9.0.146.50<span class="comment">#53(9.0.146.50)</span></span><br><span class="line">;; WHEN: Sun Mar 11 18:04:06 CST 2018</span><br><span class="line">;; MSG SIZE  rcvd: 99</span><br></pre></td></tr></table></figure><p>以上部分是不是延迟问题，明天再试试。</p><p>(Update: 第二天测试，果然解析到了<code>xu-song.coding.me</code>. ANSWER: 15, AUTHORITY: 0,)</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">$ dig eson.org vip1.alidns.com</span><br><span class="line">; &lt;&lt;&gt;&gt; DiG 9.9.5-3ubuntu0.17-Ubuntu &lt;&lt;&gt;&gt; eson.org vip1.alidns.com</span><br><span class="line">;; global options: +cmd</span><br><span class="line">;; Got answer:</span><br><span class="line">;; -&gt;&gt;HEADER&lt;&lt;- opcode: QUERY, status: NOERROR, id: 23319</span><br><span class="line">;; flags: qr rd ra; QUERY: 1, ANSWER: 15, AUTHORITY: 0, ADDITIONAL: 1</span><br><span class="line"></span><br><span class="line">;; OPT PSEUDOSECTION:</span><br><span class="line">; EDNS: version: 0, flags:; udp: 4096</span><br><span class="line">;; QUESTION SECTION:</span><br><span class="line">;eson.org.                      IN      A</span><br><span class="line"></span><br><span class="line">;; ANSWER SECTION:  <span class="comment"># 这个就对了。我采用的双线部署。国内走coding.net</span></span><br><span class="line">eson.org.               600     IN      CNAME   xu-song.coding.me.</span><br><span class="line">xu-song.coding.me.      60      IN      A       103.72.147.211</span><br><span class="line">xu-song.coding.me.      60      IN      A       103.72.145.7</span><br><span class="line">xu-song.coding.me.      60      IN      A       23.91.101.50</span><br><span class="line">xu-song.coding.me.      60      IN      A       103.218.240.147</span><br><span class="line">xu-song.coding.me.      60      IN      A       36.255.221.66</span><br><span class="line">xu-song.coding.me.      60      IN      A       107.150.121.91</span><br><span class="line">xu-song.coding.me.      60      IN      A       107.150.121.231</span><br><span class="line">xu-song.coding.me.      60      IN      A       103.72.147.89</span><br><span class="line">xu-song.coding.me.      60      IN      A       103.14.35.185</span><br><span class="line">xu-song.coding.me.      60      IN      A       103.72.146.177</span><br><span class="line">xu-song.coding.me.      60      IN      A       36.255.220.102</span><br><span class="line">xu-song.coding.me.      60      IN      A       23.91.96.142</span><br><span class="line">xu-song.coding.me.      60      IN      A       23.91.97.251</span><br><span class="line">xu-song.coding.me.      60      IN      A       103.218.241.74</span><br><span class="line"></span><br><span class="line">;; Query time: 682 msec</span><br><span class="line">;; SERVER: 9.0.146.50<span class="comment">#53(9.0.146.50)</span></span><br><span class="line">;; WHEN: Sun Mar 11 18:05:55 CST 2018</span><br><span class="line">;; MSG SIZE  rcvd: 292</span><br><span class="line"></span><br><span class="line">;; Got answer:  <span class="comment"># 为什么又有一个query &amp; answer？</span></span><br><span class="line">;; -&gt;&gt;HEADER&lt;&lt;- opcode: QUERY, status: NOERROR, id: 52301</span><br><span class="line">;; flags: qr rd ra; QUERY: 1, ANSWER: 9, AUTHORITY: 0, ADDITIONAL: 1</span><br><span class="line"></span><br><span class="line">;; OPT PSEUDOSECTION:</span><br><span class="line">; EDNS: version: 0, flags:; udp: 4096</span><br><span class="line">;; QUESTION SECTION:</span><br><span class="line">;vip1.alidns.com.               IN      A</span><br><span class="line"></span><br><span class="line">;; ANSWER SECTION:   <span class="comment"># 这是什么鬼？</span></span><br><span class="line">vip1.alidns.com.        600     IN      A       14.1.112.11</span><br><span class="line">vip1.alidns.com.        600     IN      A       140.205.29.113</span><br><span class="line">vip1.alidns.com.        600     IN      A       106.11.30.113</span><br><span class="line">vip1.alidns.com.        600     IN      A       116.211.173.151</span><br><span class="line">vip1.alidns.com.        600     IN      A       106.11.41.151</span><br><span class="line">vip1.alidns.com.        600     IN      A       140.205.1.1</span><br><span class="line">vip1.alidns.com.        600     IN      A       121.29.51.151</span><br><span class="line">vip1.alidns.com.        600     IN      A       140.205.228.51</span><br><span class="line">vip1.alidns.com.        600     IN      A       47.88.44.151</span><br><span class="line"></span><br><span class="line">;; Query time: 389 msec</span><br><span class="line">;; SERVER: 9.0.146.50<span class="comment">#53(9.0.146.50)</span></span><br><span class="line">;; WHEN: Sun Mar 11 18:05:56 CST 2018</span><br><span class="line">;; MSG SIZE  rcvd: 188</span><br></pre></td></tr></table></figure><p>以上命令，第二天竟然变回了cloudflare的name server。why？</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">;; flags: qr rd ra; QUERY: 1, ANSWER: 0, AUTHORITY: 1, ADDITIONAL: 1</span><br><span class="line">...</span><br><span class="line">AUTHORITY SECTION:</span><br><span class="line">eson.org.               3600    IN      SOA     hugh.ns.cloudflare.com. dns.cloudflare.com.</span><br></pre></td></tr></table></figure><p>过几天又变回来了。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">$ dig eson.org dns25.hichina.com</span><br><span class="line">; &lt;&lt;&gt;&gt; DiG 9.9.5-3ubuntu0.17-Ubuntu &lt;&lt;&gt;&gt; eson.org dns25.hichina.com</span><br><span class="line">;; global options: +cmd</span><br><span class="line">;; Got answer:</span><br><span class="line">;; -&gt;&gt;HEADER&lt;&lt;- opcode: QUERY, status: NOERROR, id: 18683</span><br><span class="line">;; flags: qr rd ra; QUERY: 1, ANSWER: 0, AUTHORITY: 1, ADDITIONAL: 1</span><br><span class="line"></span><br><span class="line">;; OPT PSEUDOSECTION:</span><br><span class="line">; EDNS: version: 0, flags:; udp: 4096</span><br><span class="line">;; QUESTION SECTION:</span><br><span class="line">;eson.org.                      IN      A</span><br><span class="line"></span><br><span class="line">;; AUTHORITY SECTION:   <span class="comment"># 这个也有延迟啊。什么情况？dns25.hichina.com与vip1.alidns.com什么区别？是不是有个根节点?</span></span><br><span class="line">eson.org.               3404    IN      SOA     hugh.ns.cloudflare.com. dns.cloudflare.com. 2027227883 10000 2400 604800 3600</span><br><span class="line"></span><br><span class="line">;; Query time: 115 msec</span><br><span class="line">;; SERVER: 9.0.146.50<span class="comment">#53(9.0.146.50)</span></span><br><span class="line">;; WHEN: Sun Mar 11 18:07:14 CST 2018</span><br><span class="line">;; MSG SIZE  rcvd: 99</span><br><span class="line"></span><br><span class="line">;; Got answer:</span><br><span class="line">;; -&gt;&gt;HEADER&lt;&lt;- opcode: QUERY, status: NOERROR, id: 31080</span><br><span class="line">;; flags: qr rd ra; QUERY: 1, ANSWER: 8, AUTHORITY: 0, ADDITIONAL: 1</span><br><span class="line"></span><br><span class="line">;; OPT PSEUDOSECTION:</span><br><span class="line">; EDNS: version: 0, flags:; udp: 4096</span><br><span class="line">;; QUESTION SECTION:</span><br><span class="line">;dns25.hichina.com.             IN      A</span><br><span class="line"></span><br><span class="line">;; ANSWER SECTION:</span><br><span class="line">dns25.hichina.com.      496     IN      A       106.11.211.69</span><br><span class="line">dns25.hichina.com.      496     IN      A       106.11.211.59</span><br><span class="line">dns25.hichina.com.      496     IN      A       106.11.141.129</span><br><span class="line">dns25.hichina.com.      496     IN      A       106.11.141.119</span><br><span class="line">dns25.hichina.com.      496     IN      A       140.205.41.29</span><br><span class="line">dns25.hichina.com.      496     IN      A       140.205.41.19</span><br><span class="line">dns25.hichina.com.      496     IN      A       140.205.81.29</span><br><span class="line">dns25.hichina.com.      496     IN      A       140.205.81.19</span><br><span class="line"></span><br><span class="line">;; Query time: 114 msec</span><br><span class="line">;; SERVER: 9.0.146.50<span class="comment">#53(9.0.146.50)</span></span><br><span class="line">;; WHEN: Sun Mar 11 18:07:14 CST 2018</span><br><span class="line">;; MSG SIZE  rcvd: 174</span><br></pre></td></tr></table></figure><p>以上这个部分，第二天测试竟然不变。为什么会采用cloudflare的DNS服务器呢？</p><p>过几天又变回了coding.me线路。</p><h3 id="测试结果分析"><a href="#测试结果分析" class="headerlink" title="测试结果分析"></a>测试结果分析</h3><p>如果递归 DNS 服务器和权威 DNS 服务器都未生效，表明域名确实没有添加成功。</p><p>如果递归 DNS 服务器未生效，权威 DNS 服务器已生效，表明域名刚添加不久，全球的递归 DNS 服务器未完全同步，需要等待域名配置的 <code>TTL 时间后再次检测</code>是否生效。如果某些个别的运营商递归 DNS 服务器依然未生效，很可能是你遇到了域名劫持或者 DNS 缓存投毒事件。</p><p>参考: <a href="https://www.alibabacloud.com/help/zh/doc-detail/58458.html" target="_blank" rel="noopener">https://www.alibabacloud.com/help/zh/doc-detail/58458.html</a></p><h1 id="修改过-DNS-服务器，多长时间解析可以生效？"><a href="#修改过-DNS-服务器，多长时间解析可以生效？" class="headerlink" title="修改过 DNS 服务器，多长时间解析可以生效？"></a>修改过 DNS 服务器，多长时间解析可以生效？</h1><p><a href="https://www.alibabacloud.com/help/zh/doc-detail/58458.htm" target="_blank" rel="noopener"> 多长时间解析可以生效</a><br>要全球解析生效，得等上一会了，也可以先ping一下自己的设置对不对。阿里云域名服务的工作原理是，在你更新了域名解析之后，首先是阿里的万网云解析，然后传播到各大运营商的DNS服务器，刷新DNS缓存，至此你的域名可以被访问。</p>]]></content>
      
      <categories>
          
          <category> CS </category>
          
          <category> network </category>
          
          <category> 网络协议-OSI七层模型 </category>
          
          <category> 1. 第七层 应用层 </category>
          
          <category> DNS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> domain </tag>
            
            <tag> 建站 </tag>
            
            <tag> github </tag>
            
            <tag> blog </tag>
            
            <tag> pages </tag>
            
            <tag> DNS </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>利用Github Pages搭建独立域名的个人博客</title>
      <link href="/pub/6c2187f/"/>
      <url>/pub/6c2187f/</url>
      <content type="html"><![CDATA[<h1 id="1-购买域名"><a href="#1-购买域名" class="headerlink" title="1. 购买域名"></a>1. 购买域名</h1><p><a href="https://wanwang.aliyun.com/" target="_blank" rel="noopener">阿里云-万网</a> 或其他供应商</p><p><a href="">了解更多域名</a></p><h1 id="2-域名解析-xusong-vip-—-gt-xu-song-github-io"><a href="#2-域名解析-xusong-vip-—-gt-xu-song-github-io" class="headerlink" title="2. 域名解析 (xusong.vip —&gt; xu-song.github.io)"></a>2. 域名解析 (xusong.vip —&gt; xu-song.github.io)</h1><p>域名注册完成后首先需要做域名解析，域名解析就是把域名指向网站所在服务器的IP，让人们通过注册的域名可以访问到网站。</p><h2 id="2-1-配置DNS解析"><a href="#2-1-配置DNS解析" class="headerlink" title="2.1 配置DNS解析"></a>2.1 配置DNS解析</h2><p>进入你的<a href="https://home.console.aliyun.com" target="_blank" rel="noopener">阿里云DNS解析</a>，选择你想要解析的域名，点击后面的解析。如下图所示：<br><img src="https://user-images.githubusercontent.com/13825126/35460092-a97a685a-031d-11e8-9cc6-1ce1b730a917.PNG" alt="dns"></p><blockquote><p>We recommend you change this to a CNAME record pointing at [YOUR USERNAME].github.io.<br>— <a href="https://help.github.com/articles/setting-up-a-custom-subdomain/" target="_blank" rel="noopener">Github Help</a></p></blockquote><p><strong>Github建议采用CNAME记录，为什么？</strong></p><p>因为IP有可能会变动，导致A记录失效吗？不是，是因为所有Github Pages共用ip，Github后台是根据host定位www目录的。详见<a href="">Github Pages原理</a></p><p><strong>阿里云建议采用A记录</strong></p><p>因为A记录限制最少，最灵活，多条不会冲突</p><p>参考<br><a href="/2018/01/26/web/site-dev/host/github-pages/%E5%88%A9%E7%94%A8Github-Pages%E6%90%AD%E5%BB%BA%E7%8B%AC%E7%AB%8B%E5%9F%9F%E5%90%8D%E7%9A%84%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/">DNS解析-解析记录</a></p><h1 id="3-重定向-xu-song-github-io-—-gt-xusong-vip"><a href="#3-重定向-xu-song-github-io-—-gt-xusong-vip" class="headerlink" title="3. 重定向(xu-song.github.io —&gt; xusong.vip)"></a>3. 重定向(xu-song.github.io —&gt; xusong.vip)</h1><h2 id="3-1-配置github-pages的custom-domain"><a href="#3-1-配置github-pages的custom-domain" class="headerlink" title="3.1 配置github pages的custom domain"></a>3.1 配置github pages的custom domain</h2><p>进入你的github pages的仓库，然后在设置里面将的你的域名的地址，添加到custom domain中，然后保存即可。如下图所示：</p><p><img src="https://user-images.githubusercontent.com/13825126/35460275-62ca64a4-031e-11e8-8e43-b15c8b2e1bcc.PNG" alt="default"></p><p>这里是对github.io做了重定向，会重定向到所配置的站点。也可以随便填写一个站点，比如www.baidu.com，也会重定向过去</p><p>细心的同学会发现，配置custom domain后github仓库的根目录多了一个<code>CNAME</code>文件，里面正式刚刚配置的域名地址。</p><h3 id="3-2-重新deploy，你会发现github-page的domain设置又被改回去了，肿么办？"><a href="#3-2-重新deploy，你会发现github-page的domain设置又被改回去了，肿么办？" class="headerlink" title="3.2 重新deploy，你会发现github page的domain设置又被改回去了，肿么办？"></a>3.2 重新deploy，你会发现github page的domain设置又被改回去了，肿么办？</h3><p>原因是，hexo deploy时会采用<code>git push --force</code>。如果deploy版本没有<code>CNAME</code>文件，则会强制删除3.1中添加的CNAME文件，导致custom domain失效。</p><p>因此，最佳的方式是我们手动添加CNAME文件来设置domain。在source目录下新建CNAME文件，内容是<code>xusong.vip</code>。这样每次deploy会自动完成<code>步骤3.1</code>。</p><h2 id="5-疑点重重"><a href="#5-疑点重重" class="headerlink" title="5. 疑点重重"></a>5. 疑点重重</h2><ul><li>[x] 为什么还要再github仓库中设置？dns解析不是已经做了重定向了吗。指向ip:80端口还不够吗？</li><li>[x] 每个账号的gitpage都是独立的IP吗？github怎么这么多独立外网IP？还是不同账号共用IP？</li><li>[x] 不同github page共享ip 正因为如此，才需要<code>步骤3</code>的设置。</li><li>[x]  配置github pages的custom domain，其作用仅仅是<code>xu-song.github.io --&gt; xusong.vip (重定向)</code>吗？</li></ul><p><a href="./github pages原理.md">ss</a></p>]]></content>
      
      <categories>
          
          <category> CS </category>
          
          <category> web </category>
          
          <category> site-dev </category>
          
          <category> host </category>
          
          <category> github-pages </category>
          
      </categories>
      
      
        <tags>
            
            <tag> domain </tag>
            
            <tag> 建站 </tag>
            
            <tag> github </tag>
            
            <tag> blog </tag>
            
            <tag> pages </tag>
            
            <tag> DNS </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>一图知git</title>
      <link href="/pub/cd67fa63/"/>
      <url>/pub/cd67fa63/</url>
      <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>首先，这不是一个git命令教程，这是一个用于快速理解git命令的辅助文档。</p><p>用了git几年了，每次遇到疑难杂症都要现查，归其原因，是不了解git命令背后到底做了什么。</p><p>于是决定整理一下思路。</p><h2 id="术语"><a href="#术语" class="headerlink" title="术语"></a>术语</h2><p><strong>存储位置</strong></p><ul><li>工作区：working_directory，working_tree，workspace</li><li>暂存区：stage, index  (加入到暂存区的更改：staged/indexed changes, add changes to stage/index)</li><li>本地仓库： local_repository, local_commit_history，history</li><li><p>远程仓库：remote_repository</p></li><li><p>快照：snapshot</p></li><li>Blobs:   即files</li></ul><p><strong>文件状态</strong></p><ul><li>Untrack file：新文件，从未被add的文件。下一步操作往往是<code>git add</code>或者加入<code>.gitignore</code>中<br>-</li></ul><p><strong>changes </strong></p><ul><li>Changes to be committed</li><li>Changes not staged for commit</li></ul><p><strong>操作</strong><br>stage操作：git add<br>commit操作：git commit</p><p><strong>指针</strong><br>指针指向实体</p><ul><li>HEAD指针<ul><li>正常状态: 指向一个<branch> (确切说是named branch)</branch></li><li>Detached HEAD: 指向了anonymous branch，即<commit></commit></li><li>null: 不可能出现这个状态</li></ul></li><li>master</li></ul><p><strong>HEAD指针状态</strong></p><p><strong>实体</strong><br>hash</p><p><commit>、<branch>、<tree-ish>、<start point="">什么区别？<br>能写master~吗？能写 jkjdka~吗？</start></tree-ish></branch></commit></p><p>参考 <a href="https://stackoverflow.com/questions/23303549/what-are-commit-ish-and-tree-ish-in-git" target="_blank" rel="noopener">https://stackoverflow.com/questions/23303549/what-are-commit-ish-and-tree-ish-in-git</a></p><h2 id="上图"><a href="#上图" class="headerlink" title="上图"></a>上图</h2><p><img src="/images/raw/Git - summary.svg" height="110%" width="110%"></p><p>有点紧凑，建议放大看</p><h2 id="看图说话"><a href="#看图说话" class="headerlink" title="看图说话"></a>看图说话</h2><p><strong>入门</strong>：<br><a href="https://git-scm.com/docs/git-add" target="_blank" rel="noopener">git add</a> : 读取工作区文件，写入暂存区 (1个箭头代表1个写操作)</p><p><strong>进阶</strong>：</p><p><a href="https://git-scm.com/docs/git-checkout" target="_blank" rel="noopener">git checkout \<branch\></branch\></a>: 移动本地仓库中的HEAD指针到指定branch，更新index，更新工作区文件 (3个箭头)</p><p><a href="https://git-scm.com/docs/git-reset" target="_blank" rel="noopener">git reset —soft</a>：撤销指定commit，移动HEAD (不涉及工作区、暂存区、远程仓库的操作)</p><p>soft mixed hard三个参数的区别也一目了然<br>…</p><h2 id="所有涉及更改index区域的操作"><a href="#所有涉及更改index区域的操作" class="headerlink" title="所有涉及更改index区域的操作"></a><a href="https://git-scm.com/docs/git-commit" target="_blank" rel="noopener">所有涉及更改index区域的操作</a></h2><ul><li>git add</li><li>git rm</li><li><p>by listing files as arguments to the commit command (without —interactive or —patch switch), in which case the commit will ignore changes staged in the index, and instead record the current content of the listed files (which must already be known to Git);</p></li><li><p>by using the -a switch with the commit command to automatically “add” changes from all known files (i.e. all files that are already listed in the index) and to automatically “rm” files in the index that have been removed from the working tree, and then perform the actual commit;</p></li><li><p>by using the —interactive or —patch switches with the commit command to decide one by one which files or hunks should be part of the commit in addition to contents in the index, before finalizing the operation. See the “Interactive Mode” section of git-add[1] to learn how to operate these modes.</p></li></ul><h2 id="逆向操作-undo"><a href="#逆向操作-undo" class="headerlink" title="逆向操作(undo)"></a>逆向操作(undo)</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">git add                 # 加入index</span><br><span class="line">git reset –mixed HEAD   # 撤销index  对不，是checkout吗？</span><br><span class="line"></span><br><span class="line">git commit              #</span><br><span class="line">git reset –soft HEAD~   # 撤销尚未push的commit</span><br><span class="line"></span><br><span class="line">git add + git commit    #</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">git push    </span><br><span class="line">push不支持撤销操作       # 如何撤销已经push的commit？</span><br><span class="line"></span><br><span class="line">git push –force         # 覆盖远程仓库提交历史(太狠)</span><br><span class="line">                        # 参考 https://www.borfast.com/blog/2014/10/19/how-to-undo-a-git-push---force-and-undelete-things/</span><br><span class="line">git rm file             # 删除文件和index</span><br><span class="line">git checkout HEAD file  # 恢复文件和index (index中已经没有该文件的信息，只能从仓库的HEAD中恢复文件)</span><br><span class="line"></span><br><span class="line">git rm -r dir           # 删除整个目录及相应index</span><br><span class="line">git checkout HEAD dir   # 恢复</span><br><span class="line"></span><br><span class="line">git add −p</span><br><span class="line">git reset −p</span><br><span class="line"></span><br><span class="line">git stash</span><br><span class="line">git stash pop</span><br></pre></td></tr></table></figure><p>两个git add 会怎样？会merge为一个吧？git add + rm 前面的add的changes就完全丢了吧？</p><p>If you don’t have <code>uncommited changes</code> for removed files, the</p><p>如何撤销已经push的commit？</p><p>如何撤销已经force push的commit？</p><p><a href="https://www.borfast.com/blog/2014/10/19/how-to-undo-a-git-push---force-and-undelete-things/" target="_blank" rel="noopener">https://www.borfast.com/blog/2014/10/19/how-to-undo-a-git-push---force-and-undelete-things/</a></p><p>Reset</p><h2 id="关于该图的改进"><a href="#关于该图的改进" class="headerlink" title="关于该图的改进"></a>关于该图的改进</h2><ul><li>捡重要的命令放 (init clone不要放)</li><li>布局，整体，有点丑</li></ul><h2 id="待看"><a href="#待看" class="headerlink" title="待看"></a>待看</h2><p><a href="https://github.com/geeeeeeeeek/git-recipes/blob/master/sources/%E6%A3%80%E5%87%BA%E4%BB%A5%E5%89%8D%E7%9A%84%E6%8F%90%E4%BA%A4.md" target="_blank" rel="noopener">https://github.com/geeeeeeeeek/git-recipes/blob/master/sources/%E6%A3%80%E5%87%BA%E4%BB%A5%E5%89%8D%E7%9A%84%E6%8F%90%E4%BA%A4.md</a></p><p><a href="https://github.com/geeeeeeeeek/git-recipes/blob/master/sources/%E4%BB%A3%E7%A0%81%E5%90%88%E5%B9%B6Merge%E8%BF%98%E6%98%AFRebase.md" target="_blank" rel="noopener">代码合并：Merge、Rebase 的选择</a><br><a href="https://github.com/geeeeeeeeek/git-recipes/blob/master/sources/%E9%87%8D%E5%86%99%E9%A1%B9%E7%9B%AE%E5%8E%86%E5%8F%B2.md" target="_blank" rel="noopener">重写项目历史</a><br><a href="https://github.com/geeeeeeeeek/git-recipes/blob/master/sources/%E5%B8%B8%E8%A7%81%E5%B7%A5%E4%BD%9C%E6%B5%81%E6%AF%94%E8%BE%83.md" target="_blank" rel="noopener">常见工作流比较</a></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://stackoverflow.com/questions/292357/what-is-the-difference-between-git-pull-and-git-fetch/292359" target="_blank" rel="noopener">https://stackoverflow.com/questions/292357/what-is-the-difference-between-git-pull-and-git-fetch/292359</a></li><li><a href="https://git-scm.com/docs" target="_blank" rel="noopener">官方doc</a></li><li><a href="http://marklodato.github.io/visual-git-guide/index-zh-cn.html" target="_blank" rel="noopener">图解git</a></li></ul><h2 id="待续"><a href="#待续" class="headerlink" title="待续"></a>待续</h2>]]></content>
      
      <categories>
          
          <category> CS </category>
          
          <category> tools </category>
          
          <category> 同步与版本管理 </category>
          
          <category> git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Gist 从入门到精通到放弃</title>
      <link href="/pub/d051a027/"/>
      <url>/pub/d051a027/</url>
      <content type="html"><![CDATA[<h1 id="gist简介"><a href="#gist简介" class="headerlink" title="gist简介"></a>gist简介</h1><h2 id="官方描述"><a href="#官方描述" class="headerlink" title="官方描述"></a>官方描述</h2><blockquote><p>Gists are a great way to share your work. You can share single files, parts of files, or full applications.</p></blockquote><p>关键词: <code>share</code>, <code>single</code>, <code>parts</code>。gist的定位就在这几个词里。</p><h2 id="详解"><a href="#详解" class="headerlink" title="详解"></a>详解</h2><ul><li>为了强调<code>single</code>和<code>parts</code>，gist对git进行阉割，禁用了directory功能。(貌似还禁用了pull功能)</li><li>为了强调<code>share</code>，在原来<code>Clone</code>的基础上，额外引入了<code>Embed</code>和<code>Share</code>两个功能。其中<code>Embed</code>(嵌入)实现了仅通过一行JS就能分享到网站(share your work in your website)</li></ul><ul><li>既然要<code>share</code>，那就不能没有feedback，这就像作presentation有问答环节一样。于是加入了<code>comments</code>功能。</li></ul><h2 id="Gist背后的Git库"><a href="#Gist背后的Git库" class="headerlink" title="Gist背后的Git库"></a>Gist背后的Git库</h2><p>创建的每一个Gist的背后都对应着一个Git版本库</p><h1 id="gist-推荐用法"><a href="#gist-推荐用法" class="headerlink" title="gist 推荐用法"></a>gist 推荐用法</h1><p><strong>推荐用法</strong></p><ol><li>不宜用Gist<ul><li>含图片等文件的项目<br><br> 因为Gist不支持directory，file&amp;image最好放在其他地方。<br><br> 最省事的方法：1. 在comment里upload image  2. 在gist doc中引用 3. 删除1中的comment</li><li>多个文件的项目</li></ul></li><li>先在comments里写好doc<ul><li>主doc不支持markdown preview</li><li>主doc有提交慢。因为主doc具有版本管理功能，comments不需要。所以频繁改动状态的doc也最好在comments里写，成形后再放入repo。</li></ul></li><li>用embed js的方式<code>发布gist</code><ul><li>解决了多个blog的同步问题</li><li>节省blog服务器存储空间</li></ul></li><li>host站点不支持嵌入js怎么办？<ul><li>知乎、博客、github.io都不支持js</li></ul></li><li>存放<code>ipynb</code>文件<ul><li><code>ipynb</code>一般也是单文件程序(教程)，很适合用gist来管理</li></ul></li></ol><p><strong>禁忌用法</strong><br>两个终端同时修改同一个comment，会已最后提交的为准，有内容丢失的风险（不可逆）。</p><h1 id="gist-代码片段用法"><a href="#gist-代码片段用法" class="headerlink" title="gist 代码片段用法"></a>gist 代码片段用法</h1><p><strong>片段的优势体现在</strong>：</p><ul><li>embed。比如一篇博客里面，要贴个代码片段，可直接引用gist。</li><li>据说搜索也有优势</li></ul><h2 id="gistBox-cacher-用法"><a href="#gistBox-cacher-用法" class="headerlink" title="gistBox / cacher 用法"></a>gistBox / cacher 用法</h2><h2 id="技巧"><a href="#技巧" class="headerlink" title="技巧"></a>技巧</h2><p><strong>文件排序</strong>： 根据文件名的ascii排序，数字&gt; 大写&gt; 小写<br><strong>快捷键</strong>：用Ctrl或者Cmd按着鼠标多处点击进行多选!用中键或者alt进行拖动实现拉选!</p><h1 id="缺陷"><a href="#缺陷" class="headerlink" title="缺陷"></a>缺陷</h1><ul><li>主doc不能preview</li><li>gist embed方式嵌入页面，样式固定，不能自适应网站主题。另外背景是白色，不能融入网站的主题背景。<br>-</li></ul><h1 id="疑问"><a href="#疑问" class="headerlink" title="疑问"></a>疑问</h1><p><strong>为什么要偏要对gist设置private和anonymous？git和wiki却没有，设计初衷是什么？</strong></p><p><strong>为什么gist不开放directory？</strong><br>阉割了这个功能，图片等raw文件就不适宜放在gist了</p><p><strong>gist不提供Pull Request功能？</strong></p><h1 id="类似组件"><a href="#类似组件" class="headerlink" title="类似组件"></a>类似组件</h1><p>bitbucket的Snippets。 不提供<code>embed</code>嵌入方式</p><h1 id="reference"><a href="#reference" class="headerlink" title="reference"></a>reference</h1><ul><li><a href="http://www.worldhello.net/gotgithub/06-side-projects/gist.html" target="_blank" rel="noopener">http://www.worldhello.net/gotgithub/06-side-projects/gist.html</a></li></ul>]]></content>
      
      <categories>
          
          <category> CS </category>
          
          <category> tools </category>
          
          <category> 同步与版本管理 </category>
          
          <category> git </category>
          
          <category> github </category>
          
      </categories>
      
      
        <tags>
            
            <tag> github </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>github中的git gist wiki区别</title>
      <link href="/pub/ef977b92/"/>
      <url>/pub/ef977b92/</url>
      <content type="html"><![CDATA[<h2 id="git-gist-wiki-区别"><a href="#git-gist-wiki-区别" class="headerlink" title="git gist wiki 区别"></a>git gist wiki 区别</h2><ul><li>git: 这里指 github.com中的repo</li><li>gist: gist.github.com</li><li>wiki: github.com/ wiki</li></ul><p>三者都是repo，都记录历史。详细对比如下</p><div class="table-container"><table><thead><tr><th></th><th>github repo</th><th>gist</th><th>wiki</th><th>注解</th></tr></thead><tbody><tr><td><a href="https://github.com/github/markup#markups" target="_blank" rel="noopener">markup支持</a></td><td>.md .textile .org .rst .wiki …</td><td>同上</td><td>同上</td><td></td></tr><tr><td>previw_所见即所得</td><td>√</td><td>×</td><td>√</td><td>可在gist的comment中preview</td></tr><tr><td>MathJax</td><td>×</td><td>×</td><td>×</td><td>gitpage支持</td></tr><tr><td>private space</td><td>收费</td><td>√</td><td></td><td>gist的private repo不能设置密码。不知道搜索引擎能不能搜到</td></tr><tr><td>anonymous</td><td>×</td><td>√</td><td>×</td><td>Gist提供匿名发布，有时候被用来议论政府，政府害怕所以给墙掉了(DNS污染)</td></tr><tr><td>directory</td><td>√</td><td>×</td><td>√</td><td>gist是平行文档(一般只一个page)，不支持子目录</td></tr><tr><td>fork &amp; clone</td><td>√</td><td>√</td><td>√</td><td></td></tr><tr><td>comments</td><td>×</td><td>√</td><td>×</td><td>issue可视为git和wiki的comments，</td></tr><tr><td>多人协作</td><td>√</td><td>√</td><td>√</td><td></td></tr><tr><td>直接用途、设计思想</td><td>代码版本管理、协作</td><td>分享代码片断</td><td>写文档</td><td>snippet什么用？</td></tr><tr><td>博客</td><td>github.io</td><td></td><td></td><td>gist的embed方式很适合博客，但是多数网站不支持嵌入js</td></tr><tr><td>搜索引擎友好性</td><td></td><td></td><td></td><td>gist 在google搜索的 rank较高(据说)</td></tr><tr><td>缺点</td><td></td><td>不易归类</td><td></td></tr></tbody></table></div><p>其他特征</p><ul><li>gist_comment ≈ git_issue  (issue多支持了几种附件类型而已)</li><li>GitHub Pages. 这个除了展示静态的网页(网站)之外并没有什么神奇的功能。它对各种文本文档的渲染支持, 比如 .md, .rst, .org 等.</li></ul><h2 id="gitpage"><a href="#gitpage" class="headerlink" title="gitpage"></a>gitpage</h2><p>官方定义：</p><blockquote><p>GitHub Pages is deeply integrated with Jekyll, a popular static site generator designed for blogging and software documentation, but used for much more.</p></blockquote><ul><li>github markdown 不支持动态js。</li><li>gitpages 不支持动态语言，什么意思？不支持js？还是不支持restapi，数据库，不支持UGC(评论，在线写博客)</li></ul><p>注意区别这俩。markdown是连js都不支持。gitpage支持了js，但不支持backend</p>]]></content>
      
      <categories>
          
          <category> CS </category>
          
          <category> tools </category>
          
          <category> 同步与版本管理 </category>
          
          <category> git </category>
          
          <category> github </category>
          
      </categories>
      
      
        <tags>
            
            <tag> github </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Github Pages托管静态博客-原理浅析</title>
      <link href="/pub/bfc2ae40/"/>
      <url>/pub/bfc2ae40/</url>
      <content type="html"><![CDATA[<h2 id="关于github提供的http-server"><a href="#关于github提供的http-server" class="headerlink" title="关于github提供的http server"></a>关于github提供的http server</h2><h4 id="ping-几个不同账号的gitpage-比如colah-github-io-xu-song-github-io-，发现对应的是同一个ip。为什么返回的页面不同呢？"><a href="#ping-几个不同账号的gitpage-比如colah-github-io-xu-song-github-io-，发现对应的是同一个ip。为什么返回的页面不同呢？" class="headerlink" title="ping 几个不同账号的gitpage(比如colah.github.io,xu-song.github.io)，发现对应的是同一个ip。为什么返回的页面不同呢？"></a>ping 几个不同账号的gitpage(比如<code>colah.github.io</code>,<code>xu-song.github.io</code>)，发现对应的是同一个ip。为什么返回的页面不同呢？</h4><p>github pages 的 CNAME 是绑定 pages.github.io，不是${username}.github.io</p><p>coding.net 的 CNAME 是绑定 pages.coding.me </p><p>显然，Github肯定在后台做了处理。即github自身会维护一个映射，<code>host_name --&gt; www_path</code>，这样就可以根据不同的host信息返回不同的html了。</p><p>这样，在访问<code>xu-song.github.io</code>时github就找到了该返回的html。</p><h2 id="关于custom-domain"><a href="#关于custom-domain" class="headerlink" title="关于custom domain"></a>关于custom domain</h2><p>现在我们改用<code>custom domain</code>的方式访问gitpage主页。假设已经配置好了dns的A记录映射。<br>访问<code>xusong.vip</code>，dns解析得到ip地址。然而这次github服务器得到的host是<code>xusong.vip</code>。懵逼了，github不认识<code>xusong.vip</code>(host数据里没有该记录)，返回404页面</p><image src="https://user-images.githubusercontent.com/13825126/35623051-fc61df6c-06c4-11e8-89a7-6207bc430d85.PNG" style="width: 60%;"><p><strong>怎么办呢？</strong></p><p>那就让github认识一下<code>xusong.vip</code>，也就是在github page里设置一下custom domain，或者添加CNAME文件，详见<a href="../利用Github Pages搭建独立域名的个人博客/">用Github Pages搭建独立域名的个人博客</a></p><ul><li>[ ] 如果DNS设置CNAME记录，是不是github page不用设置就能work？</li></ul><h2 id="那么上一篇中的重重疑点也就解开了"><a href="#那么上一篇中的重重疑点也就解开了" class="headerlink" title="那么上一篇中的重重疑点也就解开了"></a>那么上一篇中的重重疑点也就解开了</h2><ul><li>[x] 每个账号的gitpage都是独立的IP吗？github怎么这么多独立外网IP？还是不同账号共用IP？<ul><li>很多账号是同一个ip。</li></ul></li><li>[x] 不同github page共享ip 正因为如此，才需要<code>步骤3</code>的设置。</li><li>[x]  配置github pages的custom domain，其作用仅仅是<code>xu-song.github.io --&gt; xusong.vip (重定向)</code>吗？<ul><li>不是。1. 查dns解析是否通过 2. 部署到github服务器的相应目录（因为） 3. github page到domain的重定向</li></ul></li></ul><h2 id="关于https"><a href="#关于https" class="headerlink" title="关于https"></a>关于https</h2><h3 id="为什么Github-Pages不支持为自定义域名添加SSL证书？"><a href="#为什么Github-Pages不支持为自定义域名添加SSL证书？" class="headerlink" title="为什么Github Pages不支持为自定义域名添加SSL证书？"></a>为什么Github Pages不支持为自定义域名添加SSL证书？</h3><p><a href="https://steffan.cn/2017/03/22/use-cloudflare-to-implement-HTTPS-for-GithubPages-with-custom-domain-names/" target="_blank" rel="noopener">https://steffan.cn/2017/03/22/use-cloudflare-to-implement-HTTPS-for-GithubPages-with-custom-domain-names/</a></p><h2 id="多个域名能否指向同一个-GitHub-Pages？"><a href="#多个域名能否指向同一个-GitHub-Pages？" class="headerlink" title="多个域名能否指向同一个 GitHub Pages？"></a>多个域名能否指向同一个 GitHub Pages？</h2><p>GitHub Pages 的官方文档，一个 username.github.io 只能支持一个域名。</p><p>coding page支持多个域名。</p><h2 id="一个账号能否见多个github-page？"><a href="#一个账号能否见多个github-page？" class="headerlink" title="一个账号能否见多个github page？"></a>一个账号能否见多个github page？</h2><p>可以建立多个， 个人账户page只能有一个， 项目page可以有多个</p><p>比如你的账号名为  username, 项目叫 project1    那你可以通过  username.github.io/project1 访问， 如果配置了个人域名就可以用自己的域名访问了</p><p>但是CNAME不能指向username.github.io/project1，怎么办？</p><h2 id="todo"><a href="#todo" class="headerlink" title="todo"></a>todo</h2><ul><li>[ ] 如何解决md同步问题？<ul><li>git-repo源，gist源，git issue源，gitpage源。最优的方式就是同源 + 自动deploy。</li><li>方式一：以issue作源，要自己利用github api，读取issue，然后写到source目录(貌似也挺简单)。</li><li>方式二：以git-repo作源，貌似不错哎。单独把source目录单独作为repo</li><li>方式三：以gist作源：易集成(一行js即可)，但不易管理(不支持directory，文档多了很麻烦)</li></ul></li><li>[ ] 如何实现在线写blog，像wordpress那样<ul><li>用js调用github api，或者其他后台api即可</li></ul></li></ul></image>]]></content>
      
      <categories>
          
          <category> CS </category>
          
          <category> web </category>
          
          <category> site-dev </category>
          
          <category> host </category>
          
          <category> github-pages </category>
          
      </categories>
      
      
        <tags>
            
            <tag> github </tag>
            
            <tag> blog </tag>
            
            <tag> pages </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>google云主机---GCE</title>
      <link href="/pub/3329d7fc/"/>
      <url>/pub/3329d7fc/</url>
      <content type="html"><![CDATA[<h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p><a href="https://cloud.google.com/free/?hl=zh-cn" target="_blank" rel="noopener">GCP 免费方案</a><br>送您 $300 赠金和 12 个月免费试用期，帮助您顺利上手。更有“始终免费”<em>产品助您一路前行。</em>随时可能更改<br><img src="https://user-images.githubusercontent.com/13825126/35475026-57ca6be4-03d2-11e8-9551-9af4410e254b.PNG" alt="default"></p><p>只要绑定信用卡就送300刀，能免费用一年</p><image src="https://user-images.githubusercontent.com/13825126/35471148-9fda0c4c-0390-11e8-8167-6484aac58ab5.PNG"><p><a href="https://console.cloud.google.com/?hl=zh-cn" target="_blank" rel="noopener">GCP控制台</a></p><h3 id="开通"><a href="#开通" class="headerlink" title="开通"></a>开通</h3><p>google云只支持以下几种信用卡。不支持中国银联<br>2: masterCard<br>3: 美国运通或JCB<br>4:: visa<br>5:mastercard</p><p>开通后，消费1美元，是什么意思？ (先消费1美元，再撤销1美元)</p><h3 id="价格-amp-配置"><a href="#价格-amp-配置" class="headerlink" title="价格&amp; 配置"></a>价格&amp; 配置</h3><p><strong>综述</strong>：GCE是主机部分按时间计费的，网络部分是按流量计费的，跟AWZ一样<br>（与cpu和内存使用率无关，那就可劲用吧）<br>(时间是使用时间，还是申请时间？关机算时间吗？关机不收费，那可以多开几个vm)<br>(流量是怎么算？下载conda，软件包也算流量？)</p><p>GCE 的价格比较亲民，最低配 1 共享核-0.6 GB 内存-10GB HDD 每月只需要不到 5 美元，而且由于 CPU、内存大小和磁盘大小都是可调的，所以可以根据自己的需要去购买最适合的，能省去不必要的开销。</p><div class="table-container"><table><thead><tr><th>GCE服务内容</th><th>估算费用</th><th>折扣</th><th>总计</th><th>备注</th></tr></thead><tbody><tr><td>1 个共享 vCPU + 0.6 GB 内存</td><td>$5.55/月</td><td>- $1.66/月</td><td>$4.28/月</td><td>内存小了点</td></tr><tr><td>1 个共享 vCPU + 1.7 GB 内存</td><td>$19.71/月</td><td>- $5.91/月</td><td>$14.20/月</td><td></td></tr><tr><td>1 个 vCPU + 3.75 GB 内存</td><td>$34.67/月</td><td>- $10.40/月</td><td>$24.67/月</td><td></td></tr><tr><td>2 个 vCPU + 7.5 GB 内存</td><td>$69.35/月</td><td>- $20.81/月</td><td>$48.95/月</td><td></td></tr><tr><td>..</td><td></td><td></td><td></td><td></td></tr><tr><td>10 GB 标准永久性磁盘</td><td>$0.40/月</td><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td><td></td><td></td></tr><tr><td>1 个 GPU NVIDIA Tesla K80</td><td>$328.50/月</td><td>- $108.95/月</td><td>$254.62/月</td><td>1. 共享 vCPU 不支持 GPU</td></tr><tr><td>1 个 GPU NVIDIA Tesla P100</td><td>$1,065.80/月</td><td>- $330.14/月</td><td>$770.73/月</td><td>2. 简直敲诈，不如自己买。另外仅特定区域才有GPU支持</td></tr></tbody></table></div><p>不同地区价格有差异，<strong>美国服务器价格最便宜</strong>，亚洲欧洲比美国本土贵点。</p><p><strong>可用性策略</strong></p><ul><li>抢占：该模式能够获得更低廉的价格，但是不能用做需要长期保持在线的服务（比如 Web 服务），它最长的使用期限是 24 小时，然而在我的使用中，它有时候不到 1 小时就会被终止使用。它只适合短时间去计算一些东西，计算完后中止它，平常的一般使用不要开启此功能。</li><li>自动重启：推荐开启，以获得在云端的好处，以及更好的 Uptime</li><li>主机维护期间：推荐选择 “迁移”，原因同上</li><li>IP 转发：建议关闭，几乎不会用得着此功能，关闭有助于提高安全性</li><li>SSH：这可能不同于其他一些 VPS，它默认不自动生成用户密码，所以为了远程登录必须配置好公钥私钥。而且所填写的公钥末尾的用户名是有作用的，所填写的用户名就是所需要登录的用户名，默认不支持 root 登陆，除非你将用户名设置成了 root。</li></ul><p><strong>流量</strong><br>流量的话对于所有的可用区，连中国大陆 $0.23/Gbyte、美欧地区 $0.12/Gbyte，流量的价格有些小贵，但是如果是连接 Google 自己的服务的话（包括但不限于 Gmail、YouTube），流量不计费（但是流量是双向的，所以是本地通过 GCE 上传完全免费，下载还是原价）。<br>流量另算钱，起步50g，因此最低配只要不超流量就可以用上一年。</p><p>GCE 还有一点比较特殊的是它是按分钟计费的，当服务处于终止状态（相当于关机，磁盘数据保留）时，不收取费用（除了少量的磁盘使用费用）。每次计算 Uptime 时，如果不到 10 分钟则一律按十分钟算，超过 10 分钟后才是真正的按分钟计费，不过还是很划算了</p><h2 id="ssh-登录"><a href="#ssh-登录" class="headerlink" title="ssh 登录"></a>ssh 登录</h2><p><strong>首先在浏览器窗口中打开ssh</strong></p><p><img src="https://user-images.githubusercontent.com/13825126/35474073-05e92d82-03c4-11e8-8db5-3fe45a631a50.PNG" alt="default"></p><ol><li>创建实例后设置当前用户的新密码</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ sudo passwd $&#123;whoami&#125; // 下面以 user 代替 $&#123;whoami&#125;</span><br><span class="line"># 输入新密码</span><br></pre></td></tr></table></figure><p>设置下 root 的新密码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ sudo passwd root</span><br><span class="line"># 输入新密码</span><br></pre></td></tr></table></figure></p><p><strong>在本地生成私钥和公钥</strong></p><p><strong>复制公钥</strong></p><p><strong>导入公钥到google VM</strong><br>方法一：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">进入谷歌云平台页面 -&gt; 计算引擎 -&gt; 元数据 -&gt; SSH 密钥，粘贴保存</span><br><span class="line"> 谷歌就会把上面这段 public key 写入到 ~/.ssh/authorized_keys</span><br></pre></td></tr></table></figure></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ cat ~/.ssh/authorized_keys</span><br></pre></td></tr></table></figure><p>cat ~/.ssh/authorized_keys文件，检查是否已经存在了刚刚的公钥</p><p>如果不work。就手动生成这个文件，然后拷贝public key</p><p><strong>本地通过 SSH 密码验证登录</strong></p><h3 id="用途"><a href="#用途" class="headerlink" title="用途"></a>用途</h3><p><strong>VPS</strong></p><p><strong>代理</strong></p><p><strong>web应用主机</strong></p><h3 id="GCE-云主机"><a href="#GCE-云主机" class="headerlink" title="GCE 云主机"></a>GCE 云主机</h3><p>google computer engine</p><p>Compute Engine 可让您使用在 Google 基础架构上运行的虚拟机。从微型 VM 到运行 Debian、Windows 或其他标准映像的大型虚拟机一应俱全。创建您的第一个 VM 实例并通过 CloudEndure 迁移服务导入该实例，或通过快速入门指南构建示例应用。</p><p>据说GCE 在国内经常不稳定</p><p>GCE 的后台配置页面虽不能在中国访问，但是其 GCE 实例是可以在中国访问的。(什么意思？)</p><h2 id="评价"><a href="#评价" class="headerlink" title="评价"></a>评价</h2><p>速度超快，下载tensorflow 116MB/s</p><h3 id="reference"><a href="#reference" class="headerlink" title="reference"></a>reference</h3><p><a href="https://guozeyu.com/2016/10/asia-google-compute-engine/" target="_blank" rel="noopener">https://guozeyu.com/2016/10/asia-google-compute-engine/</a><br><a href="https://www.jianshu.com/p/57e85cf3e50b" target="_blank" rel="noopener">SSH 连接配置</a></p><h3 id="app-engine-云应用"><a href="#app-engine-云应用" class="headerlink" title="app engine 云应用"></a>app engine 云应用</h3><p><a href="https://console.cloud.google.com/home/dashboard" target="_blank" rel="noopener">谷歌云平台</a></p></image>]]></content>
      
      <categories>
          
          <category> CS </category>
          
          <category> cloud </category>
          
          <category> google </category>
          
      </categories>
      
      
        <tags>
            
            <tag> cloud </tag>
            
            <tag> google </tag>
            
            <tag> GPU </tag>
            
            <tag> computer engine </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>【hexo系列】hexo的正确打开方式</title>
      <link href="/pub/d3c1b8ca/"/>
      <url>/pub/d3c1b8ca/</url>
      <content type="html"><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><h2 id="核心思想"><a href="#核心思想" class="headerlink" title="核心思想"></a>核心思想</h2><ul><li>利用submodule管理blog  <!--模块化，解耦合，易整合。hexo本身就是模块化很好的例子。cli server分离，主hexo与theme分离。generator deployer render分离。推荐一个模块化比较好的例子 https://github.com/distillpub--><ul><li>先fork再add submodule</li></ul></li><li>利用branch管理自己的project和需要PR的project<!--> 主要目的也是为了不和自己的修改绞在一起产生混乱。比如我从next仓库fork到我自己的仓库，然后我做了一些只用于我自己的个性化修改，这时候我的master分支和远程master分支之间的变动越来越大了。然后我碰到一个适用于所有人的变动，这时候想提交个pr，最好的方式显然是切换到远程master分支，然后做修改，之后提交到一个新的分支，再然后就可以去github上提交pr了，不会把自己master上的一些修改混到里面不过如果自己master和远程master始终保持完全一致的话倒是可以直接提交到自己master上，然后直接用自己master分支提交pr--></li></ul><h2 id="实现细节"><a href="#实现细节" class="headerlink" title="实现细节"></a>实现细节</h2><ul><li>主仓库 blog<ul><li><code>themes/next/</code> 每个theme是一个子仓库  <!--(经常pull一下主题，有很多新功能和bug-fix。不用为了增加某些功能而自己改模板源文件，比如busuanzi，disqus的lazy_load)--></li><li><code>source/post/</code> 作为一个子仓库  </li><li><code>source/image/</code> 作为一个子仓库<!--(可多终端同步文章),属于博客无关的。日常笔记--><!--`source/public` 如果文件可以被渲染的话，会经过解析然后储存到 public 文件夹，否则会直接拷贝到 public 文件夹。--></li></ul></li></ul><p><strong>模块搭建&amp;整合流程</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1. fork hexo-starter 作为blog主仓库</span></span><br><span class="line">$ git <span class="built_in">clone</span> --recursive git@github.com:esblog/hexo-starter.git blog</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. 添加 submodule</span></span><br><span class="line"><span class="comment"># 2.1 fork theme &amp; add submodule</span></span><br><span class="line">$ <span class="built_in">cd</span> blog/themes/</span><br><span class="line">$ git submodule add git@github.com:esblog/hexo-theme-next.git next</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2.2 fork _post &amp; add submodule</span></span><br><span class="line">$ git submodule add git@github.com:esblog/_posts.git</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 2.3 fork project-u-like &amp; add submodule</span></span><br><span class="line">$ mkdir blog/<span class="built_in">source</span>/games/ &amp;&amp; <span class="built_in">cd</span> blog/<span class="built_in">source</span>/games/</span><br><span class="line">$ git submodule add git@github.com:esblog/2048.git</span><br><span class="line"></span><br><span class="line"><span class="comment"># 检查是否添加成功</span></span><br><span class="line">$ vi .gitmodules</span><br><span class="line"></span><br><span class="line"><span class="comment"># 3. push到blog主仓库 (整合)</span></span><br><span class="line"><span class="built_in">cd</span> blog/</span><br><span class="line">git commit -m <span class="string">"add submodules hexo-theme-next source/_post games/2048"</span></span><br><span class="line">git push -u origin master</span><br></pre></td></tr></table></figure><blockquote><p>Note: 如果你嫌fork太多，那么可以开一个github小号，管理这些fork。<br>github主账号只放deploy版本。</p></blockquote><p>实例：</p><ul><li><a href="https://github.com/esblog/esblog.github.io/tree/dev" target="_blank" rel="noopener">Dev Repository</a> Main project for all submodules</li><li><a href="https://github.com/esblog/esblog.github.io/" target="_blank" rel="noopener">Deployed Repository</a> is deployed by Hexo from <code>Dev Repository</code></li><li><a href="http://xusong.vip" target="_blank" rel="noopener">Demo Site</a> hosts the <code>Deployed Repository</code></li></ul><h1 id="常用操作"><a href="#常用操作" class="headerlink" title="常用操作"></a>常用操作</h1><h2 id="push"><a href="#push" class="headerlink" title="push"></a>push</h2><ul><li>每个module独立push</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1. commit changes from all submodules (e.g. _posts)</span></span><br><span class="line">$ <span class="built_in">cd</span> _posts</span><br><span class="line">$ commit &amp; push</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. commit changes from esblog.github.io</span></span><br><span class="line">$ <span class="built_in">cd</span> blog</span><br><span class="line">$ commit &amp; push</span><br></pre></td></tr></table></figure><h2 id="pull-amp-merge"><a href="#pull-amp-merge" class="headerlink" title="pull &amp; merge"></a>pull &amp; merge</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git pull &amp;&amp; git submodule init &amp;&amp; git submodule update &amp;&amp; git submodule status</span><br></pre></td></tr></table></figure><h2 id="clone-amp-setup"><a href="#clone-amp-setup" class="headerlink" title="clone &amp; setup"></a>clone &amp; setup</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># master用于Gitpage的部署</span></span><br><span class="line">$ git <span class="built_in">clone</span> -b dev --recursive git@github.com:esblog/esblog.github.io.git blog-dev</span><br><span class="line">$ <span class="built_in">cd</span> blog-dev</span><br><span class="line">$ git branch <span class="comment"># 确认已经切换到dev分支</span></span><br><span class="line">$ npm install hexo --save  <span class="comment"># install node_modules dependency</span></span><br><span class="line">$ hexo s</span><br><span class="line">$ hexo d</span><br></pre></td></tr></table></figure><h1 id="其他操作"><a href="#其他操作" class="headerlink" title="其他操作"></a>其他操作</h1><h2 id="从官方更新模块（操作较少）"><a href="#从官方更新模块（操作较少）" class="headerlink" title="从官方更新模块（操作较少）"></a>从官方更新模块（操作较少）</h2><p>比如，theme-next有些新功能 如何更新到自己的博客中？</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git pull https://github.com/theme-next/hexo-theme-next.git</span><br><span class="line"><span class="comment"># 如果有冲突，需要人工merge</span></span><br></pre></td></tr></table></figure><p>也可在<a href="https://github.com/esblog/hexo-theme-next" target="_blank" rel="noopener">theme的github界面</a>pull &amp; merge</p><h2 id="其他操作建议"><a href="#其他操作建议" class="headerlink" title="其他操作建议"></a>其他操作建议</h2><ul><li>每个post都加date，不然每次编辑文档，时间都会变动</li><li>draft 可以放在<code>_draft</code>目录下，当然我更习惯放在<code>_post/</code>中，文件名<code>_</code>开头即可，或者整个目录<code>_</code>开头。</li><li>文件名不要经常变动(因为会改变url)，title和path可以随时改动</li></ul><h2 id="非法操作"><a href="#非法操作" class="headerlink" title="非法操作"></a>非法操作</h2><ul><li>在<code>Deployed Repository</code>人工提交。(除非你不用hexo d命令，或不用hexo)<br>-</li></ul>]]></content>
      
      <categories>
          
          <category> CS </category>
          
          <category> web </category>
          
          <category> blog-framework </category>
          
          <category> nodejs-hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>渣渣中的渣渣 之 DaoVoice</title>
      <link href="/pub/9ff21bc3/"/>
      <url>/pub/9ff21bc3/</url>
      <content type="html"><![CDATA[<h2 id="垃圾中的垃圾-之-DaoVoice"><a href="#垃圾中的垃圾-之-DaoVoice" class="headerlink" title="垃圾中的垃圾 之 DaoVoice"></a>垃圾中的垃圾 之 DaoVoice</h2><p>特点：高延迟</p><p>你如果用过DaoVoice的话，肯定知道它延迟很长。但是为什么延迟这么长呢，下面来看看。</p><p>通常web-chat都采用websocket。<br>html—server—html<br>就是一堆的websocket连接</p><p>反应特别慢，消息的发送和接收，在websocket中并未看到。</p><p><strong>消息的发送</strong><br><a href="https://im.daovoice.io/v1/conversations/b1fba959-a843-43ca-9538-928a1cdfd62d/reply" target="_blank" rel="noopener">https://im.daovoice.io/v1/conversations/b1fba959-a843-43ca-9538-928a1cdfd62d/reply</a><br>的request payload参数进行明文传输的。</p><p><strong>消息的接收</strong><br><a href="https://im.daovoice.io/v1/conversations/b1fba959-a843-43ca-9538-928a1cdfd62d/read" target="_blank" rel="noopener">https://im.daovoice.io/v1/conversations/b1fba959-a843-43ca-9538-928a1cdfd62d/read</a></p><p>消息接收并非是服务器推送的，而是每次客户端主动发送消息时才会触发消息接收。(DaoVoice的设计也太挫了吧，这可不是一般的延迟啊，根本不能叫instant message)</p><p>开了个websocket，什么事都不干，发一些没用的数据。</p><h2 id="dao-voice原理"><a href="#dao-voice原理" class="headerlink" title="dao voice原理"></a>dao voice原理</h2><p>基于websocket</p><p>Request<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Request URL:wss://rtm.daovoice.io/socket.io/?EIO=3&amp;transport=websocket&amp;sid=-ezTav4AxWfvgBszAjuI</span><br><span class="line">Request Method:GET</span><br><span class="line">Status Code:101 Switching Protocols</span><br></pre></td></tr></table></figure></p><p>Response header<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Connection:upgrade</span><br><span class="line">Date:Tue, 06 Feb 2018 01:52:13 GMT</span><br><span class="line">Sec-WebSocket-Accept:+vrxS3Tw4HDKi3JDS5wRL7vIqKc=</span><br><span class="line">Sec-WebSocket-Extensions:permessage-deflate</span><br><span class="line">Server:nginx/1.9.13</span><br><span class="line">Upgrade:websocket</span><br></pre></td></tr></table></figure></p><p>Frames</p><p>首先发送http请求<br><a href="https://rtm.daovoice.io/socket.io/?EIO=3&amp;transport=polling&amp;t=M5ZWKps&amp;sid=JtjO6wXdOoHH7RXWFqhw" target="_blank" rel="noopener">https://rtm.daovoice.io/socket.io/?EIO=3&amp;transport=polling&amp;t=M5ZWKps&amp;sid=JtjO6wXdOoHH7RXWFqhw</a></p><p><a href="https://im.daovoice.io/v1/conversations/02010594-d7b8-4f3a-896a-4f82e2cc9198/fetch" target="_blank" rel="noopener">https://im.daovoice.io/v1/conversations/02010594-d7b8-4f3a-896a-4f82e2cc9198/fetch</a><br><a href="https://im.daovoice.io/v1/conversations/02010594-d7b8-4f3a-896a-4f82e2cc9198/read" target="_blank" rel="noopener">https://im.daovoice.io/v1/conversations/02010594-d7b8-4f3a-896a-4f82e2cc9198/read</a><br><a href="https://im.daovoice.io/v1/conversations/02010594-d7b8-4f3a-896a-4f82e2cc9198/reply" target="_blank" rel="noopener">https://im.daovoice.io/v1/conversations/02010594-d7b8-4f3a-896a-4f82e2cc9198/reply</a></p><h2 id="如何自己实现在线联系"><a href="#如何自己实现在线联系" class="headerlink" title="如何自己实现在线联系"></a>如何自己实现在线联系</h2><h3 id="利用websocket"><a href="#利用websocket" class="headerlink" title="利用websocket"></a>利用websocket</h3><h3 id="利用微信api"><a href="#利用微信api" class="headerlink" title="利用微信api"></a>利用微信api</h3><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.ezlippi.com/blog/2018/01/next-chat.html" target="_blank" rel="noopener">利用dao voice</a></p>]]></content>
      
      <categories>
          
          <category> CS </category>
          
          <category> web </category>
          
          <category> blog-framework </category>
          
          <category> nodejs-hexo </category>
          
          <category> plugin </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
            <tag> plugin </tag>
            
            <tag> instant-message </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Hexo简介</title>
      <link href="/pub/80e7b4b1/"/>
      <url>/pub/80e7b4b1/</url>
      <content type="html"><![CDATA[<h2 id="Hexo剖析"><a href="#Hexo剖析" class="headerlink" title="Hexo剖析"></a>Hexo剖析</h2><p>中文文档：<a href="https://hexo.io/zh-cn/docs/" target="_blank" rel="noopener">https://hexo.io/zh-cn/docs/</a><br>官方主题库：<a href="https://hexo.io/themes/" target="_blank" rel="noopener">https://hexo.io/themes/</a><br>next主题：<a href="https://github.com/theme-next" target="_blank" rel="noopener">https://github.com/theme-next</a></p><h2 id="Hexo原理综述"><a href="#Hexo原理综述" class="headerlink" title="Hexo原理综述"></a>Hexo原理综述</h2><p>markdown到html的旅程</p><ul><li>模板渲染</li><li>模板渲染</li></ul><h2 id="hexo文件结构"><a href="#hexo文件结构" class="headerlink" title="hexo文件结构"></a>hexo文件结构</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">├── _config.yml     <span class="comment"># 站点配置文件</span></span><br><span class="line">├── db.json     <span class="comment"># database，缓存文件</span></span><br><span class="line">├── node_modules  <span class="comment"># 安装的插件以及hexo所需的一些node.js模块</span></span><br><span class="line">├── package.json  <span class="comment"># 应用程序信息，配置hexo运行需要的js包</span></span><br><span class="line">├── public     <span class="comment"># deploy时生成，最终所见网页的所有内容</span></span><br><span class="line">├── scaffolds  <span class="comment"># 模板文件夹，hexo默认包含以下三种布局(layout)    https://hexo.io/zh-cn/docs/writing.html</span></span><br><span class="line">│     ├──draft.md   <span class="comment"># hexo new draft &lt;title&gt; 会在source/_drafts目录下生成md文件</span></span><br><span class="line">│     ├──page.md  <span class="comment"># hexo new page &lt;title&gt; 在source目录下</span></span><br><span class="line">│     └──post.md   <span class="comment"># hexo new post &lt;title&gt;  在source/_posts目录下生成md文件</span></span><br><span class="line">├── source    <span class="comment"># 资源文件夹。除 posts 文件夹之外，开头命名为 (下划线)的文件 / 文件夹和隐藏的文件将会被忽略。Markdown 和 HTML 文件会被解析并放到 public 文件夹，而其他文件会被拷贝过去。</span></span><br><span class="line">│     ├── _draft  <span class="comment"># 除 _posts 文件夹之外，开头命名为 _ (下划线)的文件 / 文件夹和隐藏的文件将会被忽略</span></span><br><span class="line">│     └── _posts  <span class="comment">#</span></span><br><span class="line">│             └──  hello-world.md</span><br><span class="line">└── themes   <span class="comment">#主题文件夹</span></span><br><span class="line">      ├──</span><br><span class="line">      └──next</span><br><span class="line">          ├──</span><br><span class="line">          ├──</span><br><span class="line">          ├──</span><br><span class="line">          ├──</span><br></pre></td></tr></table></figure><h2 id="详解clean"><a href="#详解clean" class="headerlink" title="详解clean"></a>详解clean</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ hexo clean --debug</span><br><span class="line"></span><br><span class="line">INFO  Deleted database.       <span class="comment"># 清空 db.json</span></span><br><span class="line">INFO  Deleted public folder.  <span class="comment"># 删除public目录</span></span><br></pre></td></tr></table></figure><h2 id="详解hexo-g"><a href="#详解hexo-g" class="headerlink" title="详解hexo g"></a>详解hexo g</h2><p>每次运行 hexo g 命令，hexo(node.js程序)会遍历你的 source 目录，建立索引，根据你 theme 文件夹的主题生成页面到 public 文件夹。这时 public 文件夹就是一个纯由 html javascript css 等内容制作的博客，而这些恰好能在 git pages 识别</p><h2 id="详解deploy"><a href="#详解deploy" class="headerlink" title="详解deploy"></a>详解deploy</h2><p>最后 hexo d 将 public 文件夹的内容复制到临时目录，以 git 方式 push 到 github 的指定项目的指定分支，由 github 进行显示</p><p>首次deploy<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">$ hexo d --debug</span><br><span class="line"></span><br><span class="line"><span class="comment"># 1. 首先加载plugin和theme</span></span><br><span class="line">DEBUG Config loaded: ~/xs/blog/_config.yml</span><br><span class="line">DEBUG Plugin loaded: hexo-generator-category</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. 开始转化html</span></span><br><span class="line">INFO  Start processing</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2.1 处理404页面</span></span><br><span class="line">DEBUG Processed: <span class="built_in">source</span>/404.html  <span class="comment"># 404不需要theme</span></span><br><span class="line">DEBUG Processed: 404.html</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2.2 加载主题，处理source目录下的.md .html</span></span><br><span class="line">DEBUG Theme config loaded.</span><br><span class="line">DEBUG Processed: _config.yml  <span class="comment"># 这个也需要处理？</span></span><br><span class="line">DEBUG Processed: <span class="built_in">source</span>/css/main.styl  <span class="comment"># 处理source目录下所有文件，包括js image md</span></span><br><span class="line">DEBUG Processed: layout/archive.swig   <span class="comment"># 处理layout languages等</span></span><br><span class="line"></span><br><span class="line">DEBUG Generator: page  <span class="comment"># 还包括post category archive index tag</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 3. 生成html，存储在public目录</span></span><br><span class="line">INFO  Files loaded <span class="keyword">in</span> 796 ms  <span class="comment">#</span></span><br><span class="line">DEBUG Rendering page: 404.html</span><br><span class="line">DEBUG Rendering post: 2018/01/25/hello-world/index.html</span><br><span class="line">DEBUG Rendering archive: archives/index.html</span><br><span class="line">DEBUG Rendering index: index.html</span><br><span class="line"></span><br><span class="line"><span class="comment"># 4. deploy: 创建git repo，在public中拷贝文件，并push</span></span><br><span class="line">INFO  Deploying: git</span><br><span class="line">Initialized empty Git repository   <span class="comment"># git init</span></span><br><span class="line">INFO  Copying files from public folder...  <span class="comment"># 从public复制到.deploy_git目录</span></span><br><span class="line">INFO  Copying files from extend <span class="built_in">dirs</span>...</span><br><span class="line">INFO  Deploy <span class="keyword">done</span>: git  <span class="comment"># commit &amp; push 已完成</span></span><br><span class="line">DEBUG Database saved</span><br></pre></td></tr></table></figure></p><h2 id="详解hexo-server"><a href="#详解hexo-server" class="headerlink" title="详解hexo server"></a>详解hexo server</h2><p>hexo s —debug</p><h2 id="hexo的模板引擎-Rendering-HTML"><a href="#hexo的模板引擎-Rendering-HTML" class="headerlink" title="hexo的模板引擎,Rendering HTML"></a>hexo的模板引擎,Rendering HTML</h2><p>模板引擎的作用，就是将界面与数据分离。最简单的原理是将模板内容中指定的地方替换成数据，实现业务代码与逻辑代码分离。</p><p>source 文件夹理解为数据库，而theme文件夹相当于 界面。 hexo g 就将我们的数据和界面相结合生成静态文件 public。</p><p>Hexo 的模板引擎是默认使用 ejs 编写的，同类型的东西还有很多，比如jade，swig。</p><p>next选用的swig</p><h2 id="比较赞的设计"><a href="#比较赞的设计" class="headerlink" title="比较赞的设计"></a>比较赞的设计</h2><ul><li>文件名与博客名分离，即title不直接采用文件名。(这样保证了不会因为title的变动引起url的变动)</li><li>url路径与实际路径分离 ()</li></ul><h2 id="reference"><a href="#reference" class="headerlink" title="reference"></a>reference</h2><p><a href="http://coderunthings.com/2017/08/20/howhexoworks/" target="_blank" rel="noopener">http://coderunthings.com/2017/08/20/howhexoworks/</a></p>]]></content>
      
      <categories>
          
          <category> CS </category>
          
          <category> web </category>
          
          <category> blog-framework </category>
          
          <category> nodejs-hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>【Hexo源码系列】 之 入门</title>
      <link href="/pub/70d0eddc/"/>
      <url>/pub/70d0eddc/</url>
      <content type="html"><![CDATA[<h1 id="首先"><a href="#首先" class="headerlink" title="首先"></a>首先</h1><p>为什么要看源码呢？因为想自己更便捷高效的管理博客，比如</p><ul><li>如何更新Hexo。(需要看<code>hexo init</code>的源码，因为该命令隐藏了<code>hexo-starter</code>项目)</li><li>如何更新theme。某些bug-fix&amp;新功能。(需要借助git的submodule来高效管理)</li><li>如何自己实现一个新功能(比如添加edit button，添加URL哈希。需要了解模板原理)</li></ul><p>源码不用细看，看个大概能满足自己的需求就够了。</p><p>本文仅介绍<a href="https://github.com/hexojs/hexo-starter" target="_blank" rel="noopener">Hexo基础包</a>，<a href="https://hexo.io/plugins/" target="_blank" rel="noopener">扩展包</a>可参考【Hexo插件系列】博客。</p><h1 id="查看Hexo和Plugin版本"><a href="#查看Hexo和Plugin版本" class="headerlink" title="查看Hexo和Plugin版本"></a>查看Hexo和Plugin版本</h1><p>首先看一下自己的Hexo和Plugin版本，因为不同的版本是不同的实现。版本号是次要的，主要看是不是同一种包。比如<code>hexo-deployer-git</code>和<code>hexo-deployer-rsync</code>在执行<code>hexo d</code>命令时方式就不同。详见<a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">官方文档</a></p><p>查看<code>package.json</code>文件的依赖项。<br><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">"dependencies":</span> <span class="string">&#123;</span></span><br><span class="line"><span class="attr">  "hexo":</span> <span class="string">"^3.7.0"</span><span class="string">,</span> <span class="comment"># https://github.com/hexojs/hexo/  hexo仅仅是一个module而已，用于...</span></span><br><span class="line"><span class="attr">  "hexo-generator-archive":</span> <span class="string">"^0.1.5"</span><span class="string">,</span>  <span class="comment"># generator最复杂</span></span><br><span class="line"><span class="attr">  "hexo-generator-category":</span> <span class="string">"^0.1.3"</span><span class="string">,</span></span><br><span class="line"><span class="attr">  "hexo-generator-index":</span> <span class="string">"^0.2.1"</span><span class="string">,</span></span><br><span class="line"><span class="attr">  "hexo-generator-tag":</span> <span class="string">"^0.2.0"</span><span class="string">,</span> <span class="comment"># nodejs的模板引擎，有EJS、Jade、Swig、Haml。theme-next采用的swig</span></span><br><span class="line"><span class="attr">  "hexo-renderer-ejs":</span> <span class="string">"^0.3.1"</span><span class="string">,</span></span><br><span class="line"><span class="attr">  "hexo-renderer-stylus":</span> <span class="string">"^0.3.3"</span><span class="string">,</span></span><br><span class="line"><span class="attr">  "hexo-renderer-marked":</span> <span class="string">"^0.3.2"</span><span class="string">,</span>  <span class="comment"># markdown的render engine，即`.md`转`html`</span></span><br><span class="line"><span class="attr">  "hexo-server":</span> <span class="string">"^0.3.1"</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure></p><p>也可用以下命令查看版本：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm ls --depth 0</span><br></pre></td></tr></table></figure></p><blockquote><p>更新各个模块，命令 npm update</p></blockquote><ul><li>hexo-cli，<ul><li>提供hexo init、hexo help、hexo version命令</li></ul></li><li>hexo<ul><li>hexo new</li><li>hexo generate</li></ul></li><li>hexo plugin，即node依赖<ul><li>hexo server</li><li>hexo deploy</li><li>其他命令</li></ul></li></ul><h1 id="回顾Hexo搭建流程"><a href="#回顾Hexo搭建流程" class="headerlink" title="回顾Hexo搭建流程"></a>回顾Hexo搭建流程</h1><p>以下来自<a href="https://github.com/hexojs/hexo/blob/master/README.md" target="_blank" rel="noopener">官方文档</a></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1. Installation</span></span><br><span class="line">$ npm install hexo-cli -g</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. Setup your blog</span></span><br><span class="line">$ hexo init blog</span><br><span class="line">$ <span class="built_in">cd</span> blog</span><br><span class="line"></span><br><span class="line"><span class="comment"># 3. Start the server</span></span><br><span class="line">$ hexo server</span><br><span class="line"></span><br><span class="line"><span class="comment"># 4. Create a new post</span></span><br><span class="line">$ hexo new <span class="string">"Hello Hexo"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 5. Generate static files</span></span><br><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><h1 id="流程详解"><a href="#流程详解" class="headerlink" title="流程详解"></a>流程详解</h1><h2 id="1-npm-install"><a href="#1-npm-install" class="headerlink" title="1. npm install"></a>1. npm install</h2><p>npm是nodejs的包管理器，管理javascript lib<br>hexo-cli是nodejs的一个包，用于运行hexo命令。(有cli难道还有server？)</p><p>npm list -g 能够看到安装路径。一般在/usr/lib/node_modules/ 或者/usr/local/lib/node_modules/</p><h2 id="2-hexo-init"><a href="#2-hexo-init" class="headerlink" title="2. hexo init"></a>2. hexo init</h2><p><code>hexo init</code>命令做了什么？</p><h3 id="答案"><a href="#答案" class="headerlink" title="答案"></a>答案</h3><p><code>hexo init</code>等价于以下两行shell命令。<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1. Cloning hexo-starter to blog</span></span><br><span class="line">$ git <span class="built_in">clone</span> --recursive https://github.com/hexojs/hexo-starter.git blog</span><br><span class="line"><span class="comment"># 2. Install dependencies</span></span><br><span class="line">$ npm install --production</span><br></pre></td></tr></table></figure></p><p>看到这里，就够用。如果自己的hexo项目是老版本的，可以在这个仓库pull更新(虽然更新很少)。<br>如果对追寻答案的过程感兴趣，可以继续往下看。</p><h3 id="追寻答案的旅程-optional"><a href="#追寻答案的旅程-optional" class="headerlink" title="追寻答案的旅程 - optional"></a>追寻答案的旅程 - optional</h3><p><strong>首先看一下hexo</strong></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">which</span> hexo</span><br><span class="line">/usr/bin/hexo</span><br><span class="line"></span><br><span class="line">$ cat /usr/bin/hexo</span><br><span class="line"><span class="comment">#!/usr/bin/env node</span></span><br><span class="line"><span class="string">'use strict'</span>;</span><br><span class="line">require(<span class="string">'../lib/hexo'</span>)();</span><br></pre></td></tr></table></figure><p>这里你会发现，hexo命令是nodejs脚本。 <code>../lib/hexo</code>对应的是<code>usr/lib/hexo</code>，然而没有path。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ ls -l /usr/bin/hexo</span><br><span class="line"> /usr/bin/hexo -&gt; ../lib/node_modules/hexo-cli/bin/hexo</span><br></pre></td></tr></table></figure><p>原来<code>/usr/bin/hexo</code>是个符号链接，链接到nodejs的modules目录里。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ cat /usr/lib/node_modules/hexo-cli/bin/hexo</span><br><span class="line"><span class="comment">#!/usr/bin/env node</span></span><br><span class="line"><span class="string">'use strict'</span>;</span><br><span class="line">require(<span class="string">'../lib/hexo'</span>)();</span><br></pre></td></tr></table></figure><p>即<code>hexo</code>命令对应的是<a href="https://github.com/hexojs/hexo-cli/blob/master/lib/hexo.js" target="_blank" rel="noopener"><code>/usr/lib/node_modules/hexo-cli/lib/hexo.js</code></a>文件。</p><p>hexo找到了，init命令呢？讲道理应该是个package.json下的script。</p><p>原生<code>hexo-cli</code>提供了4个命令，都在<code>hexo-cli/lib/console</code>路径下。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ hexo help</span><br><span class="line">$ hexo init</span><br><span class="line">$ hexo version</span><br></pre></td></tr></table></figure><p>扩展命令通过<code>hexo-cli/lib/extends.console.js</code>实现。</p><p><strong>hexo init 命令</strong></p><p><strong><code>init.js</code>核心代码</strong></p><p>路径<code>hexo-cli/lib/console/init.js</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> GIT_REPO_URL = <span class="string">'https://github.com/hexojs/hexo-starter.git'</span>;</span><br><span class="line"><span class="comment">// 1. git clone --recursive https://github.com/hexojs/hexo-starter.git blog</span></span><br><span class="line">log.info(<span class="string">'Cloning hexo-starter to'</span></span><br><span class="line">spawn(<span class="string">'git'</span>, [<span class="string">'clone'</span>, <span class="string">'--recursive'</span>, GIT_REPO_URL, target]);</span><br><span class="line">removeGitDir(target);</span><br><span class="line">removeGitModules(target);</span><br><span class="line"><span class="comment">// 2. npm install --production</span></span><br><span class="line">log.info(<span class="string">'Install dependencies'</span>);</span><br><span class="line">spawn(npmCommand, [<span class="string">'install'</span>, <span class="string">'--production'</span>]);</span><br></pre></td></tr></table></figure><p>实际上吧，如果hexo的log打印出来<code>GIT_REPO_URL</code>就更清晰，非要藏起来等人挖掘。</p><p><strong>参考</strong></p><ul><li><a href="https://github.com/hexojs/hexo-starter" target="_blank" rel="noopener">hexo-starter项目</a></li><li><a href="https://github.com/hexojs/hexo-cli/blob/master/lib/hexo.js" target="_blank" rel="noopener">hexo.js源码 | hexo-cli 项目</a></li><li><a href="https://github.com/hexojs/hexo-cli/blob/master/lib/console/init.js" target="_blank" rel="noopener">hexo init 命令源码 | hexo-cli 项目</a></li></ul><h2 id="3-hexo-server"><a href="#3-hexo-server" class="headerlink" title="3. hexo server"></a>3. hexo server</h2><p>这个不属于hexo-cli了。<br><a href="https://github.com/hexojs/hexo-server/blob/master/lib/server.js" target="_blank" rel="noopener">hexo server命令源码</a></p><p>暂没兴趣，应该就是启了个nodejs HttpServer。待看</p><ul><li>额外的逻辑是，如果没generate，先调一下 hexo g</li></ul><p>但是偶尔出现的bug来源于<code>hexo s</code>，这里的逻辑还需要看一下。</p><h2 id="4-hexo-new"><a href="#4-hexo-new" class="headerlink" title="4. hexo new"></a>4. hexo new</h2><h2 id="5-hexo-generate"><a href="#5-hexo-generate" class="headerlink" title="5. hexo generate"></a>5. hexo generate</h2><p>生成器（Generator）<a href="https://hexo.io/zh-cn/api/generator.html" target="_blank" rel="noopener">官方文档</a></p><p>这个好麻烦，看不动了。这么多<code>generator</code>和<code>render</code>。</p><p>放个链接 <a href="https://github.com/hexojs/hexo-generator-index" target="_blank" rel="noopener">https://github.com/hexojs/hexo-generator-index</a> ，貌似主要先看这个。</p><h3 id="generator"><a href="#generator" class="headerlink" title="generator"></a>generator</h3><p>generates static files</p><p>这一步最慢。<br>常用的有hexo-renderer-marked<br>hexo-renderer-pandoc</p><h3 id="render-模板引擎"><a href="#render-模板引擎" class="headerlink" title="render 模板引擎"></a>render 模板引擎</h3><p><a href="https://hexo.io/zh-cn/api/renderer.html" target="_blank" rel="noopener">官方文档</a></p><p><a href="https://hexo.io/zh-cn/api/rendering.html" target="_blank" rel="noopener">https://hexo.io/zh-cn/api/rendering.html</a></p><p>模板引擎的作用，就是将界面与数据分离。最简单的原理是将模板内容中指定的地方替换成数据，实现业务代码与逻辑代码分离。</p><p>生成静态文件。将我们的数据和界面相结合生成静态文件的过程。会遍历主题文件中的 source 文件夹（js、css、img 等静态资源），然后建立索引，然后根据索引生成 pubild 文件夹中，此时的 publid 文件是由 html、 js、css、img 建立的纯静态文件可以通过 index.html 作为入口访问你的博客。</p><p>其中 _layout.swig 是通用模板，里面引入了 head、footer 等公共组件，然后在其他的模板中会引入这个 _layout.swig 通用模板，比如 post.swig 模板</p><ul><li>.md解析成html</li><li>.swig渲染为html</li></ul><h3 id="数据的填充"><a href="#数据的填充" class="headerlink" title="数据的填充"></a>数据的填充</h3><p>数据的填充主要是 hexo -g 的时候将数据传递给 swig 模板，然后再由 swig 模板填充到 HTML 中。</p><h2 id="6-hexo-deploy"><a href="#6-hexo-deploy" class="headerlink" title="6. hexo deploy"></a>6. hexo deploy</h2><p>deploy到底干了什么？执行了git push？</p><p>deploy配置<br><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Deployment</span></span><br><span class="line"><span class="comment">## Docs: https://hexo.io/docs/deployment.html</span></span><br><span class="line"><span class="attr">deploy:</span></span><br><span class="line"><span class="attr">- type:</span> <span class="string">git</span></span><br><span class="line"><span class="attr">  repo:</span> <span class="string">git@github.com:xu-song/xu-song.github.io.git</span></span><br><span class="line"><span class="attr">  branch:</span> <span class="string">master</span></span><br></pre></td></tr></table></figure></p><p>部署主要是根据在 _config.yml 中配置的 git 仓库或者 coding 的地址，将 public 文件上传至 github 或者 coding 中。然后再根据上面的 github 提供的 pages 服务呈现出页面。当然你也可以直接将你生成的 public 文件上传至你自己的服务器上。</p><p><strong>deploy.js核心源码</strong>：<a href="https://github.com/hexojs/hexo-deployer-git/blob/master/lib/deployer.js#L83" target="_blank" rel="noopener">https://github.com/hexojs/hexo-deployer-git/blob/master/lib/deployer.js#L83</a><br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git(<span class="string">'add'</span>, <span class="string">'-A'</span>);  <span class="comment">// 对publc目录中执行add操作。</span></span><br><span class="line">git(<span class="string">'commit'</span>, <span class="string">'-m'</span>, message);</span><br><span class="line">git(<span class="string">'push'</span>, <span class="string">'-u'</span>, repo.url, <span class="string">'HEAD:'</span> + repo.branch, <span class="string">'--force'</span>);</span><br></pre></td></tr></table></figure></p><p>即等价于以下几个命令(通常情况下)<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ rm -rf .deploy_git  <span class="comment"># log.info('Clearing .deploy_git folder...');</span></span><br><span class="line">$ cp -rf public .deploy_git <span class="comment"># log.info('Copying files from public folder...');</span></span><br><span class="line">$ <span class="built_in">cd</span> .deploy_git</span><br><span class="line"></span><br><span class="line">$ git add -A</span><br><span class="line">$ git commit -m <span class="string">"Site updated: 2018-01-30 *:*:*"</span> <span class="comment">#某时间</span></span><br><span class="line">$ git push -u origin HEAD:master --force</span><br></pre></td></tr></table></figure></p><p>上面命令使用—force选项，强制push到远程主机，会使远程主机更新的版本被覆盖。所以不要在deploy之后的仓库做提交，要在dev仓库提交。</p><p>实例：</p><ul><li>[x] <a href="https://github.com/xsung/blog-dev/#submodule" target="_blank" rel="noopener">Dev Repository</a> Main project for all submodules</li><li>[x] <a href="https://github.com/xu-song/xu-song.github.io/" target="_blank" rel="noopener">Deployed Repository</a> is deployed by Hexo from <code>Dev Repository</code></li><li>[x] <a href="http://xusong.vip" target="_blank" rel="noopener">Demo Site</a> hosts the <code>Deployed Repository</code></li></ul><p><strong>参考</strong></p><ul><li><a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">hexo deploy官方文档</a></li><li><a href="https://github.com/hexojs/hexo-deployer-git/blob/master/lib/deployer.js" target="_blank" rel="noopener">hexo deploy.js源码</a></li><li><a href="http://cherryblog.site/hexo-4.html" target="_blank" rel="noopener">http://cherryblog.site/hexo-4.html</a></li><li><a href="http://cherryblog.site/hexo-4.html" target="_blank" rel="noopener">深入理解 Hexo</a></li><li><a href="http://coderunthings.com/2017/08/20/howhexoworks/" target="_blank" rel="noopener">hexo是怎么工作的</a><h2 id="7-Hexo-的模板引擎"><a href="#7-Hexo-的模板引擎" class="headerlink" title="7. Hexo 的模板引擎"></a>7. Hexo 的模板引擎</h2>这个<code>render</code>讲道理应该是在<code>hexo g</code>的时候调用的。 待看</li></ul>]]></content>
      
      <categories>
          
          <category> CS </category>
          
          <category> web </category>
          
          <category> blog-framework </category>
          
          <category> nodejs-hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
            <tag> 源码 </tag>
            
            <tag> 原理 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>关于域名</title>
      <link href="/pub/8dcc3c99/"/>
      <url>/pub/8dcc3c99/</url>
      <content type="html"><![CDATA[<h2 id="顶级域名比较"><a href="#顶级域名比较" class="headerlink" title="顶级域名比较"></a>顶级域名比较</h2><p><a href="https://zh.wikipedia.org/wiki/%E4%BA%92%E8%81%94%E7%BD%91%E9%A1%B6%E7%BA%A7%E5%9F%9F%E5%88%97%E8%A1%A8" target="_blank" rel="noopener">互联网顶级域列表</a></p><div class="table-container"><table><thead><tr><th></th><th>简介</th><th>google页面数(million)</th><th>域名数目</th><th>域名饱和度</th><th>开放时间</th><th>价格</th><th>审核</th><th>星级</th><th>备注</th></tr></thead><tbody><tr><td>.com</td><td>原用于商业组织，现无限制</td><td>25,270</td><td>13290万</td><td>4字母的基本饱和</td><td>1985-01-01</td><td></td><td></td><td>☆☆☆☆☆</td><td></td></tr><tr><td>.net</td><td>原用于网络服务，现无限制</td><td>2,790</td><td>1437万</td><td>大批量4字母</td><td>1985-01-01</td><td></td><td></td><td>☆☆☆☆</td><td></td></tr><tr><td>.org</td><td>原用于非营利组织，现无限制</td><td>5,040</td><td>1040万</td><td>大批量4字母</td><td>1985-01-01</td><td></td><td></td><td>☆☆☆☆</td><td>国内不能实名认证，不能备案</td></tr><tr><td>.info</td><td>适用于提供信息服务的企业</td><td>738</td><td>656万</td><td></td><td>2001-06-26</td><td></td><td></td><td></td><td></td></tr><tr><td>.cn</td><td>中国</td><td>425</td><td>1134万</td><td></td><td>1990-11-28</td><td></td><td>需提供政府颁发的有效身份证件。</td><td>☆☆☆☆</td><td></td></tr><tr><td>.us</td><td>美国</td><td>420</td><td>205万</td><td></td><td>1985-02-15</td><td></td><td></td><td></td><td>美国的网站很喜欢使用.com的域名。因此.us网站相对较少</td></tr><tr><td>.io</td><td>新秀，“Indian Ocean”为英属印度洋领地的缩写</td><td>193</td><td>33万</td><td></td><td>1997-09-16</td><td>贵</td><td></td><td>☆☆☆☆</td><td>该顶级域十分受初创公司和IT公司欢迎</td></tr><tr><td>.biz</td><td></td><td>104</td><td>200万</td><td></td><td>2001-06-26</td><td></td><td></td><td></td><td>取意来自英文单词 “business” ，代表着商业领域，在 .com 资源日渐枯竭的情况下， .biz 必将代替 .com 成为企业注册域名的首选。</td></tr><tr><td>.cc</td><td></td><td>91</td><td>96万</td><td></td><td>1997-10-13</td><td></td><td></td><td></td><td></td></tr><tr><td>.ai</td><td>英国海外属地安圭拉国家及地区顶级域</td><td>25</td><td>3万</td><td></td><td>1995-02-16</td><td>贵</td><td></td><td>☆☆☆☆</td><td>由于近来人工智能的大热，.ai域名热度极度攀升</td></tr><tr><td>.xyz</td><td></td><td>24</td><td>184万</td><td></td><td>2014-02-06</td><td>贵</td><td></td><td></td><td></td></tr><tr><td>.top</td><td></td><td>1</td><td>168万</td><td></td><td>2014-07-24</td><td>便宜</td><td></td><td></td><td></td></tr><tr><td>.vip</td><td></td><td>0.6</td><td>74万</td><td></td><td>2015-07-30</td><td>便宜</td><td></td><td></td><td></td></tr><tr><td>特殊用途域名</td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>.gov</td><td>政府部门</td><td>1,170</td><td>0.5万</td><td></td><td>1985-01-01</td><td></td><td>需提供相关证件资料</td><td>☆☆☆☆☆☆</td><td>域名少，页面丰富</td></tr><tr><td>.edu</td><td>教育机构</td><td>601</td><td>0.7万</td><td></td><td>1985-01-01</td><td></td><td>需提供相关证件资料</td><td>☆☆☆☆☆☆</td></tr></tbody></table></div><h2 id="中文域名"><a href="#中文域名" class="headerlink" title="中文域名"></a>中文域名</h2><p>比如 <code>域名.com</code>，有点贵</p><h2 id="溢价域名"><a href="#溢价域名" class="headerlink" title="溢价域名"></a>溢价域名</h2><p>溢价域名，是注册局根据ICANN相关规定，在开放注册后可以保留一定时间后再开放的。<br>通常情况下，溢价域名是注册局保留的精品优质域名。</p><h2 id="域名实名认证"><a href="#域名实名认证" class="headerlink" title="域名实名认证"></a>域名实名认证</h2><p>.org .cc .me的域名不能实名认证，不在阿里云实名认证列表里。会有一下提示：</p><blockquote><p>根据工信部和域名注册局新的实名认证要求，该后缀域名暂时停止实名认证，具体开放时间等待进一步通知</p></blockquote><p>阿里云实名认证文档:</p><blockquote><p>为贯彻国家工信部对域名持有者实名制审核管理的相关规范，阿里云将全面推行域名实名认证。域名实名认证包括域名命名审核（指域名将由国家监管部门认定是否含有政策不允许注册的字符）和域名持有人信息资料实名认证。</p><p><a href="https://help.aliyun.com/knowledge_detail/35881.html" target="_blank" rel="noopener">须完成实名认证或命名审核的域名</a></p><p>按照工信部 2017 年全面域名实名认证的要求，目前阿里云已接到相关注册局通知：若域名在规定时间内未通过实名审核，会被注册局暂停解析（Serverhold），无法正常访问，待实名认证通过后方可恢复正常使用。涉及的域名后缀包括：.cn/.中国/.公司/.网络/.xin/.com/.net/.top/.xyz/.vip/.club/.shop/.wang/.ren/.site/.我爱你/.集团/.biz/.red/.kim/.pro/.info/.mobi/.ltd/.group/.link/.ink/.在线/.中文网/.网址/.work/.online/ .tech/.fun/.store/.网店/.live/.social/.pub/.video。</p></blockquote><p>没有实名认证的域名可以备案吗？ 不能，因为备案需要域名证书</p><p>没有办法 转国外了</p><p>我想问 你们域名都在国外，NS有没在国内？比如cloudxns？<br>有啊，我就是namesilo域名，cloudxns解析，没啥问题</p><h2 id="备案"><a href="#备案" class="headerlink" title="备案"></a>备案</h2><ul><li>2018年1月1日起，工信部要求备案域名必须完成域名实名认证，未完成实名认证、实名信息与备案信息不一致等会被管局驳回。</li><li>备案订单有效期为45天(自提交当天开始计算)，订单超期后自动失效，请您尽快提交并完成备案。为避免影响网站备案及访问，请注意服务器的服务期限及时续费。</li><li><a href="https://help.aliyun.com/knowledge_detail/64289.html" target="_blank" rel="noopener">网站备案域名核验</a></li></ul><h3 id="提示域名不支持备案怎么办？"><a href="#提示域名不支持备案怎么办？" class="headerlink" title="提示域名不支持备案怎么办？"></a>提示域名不支持备案怎么办？</h3><p>市面上流通的域名后缀并非都可以备案。只有工信部收录的域名后缀才允许开放备案，目前工信部暂未收录 .pub/.rocks/.band/.market/software/.social/.lawyer/.engineer/.link/.click/.help/.gift/.pics/.photo/.news/.video/.win/.party/.date/.trade/.science/.online/.tech/.website/.space/.press/.wiki/.design/.live/.studio/.red/.loan/.bid/.mom/.lol/.work/.game/.store/.ltd 等后缀的域名，故无法进行网站备案。</p><p>您可以访问 工信部备案管理系统 （www.miitbeian.gov.cn），进入 公共查询 &gt; 域名类型 查看域名后缀是否已收录。如果您购买的域名后缀无法进行备案，您可将域名指向中国大陆以外免备案服务器。中国大陆以外节点服务器无需进行备案。</p><p>此外，部分省市管局对可备案域名有特殊要求，请查看各省管局 备案规则。</p><h2 id="认可度，信任程度，稳定性，正式度，流行度排名。"><a href="#认可度，信任程度，稳定性，正式度，流行度排名。" class="headerlink" title="认可度，信任程度，稳定性，正式度，流行度排名。"></a>认可度，信任程度，稳定性，正式度，流行度排名。</h2><h3 id="国内域名"><a href="#国内域名" class="headerlink" title="国内域名"></a>国内域名</h3><ol><li><code>.cn</code>  要使用您的域名，您必须提供政府颁发的有效身份证件。</li><li><code>.com.cn</code> 要使用您的域名，您必须提供政府颁发的有效身份证件。</li><li><code>.org.cn</code></li></ol><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><ol><li>.song 神奇的亚马逊还有这个域名</li><li>特殊功能域名  .shoes .map .data .game .x 等</li><li>last.fm del.icio.us flic.kr<br>.blog<br>…</li></ol><p>适宜个人：.me .name .blog .site（换个说法就是不适宜商用，）</p><p>锤子花高价买t.tt<br>所以不流行的域名里，配合好的二级域名也是有投资价值的</p><h3 id="预测"><a href="#预测" class="headerlink" title="预测"></a>预测</h3><ul><li>无商业投资价值的域名不会火，<br>规律，商人、组织、企业们看中哪个域名，哪个域名就火。像个人主义的域名，再名字再好，在商业投资价值下，也变得逊色。比如.me</li></ul><h2 id="收费-amp-续费"><a href="#收费-amp-续费" class="headerlink" title="收费 &amp; 续费"></a>收费 &amp; 续费</h2><p>[万网-阿里云价格]<a href="https://wanwang.aliyun.com/help/price.html" target="_blank" rel="noopener">https://wanwang.aliyun.com/help/price.html</a></p><p>续费小技巧：先将域名转到国内，续费个好几年，等 2 个月后转出到国外。<br>比如 <a href="http://shuaige.me" target="_blank" rel="noopener">shuaige.me</a> 已续费到 2023 年， 13 年 37 一年续到了 22 年，今天转到了 gandi 花了 99</p><h2 id="排名"><a href="#排名" class="headerlink" title="排名"></a>排名</h2><h3 id="注册量总排名"><a href="#注册量总排名" class="headerlink" title="注册量总排名"></a>注册量总排名</h3><p><strong>全球十大域名后缀，.cn仅次于.com</strong></p><p><a href="http://www.ccw.cc/ymzcl/" target="_blank" rel="noopener">实时查询</a></p><p><img src="http://img2.ctoutiao.com/uploads/2017/07/20/1500537225490956.jpg"><br>                                              |</p><h3 id="国别域名-注册量排名"><a href="#国别域名-注册量排名" class="headerlink" title="国别域名 注册量排名"></a>国别域名 注册量排名</h3><p><strong>.cn域名总量达2140万，国别域名中位居全球第一</strong><br><img src="http://img2.ctoutiao.com/uploads/2017/07/20/1500537225451161.jpg"><br>截至2017年3月31日，国别域名的注册总量为1.431亿个，环比增长03.%，同比增长1.7%。其中排名前十的分别是.cn（中国）、.tk（托克劳）、.de（德国）、.uk（英国）、.ru（俄罗斯）、.nl（荷兰）、.br（巴西）、.eu（欧盟）、.au（澳大利亚）和.it（意大利）。</p><p>目前(2018-02-27)，<code>.tk</code> 第一，<code>.de</code>第二，<code>.cn</code>第三</p><p><img src="https://cdn0.tnwcdn.com/wp-content/blogs.dir/1/files/2016/03/NominetMap.jpg"></p><h4 id="神奇的-tk"><a href="#神奇的-tk" class="headerlink" title="神奇的 .tk"></a>神奇的 .tk</h4><p>.tk 托克劳是一个太平洋上的蕞尔小岛国，却无疑是互联网世界中的真正霸主。它力压所有国家成为了域名最多的国家。</p><p>托克劳使用了一种目前在互联网上极为流行的“免费增值”商业模式，以.tk注册的网站只享有免费的使用权。若想完全拥有这个域名仍需要支付一笔费用。这些费用占了托克劳年收入的六分之一。</p><p>域名免费提供给任何人。</p><h3 id="新域名排名"><a href="#新域名排名" class="headerlink" title="新域名排名"></a>新域名排名</h3><p><strong>新顶级域名总量达2540万，.xyz、.top、.loan位居前三</strong></p><p><img src="https://user-images.githubusercontent.com/13825126/35474303-564fe59c-03c7-11e8-9bb0-653d1fa9800f.jpg" alt="1500537226527745"></p><p>.xyz注册量这么大，不可思议。也许因为便宜，8元一个。另外还免费送，在中国备案也助长注册量吧。目前已经在走下坡路了</p><p><img src="https://user-images.githubusercontent.com/13825126/35456536-d0b104fe-0310-11e8-92ff-2602cdf13b0d.PNG" alt="default"></p><blockquote><p>知乎<br>一切不能在中国备案的域名后缀球都不值  (什么意思？)</p></blockquote><h2 id="域名对SEO的影响"><a href="#域名对SEO的影响" class="headerlink" title="域名对SEO的影响"></a>域名对SEO的影响</h2><p>域名对网页搜索没有影响。</p><ul><li><a href="">百度说</a></li><li><a href="https://www.searchenginejournal.com/google-all-domain-extensions-are-weighted-the-same/137139/" target="_blank" rel="noopener">google说</a></li></ul><h2 id="reference"><a href="#reference" class="headerlink" title="reference"></a>reference</h2><ul><li>wikipedia</li><li><a href="https://www.quora.com/What-is-a-better-alternative-for-a-startup-when-the-com-is-taken-co-io-net-or-org" target="_blank" rel="noopener">https://www.quora.com/What-is-a-better-alternative-for-a-startup-when-the-com-is-taken-co-io-net-or-org</a></li><li><a href="http://www.ctoutiao.com/239698.html" target="_blank" rel="noopener">http://www.ctoutiao.com/239698.html</a></li></ul><h2 id="域名注册机构变化"><a href="#域名注册机构变化" class="headerlink" title="域名注册机构变化"></a>域名注册机构变化</h2><h3 id="注册商"><a href="#注册商" class="headerlink" title="注册商"></a>注册商</h3><h3 id="whois"><a href="#whois" class="headerlink" title="whois"></a><a href="https://zh.wikipedia.org/wiki/WHOIS" target="_blank" rel="noopener">whois</a></h3><p>是用来查询互联网中域名的IP以及所有者等信息的传输协议。早期的WHOIS查询多以命令行接口（Command Line）存在，但是现在出现了一些基于网页接口的简化在线查询工具，甚至可以一次向不同的数据库查询。网页接口的查询工具仍然依赖WHOIS协议向服务器发送查询请求，命令行接口的工具仍然被系统管理员广泛使用。<br>WHOIS通常使用TCP协议43端口。每个域名或IP的WHOIS信息由对应的管理机构保存，例如，以.com结尾的域名的WHOIS信息由.com域名运营商VeriSign管理，中国国家顶级域名.cn域名由CNNIC管理。</p><p>通常情况下，域名或IP的信息可以由公众自由查询获得，具体的查询方法是登陆由管理机构提供的WHOIS服务器，输入待查询的域名进行查询。</p><h3 id="whois-ai的变化"><a href="#whois-ai的变化" class="headerlink" title="whois.ai的变化"></a>whois.ai的变化</h3><p>ai-domain也在这次升级中变为注册商，代号ai-domain。可惜的是，新用户已经无法在whois.ai创建账户，这意味着，新用户只能通过注册商进行注册了。而且注册局的用户的域名只出不进，即只提供转出功能，不提供转入功能。whois.ai已经变成一个遗留系统，趋势上会慢慢退出历史的舞台。前后模式的变化如下图：</p><p><img src="https://pic2.zhimg.com/80/v2-75760893eb5c084d8629a762d521a943_hd.jpg" alt="ss"></p><p>参考：<a href="https://www.zhihu.com/question/57642499/answer/154856435" target="_blank" rel="noopener">https://www.zhihu.com/question/57642499/answer/154856435</a></p><h2 id="域名转让-交易"><a href="#域名转让-交易" class="headerlink" title="域名转让/交易"></a>域名转让/交易</h2><ul><li>带价push，是直接Push到对方账户里，他要付款接收。（自己找买家，随意商议价格）</li><li>一口价域名发布,一口价需要他找域名批量或逐个购买（阿里平台给你找买家，当然要手续费）  烂域名就一口价甩出去</li><li>线上议价域名发布 （）</li><li><p>竞价域名发布</p></li><li><p>一口价挂出来，有被其他人秒走的可能(好域名可以线上议价)</p></li></ul><p><a href="https://help.aliyun.com/knowledge_detail/45051.html?spm=5176.11065259.1996646101.searchclickresult.4282327eoKPrtS" target="_blank" rel="noopener">交易手续费</a> 手续费为 1%<br>平台支持的一口价、线上议价会收取手续费，带价 push 免费。</p><p>交易费由谁承担？<br>由卖家承担，对于域名买家不受影响。</p><p>根据ICANN域名转移政策调整要求，为了确保交易的顺利进行，请所有卖家选择关闭“60天内禁止转出阿里云”限制，否则不能发布域名交易，且在2017年1月10日24点前未完成确认的已发布交易域名将全部下架处理，点击确认</p><h2 id="域名发展史"><a href="#域名发展史" class="headerlink" title="域名发展史"></a>域名发展史</h2><p><img class="portrait ui_qtext_image zoomable_in zoomable_in_feed lazy_loaded lazy_loading" src="https://qph.ec.quoracdn.net/main-qimg-1927c70c81fbd8278f89a5caca02dcf7.webp" master_src="https://qph.ec.quoracdn.net/main-qimg-31835c9f203076569e83cef18f9d495b-c" master_w="1100" master_h="8865" style="opacity: 1;"></p>]]></content>
      
      <categories>
          
          <category> CS </category>
          
          <category> web </category>
          
          <category> site-dev </category>
          
      </categories>
      
      
        <tags>
            
            <tag> domain </tag>
            
            <tag> web </tag>
            
            <tag> 建站 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>关于SEO</title>
      <link href="/pub/435df108/"/>
      <url>/pub/435df108/</url>
      <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><h2 id="如何检查自己网站是否被baidu-google检索"><a href="#如何检查自己网站是否被baidu-google检索" class="headerlink" title="如何检查自己网站是否被baidu google检索"></a>如何检查自己网站是否被baidu google检索</h2><p>site:xu-song.top git<br>site:xu-song.github.io git</p><h2 id="提交百度检索"><a href="#提交百度检索" class="headerlink" title="提交百度检索"></a>提交百度检索</h2><p><a href="https://ziyuan.baidu.com/linksubmit/url" target="_blank" rel="noopener">https://ziyuan.baidu.com/linksubmit/url</a></p><blockquote><p>百度搜索资源平台为站长提供链接提交通道，您可以提交想被百度收录的链接，百度搜索引擎会按照标准处理，但不保证一定能够收录您提交的链接。</p></blockquote><p><a href="https://blog.paddings.cn/2016/05/14/blog/hexo-sitemap/" target="_blank" rel="noopener">Hexo 博客添加百度sitemap</a></p><p><a href="https://www.zhihu.com/question/37633687" target="_blank" rel="noopener">hexo部署在github，用百度的站长收录sitemap，抓取失败怎么办？</a><br>Github屏蔽了百度爬虫。<br>除了sitemap还有其他提交方法，还可以采用主动推送和自动推送，</p><h2 id="为什么我的博客始终无法被百度收录"><a href="#为什么我的博客始终无法被百度收录" class="headerlink" title="为什么我的博客始终无法被百度收录"></a>为什么我的博客始终无法被百度收录</h2><p>我在GoDaddy购买了域名，完成了在谷歌搜录，百度完成自动推送的设置后在sitemap一栏中填入我的域名始终显示sitemap抓取失败，请问这是什么问题我该如何解决呢   — 知乎</p><p>github 禁止了百度的爬虫，你可以在 国内的 coding.net 上放一份，然后修改域名服务商的 CNAME 让国内的指向 coding.net ，国外的依然指向 github。具体你自己查下吧</p><blockquote><p>就算放开了，肯定也没有国内的vps收录快。还有就是并不是所有的ip地址的权重都一样。爬虫有自己喜欢和不喜欢的ip群</p></blockquote><p>如果完全没有外链，也不向百度提交，相当于孤岛，是不可能被收录的。<br>除非有人替你提交，或者本身百度数据库有你域名的记录。</p><p>没外链不代表孤岛，没外链你DNS修改时候百度等也有可能会知道，参考dnspod和百度合作的某文章……</p><h2 id="有多个域名，怎么做最符合-SEO"><a href="#有多个域名，怎么做最符合-SEO" class="headerlink" title="有多个域名，怎么做最符合 SEO?"></a>有多个域名，怎么做最符合 SEO?</h2><p>把其他域名都转发到主域名。很多人把不同的域名都解析到同一个网站，这样导致的结果是其他的域名没有对主域名起到任何作用，反而可能导致负面影响，如：让搜索引擎分不清到底哪一个是主域名。</p><p>搜索引擎对同一ip下的域名有互相推广的作用，给的比重越来越小了，多个域名同时解析到一个主机上，对SEO是有影响的，比如说：排名不好、PR值低、收录量少等问题。</p><p>对于多域名绑定建议从下面入手：</p><pre><code>1.使用301重定向功能。关于301重定向的操作需要注意的是：不要将次要网站中的所有网页的流量都重定向到主站上，这样做虽然节省了很多工作量，但是如果用户从搜索引擎上找过来，访问到的网页并不是他想要的内容，就会损失流量。尽可能做到页对页的重定向，保证用户从搜索引擎找过来的网页即使不是绝对匹配也是相关的内容。2.给次要的网站首页做一个导航,把流量指引到主站上；3.给次要的域名做URL转发；</code></pre><p>一定要这样做：实现301重定向把次域名重定向到主域名去，避免权重分散，甚至被K，或者影响SEO排名。</p><ul><li>301 redirect:：301代表永久性转移。301重定向是网页更改地址后对搜索引擎最友好的方法，只要不是暂时搬移的情况，都建议使用301来做转址。</li><li>302 redirect:：302代表暂时性转移。在前些年，不少Black Hat SEO曾广泛应用这项技术作弊。各大主要搜索引擎均加强了打击力度。(怎么作弊？)</li></ul><p>当网页A用301重定向转到网页B时，搜索引擎可以肯定网页A永久的改变位置，或者说实际上不存在了，搜索引擎就会把网页B当作唯一有效目标。好处是，第一，没有网址规范化问题，第二，也很重要的，网页A的PR网页级别会传到网页B。</p><h1 id="SEO与跳转-重定向"><a href="#SEO与跳转-重定向" class="headerlink" title="SEO与跳转(重定向)"></a>SEO与跳转(重定向)</h1><p>301 vs 302 vs meta-refresh tag</p><p><img src="http://www.redalkemi.com/public/tinymce/images/uploads/2008/04/bot-blog4.jpg"></p><p><a href="http://www.redalkemi.com/blog/post/the-seo-war-of-redirects-301-vs-302-vs-meta-refresh-tag" target="_blank" rel="noopener">参考</a></p><p>URL 重定向服务实际并非DNS 服务，它们在 HTTP 级别运行，而非 DNS 级别。使用URL转发的客户基本都是免费DNS的用户，当前业务暂不会投入支持。</p><h2 id="301重定向"><a href="#301重定向" class="headerlink" title="301重定向"></a>301重定向</h2><p>301 重定向，是指当用户通过浏览器访问某个 URL 时，Web 服务器被设置自动跳转到另外一个 URL，此时给客户端的返回码是 301。</p><h3 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h3><p>301 重定向一般用于两个 URL 之间的跳转。由于 301 重定向可以实现 URL 跳转后的权重转移，实现 SEO 优化，所以常用于如下场景：</p><ul><li>网站有多个域名，但有一个主域名作为 SEO 推广对象，所有其他域名可以做 301 重定向到主域名，实现权重转移。</li><li>网站更换过域名，希望用新的域名作为 SEO 推广对象，当网站的用户访问旧域名时就会被 301 重定向到新的域名，实现权重转移。<ul><li>迁移后，访问统计归零。</li><li>301重定向之后是不会承继老网站的关键词排名，只不过老网站的排名依然在而已，用户点击你的老域名会直接指向新域名</li></ul></li><li>网站部分内容做过调整，URL 已经无法访问，可以做 301 重定向实现权重转移。</li></ul><p>参考：</p><p><a href="http://www.360doc.com/content/14/0212/15/13780192_351920352.shtml" target="_blank" rel="noopener">http://www.360doc.com/content/14/0212/15/13780192_351920352.shtml</a></p><p><a href="http://www.hurencai.com/archives/453" target="_blank" rel="noopener">http://www.hurencai.com/archives/453</a></p><h3 id="服务器ip迁移"><a href="#服务器ip迁移" class="headerlink" title="服务器ip迁移"></a>服务器ip迁移</h3><p>比如从gitpage迁移到coding page。</p><p><a href="https://www.zhihu.com/question/19987112" target="_blank" rel="noopener">https://www.zhihu.com/question/19987112</a></p><h2 id=""><a href="#" class="headerlink" title="#"></a>#</h2><h2 id="URL设计-与-SEO"><a href="#URL设计-与-SEO" class="headerlink" title="URL设计 与 SEO"></a>URL设计 与 SEO</h2><ul><li>静态URL</li><li>尽量英文，中文用拼音。(现在搜索引擎也对中文优化了，貌似中文url也不错，例如wikipedia的中文页面就采用的中文url)</li><li>字母全部小写</li><li>URL中包含关键词</li><li>url要短</li><li>单词之间一般建议使用短横线（-）分隔，不要使用下划线或者其他符号</li></ul><h2 id="robots-txt"><a href="#robots-txt" class="headerlink" title="robots.txt"></a>robots.txt</h2><p>robots.txt位置固定，sitemap.xml需要在robots.txt中指定路径</p><p>必要性</p><h1 id="提交链接的几种方式"><a href="#提交链接的几种方式" class="headerlink" title="提交链接的几种方式"></a>提交链接的几种方式</h1><p>Sitemap提交：在配置sitemap文件时，无论是txt格式的文本文档还是还是xml格式的文件。都不建议将其sitemap的文件名命名为sitemap.txt或sitemap.xml这么大众化且谁都能够知道的文件名。如果你这样设置，你的竞争对手或需要你网站内容的人很容易就能拿到你所有的页面url。出于保险起见还是使用一些自己定义的较复杂的文件名。每一个url都必须包含<a href="http://，文件中包含的url不得超过5万条，单文件大小不得超过10MB，一个站点最多提交5万个sitemap文件，超出5万个不再处理并会提示“链接数超”。如果是通过子域名的形式验证的站点。那么主域名下的sitemap文件是可以包含该域名下的所有域名的url的。" target="_blank" rel="noopener">http://，文件中包含的url不得超过5万条，单文件大小不得超过10MB，一个站点最多提交5万个sitemap文件，超出5万个不再处理并会提示“链接数超”。如果是通过子域名的形式验证的站点。那么主域名下的sitemap文件是可以包含该域名下的所有域名的url的。</a></p><p>主动推送：</p><p>对比sitemap而言在及时抓取上推送更快、发现更快、抓取更及时。如果是时效性文章不排除其收录速度达到一瞬间的效率，这里特别建议一下，最好是主动推送我们网站第一时间产生的新内容给百度其效果更佳；主动推送是有推送数量的限制，尽可能的不要推送重复的内容给百度。这样会大大浪费自己的可推送资源。</p><p>自动推送：<code>在页面被访问时，页面URL将立即被推送给百度</code>。</p><h2 id="sitemap"><a href="#sitemap" class="headerlink" title="sitemap"></a>sitemap</h2><p>爬虫会通过网页内部的链接发现新的网页。但是如果没有连接指向的网页怎么办?或者用户输入条件生成的动态网页怎么办?能否让网站管理员通知搜索引擎他们网站上有哪些可供抓取的网页?这就是sitemap，最简单的 Sitepmap 形式就是XML文件，在其中列出网站中的网址以及关于每个网址的其他数据(上次更新的时间、更改的频率以及相对于网站上其他网址的重要程度等等)，利用这些信息搜索引擎可以更加智能地抓取网站内容。</p><p>新的问题来了，爬虫怎么知道这个网站有没有提供sitemap文件，或者说网站管理员生成了sitemap，(可能是多个文件)，爬虫怎么知道放在哪里呢?</p><p>由于robots.txt的位置是固定的，于是大家就想到了把sitemap的位置信息放在robots.txt里。这就成为robots.txt里的新成员了。</p><p>站点地图对于百度失效。可以用主动推送和自动推送，</p><p>对于主域名下有多个2级域名的问题，应该是每一个二级域名都有自己独立的robots文件和sitemap。</p><p>必要性：不做也能收录。<br>最好做，为蜘蛛提供一个引导，有利于收录</p><p>知乎没有sitemap.xml，或许自定义了文件名</p><p><a href="https://blog.eson.org/2018/03/04/web/site-dev/seo-in-hexo/">https://blog.eson.org/2018/03/04/web/site-dev/seo-in-hexo/</a></p><h2 id="主动推送"><a href="#主动推送" class="headerlink" title="主动推送"></a>主动推送</h2><p>调用接口<br><a href="http://data.zz.baidu.com/urls?site=https://blog.eson.org&amp;token=hOraXsrU6jl6Pifg" target="_blank" rel="noopener">http://data.zz.baidu.com/urls?site=https://blog.eson.org&amp;token=hOraXsrU6jl6Pifg</a>“</p><h3 id="应用实例"><a href="#应用实例" class="headerlink" title="应用实例"></a>应用实例</h3><p>hexo的baidu主动推送<a href="https://github.com/huiwang/hexo-baidu-url-submit" target="_blank" rel="noopener">hexo-baidu-url-submit</a></p><p>新链接的产生，hexo generate会产生一个文本文件，里面包含最新的链接<br>新链接的提交，hexo deploy会从上述文件中读取链接，提交至百度搜索引擎。</p><h2 id="自动推送"><a href="#自动推送" class="headerlink" title="自动推送"></a>自动推送</h2><p>页面每次被访问时，页面URL将立即被推送给百度。借助用户的浏览行为来触发推送动作，无需站长汇总URL再进行主动推送操作，省去了站长人工操作的时间。</p><h3 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h3><p>需要将这段js代码部署到我们的每一个网页中<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> bp = <span class="built_in">document</span>.createElement(<span class="string">'script'</span>);</span><br><span class="line">    <span class="keyword">var</span> curProtocol = <span class="built_in">window</span>.location.protocol.split(<span class="string">':'</span>)[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">if</span> (curProtocol === <span class="string">'https'</span>) &#123;</span><br><span class="line">        bp.src = <span class="string">'https://zz.bdstatic.com/linksubmit/push.js'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        bp.src = <span class="string">'http://push.zhanzhang.baidu.com/push.js'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> s = <span class="built_in">document</span>.getElementsByTagName(<span class="string">"script"</span>)[<span class="number">0</span>];</span><br><span class="line">    s.parentNode.insertBefore(bp, s);  <span class="comment">//</span></span><br><span class="line">&#125;)();</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure></p><p>每当用户进行访问时，就会触发了这段代码，这段代码自动将当前页面的url推送给了百度。具体推送代码如下：</p><p><a href="https://zz.bdstatic.com/linksubmit/push.js" target="_blank" rel="noopener">push.js</a><br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">!<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> e = <span class="regexp">/([http|https]:\/\/[a-zA-Z0-9\_\.]+\.baidu\.com)/gi</span></span><br><span class="line">      , r = <span class="built_in">window</span>.location.href</span><br><span class="line">      , t = <span class="built_in">document</span>.referrer;</span><br><span class="line">    <span class="keyword">if</span> (!e.test(r)) &#123;</span><br><span class="line">        <span class="keyword">var</span> o = <span class="string">"https://sp0.baidu.com/9_Q4simg2RQJ8t7jm9iCKT-xh_/s.gif"</span>;</span><br><span class="line">        t ? (o += <span class="string">"?r="</span> + <span class="built_in">encodeURIComponent</span>(<span class="built_in">document</span>.referrer),</span><br><span class="line">        r &amp;&amp; (o += <span class="string">"&amp;l="</span> + r)) : r &amp;&amp; (o += <span class="string">"?l="</span> + r);</span><br><span class="line">        <span class="keyword">var</span> i = <span class="keyword">new</span> Image;</span><br><span class="line">        i.src = o</span><br><span class="line">    &#125;</span><br><span class="line">&#125;(<span class="built_in">window</span>);</span><br></pre></td></tr></table></figure></p><p>比如每次访问页面<code>https://blog.eson.org</code>时，都会触发一个http请求<code>https://sp0.baidu.com/9_Q4simg2RQJ8t7jm9iCKT-xh_/s.gif?l=https://blog.eson.org/</code>。这就是自动推送。</p><h3 id="应用实例："><a href="#应用实例：" class="headerlink" title="应用实例："></a>应用实例：</h3><p>hexo-theme-next中的baidu自动推送，<a href="https://github.com/theme-next/hexo-theme-next/blob/master/layout/_third-party/seo/baidu-push.swig" target="_blank" rel="noopener"> baidu-push.swig</a></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>建议同时配置这三种方式，并让三者协同工作，将抓取和收录价值最大化。</p><h1 id="怎样判断网站有网址规范化问题？"><a href="#怎样判断网站有网址规范化问题？" class="headerlink" title="怎样判断网站有网址规范化问题？"></a>怎样判断网站有网址规范化问题？</h1><p>1) 查一下这些URL是否都有差不多的PR值和网页快照：</p><p><a href="http://domainname.com" target="_blank" rel="noopener">http://domainname.com</a><br><a href="http://www.domainname.com/index.html" target="_blank" rel="noopener">http://www.domainname.com/index.html</a><br><a href="http://domainname.com/index.html" target="_blank" rel="noopener">http://domainname.com/index.html</a><br><a href="http://www.domainname.com" target="_blank" rel="noopener">http://www.domainname.com</a></p><p>2)搜一下site:domain.com看是否结果中有多个主页版本。</p><p>3)你的网站是否在Google有大量网页被标为“ 补充材料”(Supplemental Result)。一般认为被归为“ 补充材料”是网址规范化问题的征兆。</p><p>reference： <a href="https://www.seozac.com/seo/301-redirect/" target="_blank" rel="noopener">https://www.seozac.com/seo/301-redirect/</a></p><p>site:.top</p><h1 id="tips"><a href="#tips" class="headerlink" title="tips"></a>tips</h1><ol><li><p>edu和gov后缀的域名天生权重更高。有些域名天生反链高，比如xxx   sex   之类的等等！</p><ul><li>百度说：使用何种形式的域名后缀对百度网页搜索没有影响</li></ul></li><li><p>注册时间越早的域名，越有利于排名。</p></li><li><p>到期时间越晚的域名，越有利于排名。</p></li><li><p>不同的子域名是会被当作独立网站处理的，不能继承主域名的权重。</p></li><li><p>不同国家的域名，在本国会越有利于排名，比如<a href="http://abc.cn在中国会排名更好，而http://abc.us在美国会排名更好。" target="_blank" rel="noopener">http://abc.cn在中国会排名更好，而http://abc.us在美国会排名更好。</a></p></li></ol><p>一个网站有多个域名没问题，请做好301跳转，别每个域名都可以访问。</p><p>gov和edu对排名有利，但对大多数人没什么指导意义，因为你根本弄不到这种后缀的域名。</p><p>域名买卖历史，（不涉及到违规行业越好）</p><p>惩罚 &amp; 奖励</p><ul><li>关键词堆砌</li><li>频繁的修改网页title、description和keywords</li><li>网站加上黑链</li><li>短时间内频繁的增加外链，或者短时间内大量的删除外链</li><li>服务器不稳定，网站经常打不开活域名解析错误。</li><li>全站 HTTPS，谷歌对 HTTPS 有加分</li><li>响应式设计，谷歌对提供友好移动端友好页面有加分</li><li>AMP，谷歌对提供 AMP 支持的网站有加分</li><li>PWA，谷歌对 PWA 有加分</li><li>加载优化，谷歌对 Pageseed 测试 90 分以上的网站有加分</li></ul><ul><li>页面内容持续不断更新，迎合了搜索引擎喜新厌旧的特性。</li><li>关键词密度要提升，但不是堆积</li><li><p>高质量内容出现在代码更靠前的位置，方便搜索引擎识别抓取。</p></li><li><p>内容很少的页面搜索引擎肯定不喜欢</p></li></ul><h2 id="tricks"><a href="#tricks" class="headerlink" title="tricks"></a>tricks</h2><p>有很多大学生在他们大学的个人网站上出卖链接。搜索引擎怎样去辨别哪些来自.edu的链接是自然的？哪些又是买卖的呢？</p><h2 id="seo诊断"><a href="#seo诊断" class="headerlink" title="seo诊断"></a>seo诊断</h2><p>bing站长有SEO Analyzer。</p><h3 id="title长度"><a href="#title长度" class="headerlink" title="title长度"></a>title长度</h3><p>诊断我的主页，title太短，因为只有四个字母ESON。</p><blockquote><p>Recommended Action:<br>Change the length of the title to be between 5 and 100 characters</p><p>SEO Explanation:<br>If the title is too short, it may not provide us and users with enough information to understand the relevancy of your page.  If the title is too long, we may need to shorten it in the search results and your keywords may not appear on the search results page.  You should try to keep the length of the title somewhere between at least 5 characters and 100 characters.</p></blockquote><h3 id="description长度"><a href="#description长度" class="headerlink" title="description长度"></a>description长度</h3><blockquote><p>Recommended Action:<br>Change the description in the <meta description=""> tag in the page source to be between 25 and 160 characters in length.</p><p>SEO Explanation:<br>Search engine crawlers only show the first 150-160 characters of the description in the search results page, so if a description is too long, searchers may not see all of the text. If a description is too short, the search engines may add text found elsewhere on the page. Note that search engines may show a different description from the one you have authored if they feel it may be more relevant to a user’s search.</p></blockquote><h3 id="tag数量太多"><a href="#tag数量太多" class="headerlink" title=" tag数量太多"></a><h1> tag数量太多</h1></h3><p><a href="https://blog.eson.org/2018/01/25/web/site-dev/seo/seo-for-spider/">https://blog.eson.org/2018/01/25/web/site-dev/seo/seo-for-spider/</a></p><blockquote><p>There are multiple </p><h1> tags on the page.<br>Recommended Action:<br>Remove redundant <h1> tags from the page source, so that only one <h1> tag exists.<p></p></h1></h1></h1></blockquote><h3 id="tag-的-ALT属性"><a href="#tag-的-ALT属性" class="headerlink" title=" tag 的 ALT属性"></a><img> tag 的 ALT属性</h3><blockquote><p>Recommended Action:<br>Use the <img alt=""> attribute to write descriptive content for the image: &lt;img source=”pic.gif” alt=”Accurate and descriptive keyword text that represents the image.”.</p><p>SEO Explanation:<br>As a general rule, search engines do not interpret the content of image files. The text provided in the <img alt=""> attribute enables the site owner to provide relevant information to the search engine and to the end user. Alt text is helpful to end users if they have images disabled or if the image does not properly load. In addition, the Alt text is utilized by screen readers. Make sure that your Alt text is descriptive and accurately reflects what the image represents and supports the content on the page.</p></blockquote><h2 id="reference"><a href="#reference" class="headerlink" title="reference"></a>reference</h2><p><a href="https://www.webmasterworld.com/forum25/3716.htm" target="_blank" rel="noopener">https://www.webmasterworld.com/forum25/3716.htm</a><br><a href="http://www.ehcoo.com/seo.html" target="_blank" rel="noopener">http://www.ehcoo.com/seo.html</a><br><a href="https://ziyuan.baidu.com/college/articleinfo?id=36" target="_blank" rel="noopener">百度站长平台关于SEO的建议</a><br><a href="https://lemonxq.cn/2017/11/23/[%E8%87%AA%E5%88%B6%E5%B7%A5%E5%85%B7]%E5%AE%9E%E7%8E%B0%E8%87%AA%E5%8A%A8%E6%8E%A8%E9%80%81Hexo%E5%8D%9A%E5%AE%A2%E6%96%87%E7%AB%A0%E8%87%B3%E7%99%BE%E5%BA%A6/" target="_blank" rel="noopener">自动推送Hexo博客文章至百度</a> 待看<br><a href="https://www.zhihu.com/question/22726981" target="_blank" rel="noopener">知乎是怎么把 SEO 做起来的？</a></p><ul><li><a href="http://www.chinaz.com/web/2015/1118/471868.shtml" target="_blank" rel="noopener">https建议</a></li><li><a href="https://ziyuan.baidu.com/college/articleinfo?id=874" target="_blank" rel="noopener">新站如何被百度快速收录</a><h2 id="待续"><a href="#待续" class="headerlink" title="待续"></a>待续</h2></li></ul><h1 id="常见疑问"><a href="#常见疑问" class="headerlink" title="常见疑问"></a>常见疑问</h1><h2 id="http站点转为https后，对站点原本的评价权重得分是否有影响？"><a href="#http站点转为https后，对站点原本的评价权重得分是否有影响？" class="headerlink" title="http站点转为https后，对站点原本的评价权重得分是否有影响？"></a>http站点转为https后，对站点原本的评价权重得分是否有影响？</h2><p>无影响，后续会有正向收益，认为https更安全，在排序上会有倾斜。</p><h2 id="转https后，需要做301跳转，在这个过程中，http已有的排名是否会有变动？快照是否有变动？301需要永久存在吗？"><a href="#转https后，需要做301跳转，在这个过程中，http已有的排名是否会有变动？快照是否有变动？301需要永久存在吗？" class="headerlink" title="转https后，需要做301跳转，在这个过程中，http已有的排名是否会有变动？快照是否有变动？301需要永久存在吗？"></a>转https后，需要做301跳转，在这个过程中，http已有的排名是否会有变动？快照是否有变动？301需要永久存在吗？</h2><p>快照和排名不会有变化，建议301永久存在，不管是对搜索引挚还是对用户来说都更好一些。</p><h2 id="针对https的站点，百度在抓取技术层面上有哪些建议？"><a href="#针对https的站点，百度在抓取技术层面上有哪些建议？" class="headerlink" title="针对https的站点，百度在抓取技术层面上有哪些建议？"></a>针对https的站点，百度在抓取技术层面上有哪些建议？</h2><p>如果以前有http站点，建议永久保留跳转行为。之后注意通过百度站长平台的抓取诊断工具和抓取异常工具关注抓取结果。</p><h2 id="百度索引量增加收录量反而下降是什么原因？"><a href="#百度索引量增加收录量反而下降是什么原因？" class="headerlink" title="百度索引量增加收录量反而下降是什么原因？"></a>百度索引量增加收录量反而下降是什么原因？</h2><p>百度索引量是指被百度收集的数量，百度收录量是指被百度放出的数量</p><blockquote><ol><li>索引量指可以被搜索用户搜索到的网站数据库，索引量工具同时支持站点自定义想要关注的目录，查看某一目录规则下的索引量；索引量不等于流量，索引量会有定期数据波动，属于正常现象。</li><li>百度索引数据最快每天更新一次，最迟一周更新一次，不同站点的更新日期可能不同。</li><li>您可以查询到近一年中每天的索引量数据，一年前的索引量数据为每月索引量数据。</li><li>如果已有流量数据查询不到，请隔日再查，最长间隔一周可查询到数据。<br>来自百度 <a href="https://ziyuan.baidu.com" target="_blank" rel="noopener">https://ziyuan.baidu.com</a></li></ol></blockquote><ol><li>百度索引是指你的网页已被百度蜘蛛爬取到百度索引库里了，但这不表示你的网页被百度收录了，所以你是检索不到的。</li><li>百度收录是指，在百度索引库的网页经一定检查符合百度标准的，百度“转移到”（这个词是我自己说的，方便理解，实际百度未必这样处理）收录库里，予以放出，也就是被百度收录了这时你才能检索到自己的网页，但此时你的网页如果不符合标准仍然有从百度收录库被删的可能，比如文章是复制的重复率太高等等，百度检查也不是完美的。</li></ol><p>索引增加说明，百度蜘蛛还会定期到你的网站爬取网页，所以你的索引会增加。<br>收录减少很可能是因为你的网页在百度的价值不够，又被百度收录删了。</p><h2 id="为什么百度索引量和收录量一直不增加呢"><a href="#为什么百度索引量和收录量一直不增加呢" class="headerlink" title="为什么百度索引量和收录量一直不增加呢?"></a>为什么百度索引量和收录量一直不增加呢?</h2><p>新站开始收录比较慢比较正常，当然有些新站收录也会比较好。<br>这个也是有一些偶性的，看下抓取频次和日志里面的蜘蛛爬行情况，都是正常即可。</p><h2 id="提交链接后，都会被百度抓取并收录吗？"><a href="#提交链接后，都会被百度抓取并收录吗？" class="headerlink" title="提交链接后，都会被百度抓取并收录吗？"></a>提交链接后，都会被百度抓取并收录吗？</h2><p>百度对已提交的数据，不保证一定会抓取及收录所有网址。是否收录与页面质量相关。</p><h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><p>电商比较重视排名，SEO一定要好</p><h1 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h1><p>麻蛋，百度不行啊。seo设置麻烦，收录又慢。google都不用设置，收录又新又好。</p>]]></content>
      
      <categories>
          
          <category> CS </category>
          
          <category> web </category>
          
          <category> site-dev </category>
          
          <category> seo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> domain </tag>
            
            <tag> SEO </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>图像分类--模型汇总</title>
      <link href="/pub/ff0c91b0/"/>
      <url>/pub/ff0c91b0/</url>
      <content type="html"><![CDATA[<h2 id="image-classification"><a href="#image-classification" class="headerlink" title="image classification"></a>image classification</h2><h1 id="ImageNet分类模型"><a href="#ImageNet分类模型" class="headerlink" title="ImageNet分类模型"></a>ImageNet分类模型</h1><div class="table-container"><table><thead><tr><th style="text-align:left">model</th><th style="text-align:right">简介</th><th style="text-align:right"></th><th style="text-align:right">conv_padding</th><th style="text-align:right">conv_activation</th><th style="text-align:center">pooling</th><th>code</th><th>备注</th></tr></thead><tbody><tr><td style="text-align:left">LeNet5</td><td style="text-align:right">3个卷积层+2个pooling层</td><td style="text-align:right"></td><td style="text-align:right">valid</td><td style="text-align:right">sigmoid</td><td style="text-align:center"></td><td></td></tr><tr><td style="text-align:left">AlexNet</td><td style="text-align:right">8层</td><td style="text-align:right"></td><td style="text-align:right">same</td><td style="text-align:right">ReLU</td><td style="text-align:center">Overlapping Pooling</td></tr><tr><td style="text-align:left">VGG-19</td><td style="text-align:right">19层</td><td style="text-align:right"></td><td style="text-align:right">same</td><td style="text-align:right">ReLU</td><td style="text-align:center"></td><td><a href="https://github.com/fchollet/deep-learning-models/blob/master/vgg19.py" target="_blank" rel="noopener">keras</a></td></tr><tr><td style="text-align:left">GoogLeNet</td><td style="text-align:right">22层</td><td style="text-align:right"></td></tr><tr><td style="text-align:left">ResNet</td><td style="text-align:right"></td><td style="text-align:right">152层</td><td style="text-align:right"></td><td style="text-align:right"></td><td style="text-align:center"></td><td><a href="https://github.com/fchollet/deep-learning-models/blob/master/resnet50.py" target="_blank" rel="noopener">keras</a></td></tr></tbody></table></div><p>padding=same，是采用zero-padding的方式，使得input和output的维度一致。</p><p><script type="text/javascript" src="https://www.gstatic.com/charts/loader.js"></script> <script type="text/javascript">google.charts.load("current",{packages:['corechart']}); google.charts.setOnLoadCallback(drawChart); function drawChart(){var data=google.visualization.arrayToDataTable([ ["Year", "Accruacy"], ["2010\nLin", 28.2], ["2011\nSanchez", 25.8], ["2012\nAlexNet", 16.4], ["2013\nZeiler", 11.7], ["2014\nVGG", 7.3], ["2014\nGoogLeNet", 6.7], ["2015\nResNet", 3.6], ["2016\nShao", 3.0], ["2017\nSENet", 2.3], ["Human\nRussak..", 5.1],]); var view=new google.visualization.DataView(data); view.setColumns([0, 1,{calc: "stringify", sourceColumn: 1, type: "string", role: "annotation"}]); var options={title: "ImageNet", titlePosition: 'none', width: 800, height: 400, 'chartArea':{'width': '95%'}, vAxis:{maxValue: 32, ticks: [0, 10, 20, 30]}, hAxis:{textStyle:{fontSize:12.4}}, bar:{groupWidth: "50%"}, legend:{position: "none"}, annotations:{alwaysOutside: 'true', textStyle:{color: "black", bold:true}},}; var chart=new google.visualization.ColumnChart(document.getElementById("columnchart_values")); chart.draw(view, options);}</script> <div id="columnchart_values" style="width: 800px; height: 300px;"></div></p><p>上图来自cs231n,</p>]]></content>
      
      <categories>
          
          <category> ML </category>
          
          <category> applications </category>
          
          <category> vision </category>
          
          <category> image-classification </category>
          
      </categories>
      
      
        <tags>
            
            <tag> deep learning </tag>
            
            <tag> cv </tag>
            
            <tag> image classification </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Docker镜像分层技术</title>
      <link href="/pub/229a050/"/>
      <url>/pub/229a050/</url>
      <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>采用的sha256对每层编码。对image进行编码。</p><p>Docker对于镜像的维护类似于git对于repository的维护，都是只记录增量的。原有镜像是静态文件，基于这个静态文件可以创建的一个动态容器，在这个动态的容器中做任何你希望做的修改，然后退出容器后使用commit生成新的镜像，这个新的镜像就保留了你做的改动，从而生成新的一层。  未改变的文件还是使用原有镜像的文件，  被改动的文件作为新的layer被保存。基于同一个base image构建的两个不同的镜像，就类似于 基于同一个repository创建的两个不同的branch， 未修改的文件由两个镜像公用，每个镜像又独自保留他们特定的修改内容的增量。</p><p>从命令行上来说：</p><ul><li>一个commit指令对应一个新的layer</li><li>一条RUN语句对应一个新的layer</li></ul><h1 id="Ubuntu系统的镜像"><a href="#Ubuntu系统的镜像" class="headerlink" title="Ubuntu系统的镜像"></a>Ubuntu系统的镜像</h1><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>-</p>]]></content>
      
      <categories>
          
          <category> -docker </category>
          
          <category> tutorial </category>
          
          <category> images </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>计算机视觉--常用数据库</title>
      <link href="/pub/84080d8a/"/>
      <url>/pub/84080d8a/</url>
      <content type="html"><![CDATA[<h2 id="summary"><a href="#summary" class="headerlink" title="summary"></a>summary</h2><div class="table-container"><table><thead><tr><th>dataset</th><th style="text-align:right">im_size</th><th style="text-align:right">class*num</th><th style="text-align:right">download</th><th style="text-align:right">task</th><th style="text-align:center">example code</th><th>pretrained_model</th><th>state of art</th><th>实例图片</th><th>备注</th></tr></thead><tbody><tr><td>mnist</td><td style="text-align:right">28*28</td><td style="text-align:right">70000</td><td style="text-align:right"></td><td style="text-align:right"></td><td style="text-align:center"></td><td></td><td></td><td></td><td></td></tr><tr><td><a href="https://www.cs.toronto.edu/~kriz/cifar.html" target="_blank" rel="noopener">CIFAR-10</a></td><td style="text-align:right">32x32x3</td><td style="text-align:right">10*6000</td><td style="text-align:right"></td><td style="text-align:right"></td><td style="text-align:center"></td><td></td><td></td><td><img src="https://www.cs.toronto.edu/~kriz/cifar-10-sample/automobile5.png" alt="d" title="汽车"></td><td>Alex,Hinton发布，超小图片</td></tr><tr><td><a href="https://www.cs.toronto.edu/~kriz/cifar.html" target="_blank" rel="noopener">CIFAR-100</a></td><td style="text-align:right">32x32 170M</td><td style="text-align:right">100*600</td><td style="text-align:right"></td><td style="text-align:right"></td><td style="text-align:center"></td><td></td><td></td><td></td><td></td></tr><tr><td><a href="http://host.robots.ox.ac.uk/pascal/VOC/" target="_blank" rel="noopener">Pascal VOC</a> (05-12)</td><td style="text-align:right">2GB</td><td style="text-align:right"></td><td style="text-align:right"><a href="http://host.robots.ox.ac.uk/pascal/VOC/voc2012/VOCtrainval_11-May-2012.tar" target="_blank" rel="noopener">voc2012</a></td><td style="text-align:right"></td><td style="text-align:center"></td><td></td><td></td><td></td><td></td></tr><tr><td><a href="http://mscoco.org/" target="_blank" rel="noopener">coco</a></td><td style="text-align:right"></td><td style="text-align:right"></td><td style="text-align:right">40GB</td><td style="text-align:right"></td><td style="text-align:center"></td><td></td><td></td><td></td><td></td></tr><tr><td><a href="http://image-net.org/challenges/LSVRC/2012/index" target="_blank" rel="noopener">imagenet2012</a></td><td style="text-align:right">尺寸不固定，但多数比较清晰</td><td style="text-align:right"><a href="http://image-net.org/challenges/LSVRC/2012/browse-synsets" target="_blank" rel="noopener">1000类</a>，训练集1.2m，验证集50k,测试集100k</td><td style="text-align:right"></td><td style="text-align:right"></td><td style="text-align:center"></td><td></td><td></td><td>层级标签。 评价指标，top5的label包含正确label就算正确</td><td>AlexNet</td></tr><tr><td><a href="http://www.image-net.org/about-stats" target="_blank" rel="noopener">imagenet2016</a></td><td style="text-align:right"></td><td style="text-align:right">1400多万幅图片，涵盖2万多个类别 1TB</td><td style="text-align:right"></td><td style="text-align:right"></td><td style="text-align:center"></td><td></td><td></td><td></td><td></td></tr><tr><td>places</td><td style="text-align:right"></td><td style="text-align:right"></td><td style="text-align:right"></td><td style="text-align:right"></td><td style="text-align:center"></td><td></td><td></td><td></td><td></td></tr><tr><td></td><td style="text-align:right"></td><td style="text-align:right"></td><td style="text-align:right"></td><td style="text-align:right"></td><td style="text-align:center"></td><td></td><td></td><td></td><td></td></tr><tr><td>12306</td><td style="text-align:right">约80*80</td><td style="text-align:right"></td><td style="text-align:right"></td><td style="text-align:right"></td><td style="text-align:center"></td><td></td><td>12306图片比cifar数据库大多了</td><td></td></tr></tbody></table></div><p><a href="http://rodrigob.github.io/are_we_there_yet/build/classification_datasets_results.html" target="_blank" rel="noopener">分类结果汇总</a></p><p>task_code:</p><ol><li>图像分类（image classification）</li><li>目标检测（object detection）</li><li>目标识别（object recognition）</li><li>语义分割（semantic segmentation）</li><li>实例分割（instance segmentation）</li></ol><h2 id="来自pytorch-vision的data"><a href="#来自pytorch-vision的data" class="headerlink" title="来自pytorch vision的data"></a>来自pytorch vision的data</h2><ul><li>LSUN <a href="http://lsun.cs.princeton.edu" target="_blank" rel="noopener">http://lsun.cs.princeton.edu</a>`_ dataset</li><li>Local Image Descriptors Data <a href="http://phototour.cs.washington.edu/patches/default.htm" target="_blank" rel="noopener">http://phototour.cs.washington.edu/patches/default.htm</a>`_ Dataset.</li><li>SEMEION <a href="http://archive.ics.uci.edu/ml/datasets/semeion+handwritten+digit" target="_blank" rel="noopener">http://archive.ics.uci.edu/ml/datasets/semeion+handwritten+digit</a>`_ Dataset.</li><li>STL10 <a href="https://cs.stanford.edu/~acoates/stl10/" target="_blank" rel="noopener">https://cs.stanford.edu/~acoates/stl10/</a>`_ Dataset.</li><li>SVHN <a href="http://ufldl.stanford.edu/housenumbers/" target="_blank" rel="noopener">http://ufldl.stanford.edu/housenumbers/</a>`_ Dataset.</li></ul><h2 id="来自tensorflow的data"><a href="#来自tensorflow的data" class="headerlink" title="来自tensorflow的data"></a>来自tensorflow的data</h2><h1 id=""><a href="#" class="headerlink" title="#"></a>#</h1>]]></content>
      
      <categories>
          
          <category> ML </category>
          
          <category> applications </category>
          
          <category> vision </category>
          
          <category> dataset </category>
          
      </categories>
      
      
        <tags>
            
            <tag> dataset </tag>
            
            <tag> cv </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>java系列 - String</title>
      <link href="/pub/2a8bf999/"/>
      <url>/pub/2a8bf999/</url>
      <content type="html"><![CDATA[<h2 id="ss"><a href="#ss" class="headerlink" title="ss"></a>ss</h2><p>String s = “abc”,并没有在堆上生成对象<br>Object o = new Object() 对应字节码为:</p><pre><code>0: new           #2                  // class java/lang/Object3: dup           4: invokespecial #1                  // Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V7: astore_1   </code></pre><p>String s = “abc” 对应字节码为:</p><pre><code>0: ldc           #2                  // String abc2: astore_1  </code></pre><p>String s = new String() 对应字节码为:</p><pre><code>0: new           #2                  // class java/lang/String3: dup           4: invokespecial #3                  // Method java/lang/String.&quot;&lt;init&gt;&quot;:()V7: astore_1  </code></pre>]]></content>
      
      <categories>
          
          <category> CS </category>
          
          <category> programing </category>
          
          <category> lan </category>
          
          <category> java </category>
          
          <category> jdk </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> string </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>java系列 - class文件</title>
      <link href="/pub/718175b8/"/>
      <url>/pub/718175b8/</url>
      <content type="html"><![CDATA[<h2 id="introduction"><a href="#introduction" class="headerlink" title="introduction"></a>introduction</h2><p>目的：完整分析class文件。</p><h2 id="java源码"><a href="#java源码" class="headerlink" title="java源码"></a>java源码</h2><pre><code>package MyTest;public class SimpleClass {    void dfd() {        int i;        for (i = 0; i &lt; 100; i++) {        ; // Loop body is empty        }    }}</code></pre><h2 id="class文件-16进制"><a href="#class文件-16进制" class="headerlink" title="class文件 16进制"></a>class文件 16进制</h2><p>编译得到MyTest.class</p><pre><code>cafe babe  | 0000   0033      000c                   magic num  | minor0  major51  常量池计数器11+1=12  //////////// 常量池 /////////////#1  07     0002    class  #2#2    01     0012         4d79 5465 7374 2f53 696d 706c 6543 6c61 7373      utf8   length=18    MyTest/SimpleClass                            |  |#3    07     0004      class  #4           // java/lang/Object   #4    01     0010         6a61 7661 2f6c 616e 672f 4f62 6a65 6374 |    utf8   lengh16      java/lang/Object                        |#5    01     0006         3c 696e 6974 3e         utf8   length=6     &lt;init&gt;#6    01     0003         2829 56    utf8   length=3     ()V#7    01     0004         436f 6465    utf8   length=3     Code#8    0a     000300       09    md_ref #3.          #9  //  java/lang/Object.&quot;&lt;init&gt;&quot;:()V#9    0c     0005         0006    nam&amp;ty #5           #6   //  &quot;&lt;init&gt;&quot;:()V#10    01     0003         64 6664    utf8   length=3     dfd#11    01     000d         53 7461 636b 4d61 7054 6162 6c65    utf8   length=13    StackMapTable//////////// 常量池 /////////////0021               0001         0003可能是public       #1 类索引    #3 父类索引// 0x0021=0x0001|0x0020 也即ACC_PUBLIC 和 ACC_SUPER为真，其中ACC_PUBLIC大家好理解，ACC_SUPER是jdk1.2之后编译的类都会带有的标志。0000            接口计数器      接口表0000       fields_count0002methods_count//////////////// 第一个method void &lt;init&gt;  ///////////0001     0005       0006public   #5&lt;init&gt;   #6()V      其值为()V，表示&lt;init&gt;方法没有参数和返回值, 其实这是编译器自动生成 的实例构造器方法0001            attrib_count    0007        00000011     0001       0001        00000005     2ab70008b1  0000                    0000#7Code属性  attrib_len   max_stack  max_locals  code_length  code[]      exception_table_length  attribute_count// 代码是存储在Class文件中的method的code属性的code[]数组中//////////////// 第二个method dfd()  ///////////0000              000a     0006没写access_flag   #10,dfd  ()V0001attrib_count0007        00000028       0002       0002        0000000f          033ca700068401011b1064a1fffab1  #7Code属性  属性表的长度   max_stack  max_locals  code_length=15    code[]，解析见《jvm spec》41页0000exception_table_length0001attribute_count000b                  00000007   0002              fc00 0501 0200 00#11:StackMapTable     length     num_of_entries    7个length的stack_map_frame</code></pre><h2 id="疑问"><a href="#疑问" class="headerlink" title="疑问"></a>疑问</h2><p>.和：是怎么区分的？</p><h2 id="其他阅读"><a href="#其他阅读" class="headerlink" title="其他阅读"></a>其他阅读</h2><p><a href="http://coolshell.cn/articles/9229.html" target="_blank" rel="noopener">http://coolshell.cn/articles/9229.html</a></p>]]></content>
      
      <categories>
          
          <category> CS </category>
          
          <category> programing </category>
          
          <category> lan </category>
          
          <category> java </category>
          
          <category> jdk </category>
          
          <category> jvm </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>java系列 - Thread</title>
      <link href="/pub/851507b3/"/>
      <url>/pub/851507b3/</url>
      <content type="html"><![CDATA[<h2 id="疑问"><a href="#疑问" class="headerlink" title="疑问"></a>疑问</h2><h3 id="Java的线程是如何创建的，是直接调用OS的API，还是有自己的“抽象线程”？"><a href="#Java的线程是如何创建的，是直接调用OS的API，还是有自己的“抽象线程”？" class="headerlink" title="Java的线程是如何创建的，是直接调用OS的API，还是有自己的“抽象线程”？"></a>Java的线程是如何创建的，是直接调用OS的API，还是有自己的“抽象线程”？</h3><p>java线程是映射到操作系统的内核线程上的</p><h2 id="跟踪Thread-start"><a href="#跟踪Thread-start" class="headerlink" title="跟踪Thread.start()"></a>跟踪Thread.start()</h2><p>java</p><pre><code>// Thread.javapublic synchronized void start() {    group.add(this);    ...    start0();    ...}private native void start0();</code></pre><p>native方法hotspot源码</p><pre><code>// openjdk\jdk\src\share\native\java\lang\Thread.cstatic JNINativeMethod methods[] = {    {&quot;start0&quot;,           &quot;()V&quot;,        (void *)&amp;JVM_StartThread},   ...};// openjdk\hotspot\src\share\vm\prims\jvm.cppJVM_ENTRY(void, JVM_StartThread(JNIEnv* env, jobject jthread))  JVMWrapper(&quot;JVM_StartThread&quot;);  JavaThread *native_thread = NULL;  ...  native_thread = new JavaThread(&amp;thread_entry, sz); // 重点  ...  Thread::start(native_thread); // 重点JVM_END// openjdk\hotspot\src\share\vm\runtime\thread.cppJavaThread::JavaThread(ThreadFunction entry_point, size_t stack_sz) :  Thread() {   ...   os::create_thread(this, thr_type, stack_sz);   // 可以看出java线程是映射到操作系统的内核线程上的   ...}void Thread::start(Thread* thread) {    ...    os::start_thread(thread);  }}// 在hotspot\src\os目录下可以看到windows, linux, solaris和posix的实现，先检查linux\vm\os_linux.cppbool os::create_thread(Thread* thread, ThreadType thr_type, size_t stack_size) {  ...  int ret = pthread_create(&amp;tid, &amp;attr, (void* (*)(void*)) java_start, thread);  // linux中调用的pthread，POSIX中的api  ...}</code></pre>]]></content>
      
      <categories>
          
          <category> CS </category>
          
          <category> programing </category>
          
          <category> lan </category>
          
          <category> java </category>
          
          <category> jdk </category>
          
          <category> rt </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>java系列 - Atomic</title>
      <link href="/pub/89c32f49/"/>
      <url>/pub/89c32f49/</url>
      <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul><li>原子量和普通变量相比，主要体现在读写的线程安全上。对原子量的是原子的(比如多线程下的共享变量i++就不是原子的)，由CAS操作保证原子性。对原子量的读可以读到最新值，由volatile关键字来保证可见性。</li><li>原子量多用于数据统计(如接口调用次数)、一些序列生成(多线程环境下)以及一些同步数据结构中</li></ul><ul><li>atomic是基于底层硬件的CAS做的</li><li>区别于HashTable等线程安全类，这里面没有锁</li></ul><h2 id="以AtomicLong为例"><a href="#以AtomicLong为例" class="headerlink" title="以AtomicLong为例"></a>以AtomicLong为例</h2><h3 id="java源码"><a href="#java源码" class="headerlink" title="java源码"></a>java源码</h3><pre><code>// 1. from AtomicLong.java (rt.jar:java.util.concurrent.atomic.AtomicLong)public final boolean compareAndSet(long expect, long update) {    return unsafe.compareAndSwapLong(this, valueOffset, expect, update);}// 2. from Unsafe.java (rt.jar:sun.misc.Unsafe)public final native boolean compareAndSwapLong(Object o, long offset, long expected, long x);</code></pre><h3 id="native方法的C-实现"><a href="#native方法的C-实现" class="headerlink" title="native方法的C++实现"></a>native方法的C++实现</h3><pre><code>// 3. from hotspot/src/share/vm/prims/unsafe.cpp (openjdk)static JNINativeMethod methods[] = {{CC&quot;compareAndSwapLong&quot;, CC&quot;(&quot;OBJ&quot;J&quot;&quot;J&quot;&quot;J&quot;&quot;)Z&quot;,      FN_PTR(Unsafe_CompareAndSwapLong)},...}...UNSAFE_ENTRY(jboolean, Unsafe_CompareAndSwapLong(JNIEnv *env, jobject unsafe, jobject obj, jlong offset, jlong e, jlong x))  UnsafeWrapper(&quot;Unsafe_CompareAndSwapLong&quot;);  Handle p (THREAD, JNIHandles::resolve(obj));  jlong* addr = (jlong*)(index_oop_from_field_offset_long(p(), offset));  if (VM_Version::supports_cx8())      return (jlong)(Atomic::cmpxchg(x, addr, e)) == e;  // 主要实现  else { // 如果不支持cx8，那么就需要用到ObjectLocker锁    jboolean success = false;    ObjectLocker ol(p, THREAD);    if (*addr == e) { *addr = x; success = true; }    return success;  }UNSAFE_END</code></pre><p>It is a JNI wrapper for the CAS API, with memory barriers for IA64 architecture.</p><p>It is an atomic operation which means no other processor can change the value of dest whilst the operation executes.</p><p><strong>Atomic::cmpxchg(x, addr, e)</strong><br>CAS需要三个参数 address,old_value, new_value.<br>modern CPU is required for this process.</p><p>CAS has its weakness as ABA problem, so memory barrier is necessary here to ensure the CAS is still correct in multithread environment.</p><ul><li>native的实现</li></ul><h3 id="Atomic-cmpxchg方法的分支"><a href="#Atomic-cmpxchg方法的分支" class="headerlink" title="Atomic::cmpxchg方法的分支"></a>Atomic::cmpxchg方法的分支</h3><p>依赖于OS &amp; CPU &amp; 32bit/64bit. 所以JVM在这里产生了分支</p><pre><code>// 4. from  hotspot/src/share/vm/runtime/atomic.cpp# include &quot;atomic_windows_x86.inline.hpp&quot;# include &quot;atomic_linux_x86.inline.hpp&quot;     // x86生产商有Intel, AMD, IBM等# include &quot;atomic_solaris_sparc.inline.hpp&quot; // Solaris系统，sparc处理器(都是sun的)# include &quot;atomic_linux_sparc.inline.hpp&quot;   // linux系统，sparc处理器...</code></pre><p>linux_x86中：</p><pre><code>// from openjdk/hotspot/os_cpu/linux_x86/vm/atomic_linux_x86.inline.hpp#ifdef AMD64inline jlong    Atomic::cmpxchg    (jlong    exchange_value, volatile jlong*    dest, jlong    compare_value) {  bool mp = os::is_MP();  __asm__ __volatile__ (LOCK_IF_MP(%4) &quot;cmpxchgq %1,(%3)&quot;                        : &quot;=a&quot; (exchange_value)                        : &quot;r&quot; (exchange_value), &quot;a&quot; (compare_value), &quot;r&quot; (dest), &quot;r&quot; (mp)                        : &quot;cc&quot;, &quot;memory&quot;);  return exchange_value;}#else // !AMD64inline jlong    Atomic::cmpxchg    (jlong    exchange_value, volatile jlong*    dest, jlong    compare_value) {  return _Atomic_cmpxchg_long(exchange_value, dest, compare_value, os::is_MP());}#endif // AMD64</code></pre><p>windows_x86中</p><pre><code>// from openjdk\hotspot\src\os_cpu\windows_x86\vm#ifdef AMD64inline jlong    Atomic::cmpxchg    (jlong    exchange_value, volatile jlong*    dest, jlong    compare_value) {  return (*os::atomic_cmpxchg_long_func)(exchange_value, dest, compare_value);}#else // !AMD64inline jlong    Atomic::cmpxchg    (jlong    exchange_value, volatile jlong*    dest, jlong    compare_value) {  int mp = os::is_MP();  jint ex_lo  = (jint)exchange_value;  jint ex_hi  = *( ((jint*)&amp;exchange_value) + 1 );  jint cmp_lo = (jint)compare_value;  jint cmp_hi = *( ((jint*)&amp;compare_value) + 1 );  __asm {    push ebx    push edi    mov eax, cmp_lo    mov edx, cmp_hi    mov edi, dest    mov ebx, ex_lo    mov ecx, ex_hi    LOCK_IF_MP(mp)    cmpxchg8b qword ptr [edi]    pop edi    pop ebx  }}#endif // AMD64</code></pre><p>其他平台…</p><p>可以看出，当CPU支持时，最终确实是直接用cmpxchg相关指令实现的。</p><h3 id="ObjectLocker锁"><a href="#ObjectLocker锁" class="headerlink" title="ObjectLocker锁"></a>ObjectLocker锁</h3><p>这是synchronized锁吗？</p><h2 id="Why-would-you-use-a-CAS-function"><a href="#Why-would-you-use-a-CAS-function" class="headerlink" title="Why would you use a CAS function?"></a>Why would you use a CAS function?</h2><h2 id="名词解释"><a href="#名词解释" class="headerlink" title="名词解释"></a>名词解释</h2><ul><li><p>Solaris：原是太阳微系统公司研制的类Unix操作系统，在Sun公司被Oracle并购后，称作Oracle Solaris。早期的Solaris主要用于Sun工作站上</p></li><li><p>saparc: sun公司开发的处理器，用于Sun工作站等上。Solaris在SPARC上拥有强大的处理能力和硬件支持(相对Intel x86平台)</p></li><li><p>cx8:</p></li><li><p>ObjectLocker:</p></li></ul><h2 id="疑问"><a href="#疑问" class="headerlink" title="疑问"></a>疑问</h2><ul><li><p>i = i + 1不是原子操作吗？为什么AtomicLong.incrementAndGet()的实现要这么复杂?直接用i = i + 1实现不行吗？(见《java并发编程实战》18页)</p></li><li><p>#include <atomic\> C++自带的实现与atomic_linux_x86.inline.hpp有什么区别？应该前者是后者的进一步封装吧？</atomic\></p></li><li><p>这个native方法的实现为什么在JVM层而不在jdk层？JVM是用来run byte code的。这里的JVM代码是用来run哪个byte code呢？</p></li><li><p>这里生成的byte code是啥样的？</p></li></ul><h2 id="再挖掘"><a href="#再挖掘" class="headerlink" title="再挖掘"></a>再挖掘</h2><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li>(<a href="http://stackoverflow.com/questions/7169961/can-anyone-interpret-this-c-code-from-openjdk6-into-plain-english" target="_blank" rel="noopener">http://stackoverflow.com/questions/7169961/can-anyone-interpret-this-c-code-from-openjdk6-into-plain-english</a>)</li></ul>]]></content>
      
      <categories>
          
          <category> CS </category>
          
          <category> programing </category>
          
          <category> lan </category>
          
          <category> java </category>
          
          <category> jdk </category>
          
          <category> rt </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>java系列 - Object</title>
      <link href="/pub/1c98e0dc/"/>
      <url>/pub/1c98e0dc/</url>
      <content type="html"><![CDATA[<h2 id="架构"><a href="#架构" class="headerlink" title="架构"></a>架构</h2><ul><li>Object.java(rt.jar) 调用 jdk的native方法(Object.c)。</li><li>native方法 调用hotspot jvm的方法(jvm.cpp)。</li></ul><h2 id="Object-java"><a href="#Object-java" class="headerlink" title="Object.java"></a>Object.java</h2><ul><li>java source版本：oracle 1.7</li></ul><p>Object 还有隐形的构造函数.<br>new Object();<br>new Object[int]; // 在ArrayList的构造函数中用到了</p><p>疑问：</p><h3 id="为什么Object-java中看不到构造函数"><a href="#为什么Object-java中看不到构造函数" class="headerlink" title="为什么Object.java中看不到构造函数"></a>为什么Object.java中看不到构造函数</h3><p>编译器为它生成了构造函数</p><h3 id="为什么在stack-trace中看不到调用Object"><a href="#为什么在stack-trace中看不到调用Object" class="headerlink" title="为什么在stack trace中看不到调用Object."></a>为什么在stack trace中看不到调用Object.<init></init></h3><p>有7个native方法。</p><ul><li>private static native void registerNatives();</li><li>protected native Object clone() throws CloneNotSupportedException;</li><li>public final native Class&lt;?&gt; getClass();</li><li>public native int hashCode();</li><li>public final native void notify();</li><li>public final native void notifyAll();</li><li>public final native void wait(long timeout) throws InterruptedException;</li></ul><ul><li>但是构造函数是怎样实现的呢？(见jvm目录的init.md)</li></ul><p>由于Object类中有JNI方法调用，按照JNI的规则，应当生成JNI 的头文件。<br>在此目录下执行javah -jni java.lang.Object 指令，将生成一个java_lang_Object.h头文件(自动生成的header，没什么意义)</p><h2 id="Object-c"><a href="#Object-c" class="headerlink" title="Object.c"></a>Object.c</h2><ul><li>source版本：openjdk-7-fcs-src-b147-27_jun_2011</li><li>路径: openjdk\jdk\src\share\native\java\lang\Object.c</li><li>没有Object.h</li></ul><p>Object.c</p><pre><code>/*- *      Implementation of class Object * *      former threadruntime.c, Sun Sep 22 12:09:39 1991 */#include &lt;stdio.h&gt;#include &lt;signal.h&gt;#include &lt;limits.h&gt;#include &quot;jni.h&quot;#include &quot;jni_util.h&quot;#include &quot;jvm.h&quot;#include &quot;java_lang_Object.h&quot;// JVM_这些函数是在jvm.c中实现的static JNINativeMethod methods[] = {    {&quot;hashCode&quot;,    &quot;()I&quot;,                    (void *)&amp;JVM_IHashCode},  //  返回int    {&quot;wait&quot;,        &quot;(J)V&quot;,                   (void *)&amp;JVM_MonitorWait}, // 返回void，参数是long    {&quot;notify&quot;,      &quot;()V&quot;,                    (void *)&amp;JVM_MonitorNotify},  // 返回void    {&quot;notifyAll&quot;,   &quot;()V&quot;,                    (void *)&amp;JVM_MonitorNotifyAll}, // 返回void    {&quot;clone&quot;,       &quot;()Ljava/lang/Object;&quot;,   (void *)&amp;JVM_Clone}, // 返回Ojbect};JNIEXPORT void JNICALLJava_java_lang_Object_registerNatives(JNIEnv *env, jclass cls){    (*env)-&gt;RegisterNatives(env, cls,                            methods, sizeof(methods)/sizeof(methods[0]));}JNIEXPORT jclass JNICALLJava_java_lang_Object_getClass(JNIEnv *env, jobject this){    if (this == NULL) {        JNU_ThrowNullPointerException(env, NULL);        return 0;    } else {        return (*env)-&gt;GetObjectClass(env, this);    }}</code></pre><p>其中JNINativeMethod的结构体如下:</p><pre><code>typedef struct {    char *name; // Java中函数的名字    char *signature; // signature 方法签名，描述了函数的参数和返回值    void *fnPtr;  // native实现的函数指针，指向C函数} JNINativeMethod;</code></pre><h2 id="跟踪-hashcode"><a href="#跟踪-hashcode" class="headerlink" title="跟踪 hashcode"></a>跟踪 hashcode</h2><pre><code>// jvm.h 路径: openjdk\hotspot\src\share\vm\prims\jvm.hJNIEXPORT jint JNICALLJVM_IHashCode(JNIEnv *env, jobject obj);// jvm.cpp 路径: openjdk\hotspot\src\share\vm\prims\jvm.cppJVM_ENTRY(jint, JVM_IHashCode(JNIEnv* env, jobject handle))  JVMWrapper(&quot;JVM_IHashCode&quot;);  // as implemented in the classic virtual machine; return 0 if object is NULL  return handle == NULL ? 0 : ObjectSynchronizer::FastHashCode (THREAD, JNIHandles::resolve_non_null(handle)) ;JVM_END</code></pre><p>FastHashCode才是真正计算hashcode的代码</p><h3 id="FastHashCode"><a href="#FastHashCode" class="headerlink" title="FastHashCode"></a>FastHashCode</h3><p>这是hashCode()的具体实现</p><pre><code>// 路径: openjdk\hotspot\src\share\vm\runtime\synchronizer.cppintptr_t ObjectSynchronizer::FastHashCode (Thread * Self, oop obj) {  if (UseBiasedLocking) {    // NOTE: many places throughout the JVM do not expect a safepoint    // to be taken here, in particular most operations on perm gen    // objects. However, we only ever bias Java instances and all of    // the call sites of identity_hash that might revoke biases have    // been checked to make sure they can handle a safepoint. The    // added check of the bias pattern is to avoid useless calls to    // thread-local storage.    if (obj-&gt;mark()-&gt;has_bias_pattern()) {      // Box and unbox the raw reference just in case we cause a STW safepoint.      Handle hobj (Self, obj) ;      // Relaxing assertion for bug 6320749.      assert (Universe::verify_in_progress() ||              !SafepointSynchronize::is_at_safepoint(),             &quot;biases should not be seen by VM thread here&quot;);      BiasedLocking::revoke_and_rebias(hobj, false, JavaThread::current());      obj = hobj() ;      assert(!obj-&gt;mark()-&gt;has_bias_pattern(), &quot;biases should be revoked by now&quot;);    }  }  // hashCode() is a heap mutator ...  // Relaxing assertion for bug 6320749.  assert (Universe::verify_in_progress() ||          !SafepointSynchronize::is_at_safepoint(), &quot;invariant&quot;) ;  assert (Universe::verify_in_progress() ||          Self-&gt;is_Java_thread() , &quot;invariant&quot;) ;  assert (Universe::verify_in_progress() ||         ((JavaThread *)Self)-&gt;thread_state() != _thread_blocked, &quot;invariant&quot;) ;  ObjectMonitor* monitor = NULL;  markOop temp, test;  intptr_t hash;  markOop mark = ReadStableMark (obj);  // object should remain ineligible for biased locking  assert (!mark-&gt;has_bias_pattern(), &quot;invariant&quot;) ;  if (mark-&gt;is_neutral()) {    hash = mark-&gt;hash();              // this is a normal header 对象的hashcode存储在对象头里    if (hash) {                       // if it has hash, just return it 注意这里有个cache，对于同一个Ojbect，第一次调用Object.hashCode将会执行实际的计算并记入cache，以后直接从cache中取出。      return hash;    }    hash = get_next_hash(Self, obj);  // allocate a new hash code    temp = mark-&gt;copy_set_hash(hash); // merge the hash code into header    // use (machine word version) atomic operation to install the hash    test = (markOop) Atomic::cmpxchg_ptr(temp, obj-&gt;mark_addr(), mark);    if (test == mark) {      return hash;    }    // If atomic operation failed, we must inflate the header    // into heavy weight monitor. We could add more code here    // for fast path, but it does not worth the complexity.  } else if (mark-&gt;has_monitor()) {    monitor = mark-&gt;monitor();    temp = monitor-&gt;header();    assert (temp-&gt;is_neutral(), &quot;invariant&quot;) ;    hash = temp-&gt;hash();    if (hash) {      return hash;    }    // Skip to the following code to reduce code size  } else if (Self-&gt;is_lock_owned((address)mark-&gt;locker())) {    temp = mark-&gt;displaced_mark_helper(); // this is a lightweight monitor owned    assert (temp-&gt;is_neutral(), &quot;invariant&quot;) ;    hash = temp-&gt;hash();              // by current thread, check if the displaced    if (hash) {                       // header contains hash code      return hash;    }    // WARNING:    //   The displaced header is strictly immutable.    // It can NOT be changed in ANY cases. So we have    // to inflate the header into heavyweight monitor    // even the current thread owns the lock. The reason    // is the BasicLock (stack slot) will be asynchronously    // read by other threads during the inflate() function.    // Any change to stack may not propagate to other threads    // correctly.  }  // Inflate the monitor to set hash code  monitor = ObjectSynchronizer::inflate(Self, obj);  // Load displaced header and check it has hash code  mark = monitor-&gt;header();  assert (mark-&gt;is_neutral(), &quot;invariant&quot;) ;  hash = mark-&gt;hash();  // 取出缓存  if (hash == 0) {    hash = get_next_hash(Self, obj);  // 实际计算    temp = mark-&gt;copy_set_hash(hash); // merge hash code into header    assert (temp-&gt;is_neutral(), &quot;invariant&quot;) ;    test = (markOop) Atomic::cmpxchg_ptr(temp, monitor, mark);    if (test != mark) {      // The only update to the header in the monitor (outside GC)      // is install the hash code. If someone add new usage of      // displaced header, please update this code      hash = test-&gt;hash();      assert (test-&gt;is_neutral(), &quot;invariant&quot;) ;      assert (hash != 0, &quot;Trivial unexpected object/monitor header usage.&quot;);    }  }  // We finally get the hash  return hash;}</code></pre><h3 id="get-next-hash-—-这才是核心代码"><a href="#get-next-hash-—-这才是核心代码" class="headerlink" title="get_next_hash — 这才是核心代码"></a>get_next_hash — 这才是核心代码</h3><p>又调用的get_next_hash()</p><pre><code>// 路径: openjdk\hotspot\src\share\vm\runtime\synchronizer.cppstatic inline intptr_t get_next_hash(Thread * Self, oop obj) {  intptr_t value = 0 ;  if (hashCode == 0) {     // This form uses an unguarded global Park-Miller RNG,     // so it&#39;s possible for two threads to race and generate the same RNG.     // On MP system we&#39;ll have lots of RW access to a global, so the     // mechanism induces lots of coherency traffic.     value = os::random() ;  } else  if (hashCode == 1) {     // This variation has the property of being stable (idempotent)     // between STW operations.  This can be useful in some of the 1-0     // synchronization schemes.     intptr_t addrBits = intptr_t(obj) &gt;&gt; 3 ;     value = addrBits ^ (addrBits &gt;&gt; 5) ^ GVars.stwRandom ;  } else  if (hashCode == 2) {     value = 1 ;            // for sensitivity testing  } else  if (hashCode == 3) {     value = ++GVars.hcSequence ;  } else  if (hashCode == 4) {     value = intptr_t(obj) ;  } else {     // Marsaglia&#39;s xor-shift scheme with thread-specific state     // This is probably the best overall implementation -- we&#39;ll     // likely make this the default in future releases.     unsigned t = Self-&gt;_hashStateX ;     t ^= (t &lt;&lt; 11) ;     Self-&gt;_hashStateX = Self-&gt;_hashStateY ;     Self-&gt;_hashStateY = Self-&gt;_hashStateZ ;     Self-&gt;_hashStateZ = Self-&gt;_hashStateW ;     unsigned v = Self-&gt;_hashStateW ;     v = (v ^ (v &gt;&gt; 19)) ^ (t ^ (t &gt;&gt; 8)) ;     Self-&gt;_hashStateW = v ;     value = v ;  }  value &amp;= markOopDesc::hash_mask;  if (value == 0) value = 0xBAD ;  assert (value != markOopDesc::no_hash, &quot;invariant&quot;) ;  TEVENT (hashCode: GENERATE) ;  return value;}</code></pre><p>hashCode()并不是简单的返回内存地址。<br>OpenJDK一共实现了5中不同的计算hash值的方法，通过<br>这段代码中hashCode进行切换。其中hashCode == 4的是直接使用地址的（前面的实验说明OpenJDK默认情况下并没有使用这种方式，或许可以通过运行/编译时参数进行选择）。</p><h2 id=""><a href="#" class="headerlink" title="#"></a>#</h2><h3 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h3><p>前面通过JNI验证已经能够得到很显然的结论，hashCode返回的并不一定是对象的（虚拟）内存地址，具体取决于运行时库和JVM的具体实现。</p><h2 id="跟踪wait"><a href="#跟踪wait" class="headerlink" title="跟踪wait"></a>跟踪wait</h2><pre><code>JNIEXPORT void JNICALLJVM_MonitorWait(JNIEnv *env, jobject obj, jlong ms);// 路径: openjdk\hotspot\src\share\vm\prims\jvm.cppJVM_ENTRY(void, JVM_MonitorWait(JNIEnv* env, jobject handle, jlong ms))  JVMWrapper(&quot;JVM_MonitorWait&quot;);  Handle obj(THREAD, JNIHandles::resolve_non_null(handle));  assert(obj-&gt;is_instance() || obj-&gt;is_array(), &quot;JVM_MonitorWait must apply to an object&quot;);  JavaThreadInObjectWaitState jtiows(thread, ms != 0);  if (JvmtiExport::should_post_monitor_wait()) {    JvmtiExport::post_monitor_wait((JavaThread *)THREAD, (oop)obj(), ms);  }  ObjectSynchronizer::wait(obj, ms, CHECK);JVM_END</code></pre><h2 id="跟踪notify"><a href="#跟踪notify" class="headerlink" title="跟踪notify"></a>跟踪notify</h2><pre><code>JNIEXPORT void JNICALLJVM_MonitorNotify(JNIEnv *env, jobject obj);// 路径: openjdk\hotspot\src\share\vm\prims\jvm.cppJVM_ENTRY(void, JVM_MonitorNotify(JNIEnv* env, jobject handle))  JVMWrapper(&quot;JVM_MonitorNotify&quot;);  Handle obj(THREAD, JNIHandles::resolve_non_null(handle));  assert(obj-&gt;is_instance() || obj-&gt;is_array(), &quot;JVM_MonitorNotify must apply to an object&quot;);  ObjectSynchronizer::notify(obj, CHECK);JVM_END</code></pre><h2 id="跟踪clone"><a href="#跟踪clone" class="headerlink" title="跟踪clone"></a>跟踪clone</h2><pre><code>JNIEXPORT jobject JNICALLJVM_Clone(JNIEnv *env, jobject obj);// 路径: openjdk\hotspot\src\share\vm\prims\jvm.cppJVM_ENTRY(jobject, JVM_Clone(JNIEnv* env, jobject handle))  JVMWrapper(&quot;JVM_Clone&quot;);  Handle obj(THREAD, JNIHandles::resolve_non_null(handle));  const KlassHandle klass (THREAD, obj-&gt;klass());  JvmtiVMObjectAllocEventCollector oam;</code></pre><h2 id="跟踪-getClass"><a href="#跟踪-getClass" class="headerlink" title="跟踪 getClass"></a>跟踪 getClass</h2><h2 id="跟踪"><a href="#跟踪" class="headerlink" title="跟踪"></a>跟踪</h2><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="http://blog.csdn.net/xusiwei1236/article/details/45152201" target="_blank" rel="noopener">http://blog.csdn.net/xusiwei1236/article/details/45152201</a></p><h2 id="byte-code"><a href="#byte-code" class="headerlink" title="byte code"></a>byte code</h2><ul><li>通过编译后的jar包(即class文件)，查看byte code.</li><li>运行 javap -c java.lang.Object &gt; a.txt，得到以下的byte code</li></ul><p>如果执行不成功，看看是否把jdk的lib加入到了classpath:</p><pre><code>Compiled from &quot;Object.java&quot;public class java.lang.Object {  public java.lang.Object();  // 什么都不干？不需要调用&lt;init&gt;吗？    Code:       0: return          public final native java.lang.Class&lt;?&gt; getClass();  public native int hashCode();  public boolean equals(java.lang.Object);    Code:       0: aload_0              1: aload_1              2: if_acmpne     9       5: iconst_1             6: goto          10       9: iconst_0            10: ireturn         protected native java.lang.Object clone() throws java.lang.CloneNotSupportedException;  public java.lang.String toString();    Code:       0: new           #1                  // class java/lang/StringBuilder       3: dup                  4: invokespecial #2                  // Method java/lang/StringBuilder.&quot;&lt;init&gt;&quot;:()V           // 注意这里，调用了&lt;init&gt;       7: aload_0              8: invokevirtual #3                  // Method getClass:()Ljava/lang/Class;      11: invokevirtual #4                  // Method java/lang/Class.getName:()Ljava/lang/String;      14: invokevirtual #5                  // Method java/lang/StringBuilder.append:(Ljava/lang/String;)Ljava/lang/StringBuilder;      17: ldc           #6                  // String @      19: invokevirtual #5                  // Method java/lang/StringBuilder.append:(Ljava/lang/String;)Ljava/lang/StringBuilder;      22: aload_0             23: invokevirtual #7                  // Method hashCode:()I      26: invokestatic  #8                  // Method java/lang/Integer.toHexString:(I)Ljava/lang/String;      29: invokevirtual #5                  // Method java/lang/StringBuilder.append:(Ljava/lang/String;)Ljava/lang/StringBuilder;      32: invokevirtual #9                  // Method java/lang/StringBuilder.toString:()Ljava/lang/String;      35: areturn         public final native void notify();  public final native void notifyAll();  public final native void wait(long) throws java.lang.InterruptedException;  public final void wait(long, int) throws java.lang.InterruptedException;    Code:       0: lload_1              1: lconst_0             2: lcmp                 3: ifge          16       6: new           #10                 // class java/lang/IllegalArgumentException       9: dup                 10: ldc           #11                 // String timeout value is negative      12: invokespecial #12                 // Method java/lang/IllegalArgumentException.&quot;&lt;init&gt;&quot;:(Ljava/lang/String;)V      15: athrow              16: iload_3             17: iflt          26      20: iload_3             21: ldc           #13                 // int 999999      23: if_icmple     36      26: new           #10                 // class java/lang/IllegalArgumentException      29: dup                 30: ldc           #14                 // String nanosecond timeout value out of range      32: invokespecial #12                 // Method java/lang/IllegalArgumentException.&quot;&lt;init&gt;&quot;:(Ljava/lang/String;)V      35: athrow              36: iload_3             37: ldc           #15                 // int 500000      39: if_icmpge     52      42: iload_3             43: ifeq          56      46: lload_1             47: lconst_0            48: lcmp                49: ifne          56      52: lload_1             53: lconst_1            54: ladd                55: lstore_1            56: aload_0             57: lload_1             58: invokevirtual #16                 // Method wait:(J)V      61: return          public final void wait() throws java.lang.InterruptedException;    Code:       0: aload_0              1: lconst_0             2: invokevirtual #16                 // Method wait:(J)V       5: return          protected void finalize() throws java.lang.Throwable;    Code:       0: return          static {};    Code:       0: invokestatic  #17                 // Method registerNatives:()V       3: return        }</code></pre><p>C:\Program Files\java\jdk1.7.0_67\jre\lib\rt&gt;</p><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><ul><li>object header: it’s JVM dependent， 具体参考JVM</li></ul><h2 id="扩展阅读"><a href="#扩展阅读" class="headerlink" title="扩展阅读"></a>扩展阅读</h2><ul><li><a href="http://www.voidcn.com/blog/xusiwei1236/article/p-35249.html" target="_blank" rel="noopener">Object.hashCode()的返回值到底是不是对象内存地址</a></li></ul>]]></content>
      
      <categories>
          
          <category> CS </category>
          
          <category> programing </category>
          
          <category> lan </category>
          
          <category> java </category>
          
          <category> jdk </category>
          
          <category> rt </category>
          
          <category> lang </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>java系列 - Error &amp; Exception</title>
      <link href="/pub/e2072a3f/"/>
      <url>/pub/e2072a3f/</url>
      <content type="html"><![CDATA[<h2 id="definition"><a href="#definition" class="headerlink" title="definition"></a>definition</h2><ul><li>catch an error at compile time:  before you even try to run the program  (think in java)<br>-<h2 id="java-framework"><a href="#java-framework" class="headerlink" title="java framework"></a>java framework</h2></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">Throwable─┬─Exception─┬─RuntimeException─┬─IndexOutOfBoundsException</span><br><span class="line">          │           │                  ├─NullPointerException</span><br><span class="line">          │           │                  │</span><br><span class="line">          │           │                  │</span><br><span class="line">          │           │                  │</span><br><span class="line">          │           │                  │</span><br><span class="line">          │           │                  │</span><br><span class="line">          │           │                  │</span><br><span class="line">          │           │                  └─</span><br><span class="line">          │           │                  </span><br><span class="line">          │           ├─ ReflectiveOperationException─┬─NoSuchMethodException</span><br><span class="line">          │           │                               ├─ClassNotFoundException</span><br><span class="line">          │           │                               └─IllegalAccessException</span><br><span class="line">          │           │</span><br><span class="line">          │           │</span><br><span class="line">          │           │</span><br><span class="line">          │           ├─IOException─┬─FileNotFoundException</span><br><span class="line">          │           │             ├─EOFException</span><br><span class="line">          │</span><br><span class="line">          └─Error─┬─</span><br></pre></td></tr></table></figure><div class="table-container"><table><thead><tr><th></th><th>RuntimeException</th><th>non-RuntimeException</th></tr></thead><tbody><tr><td>checked</td><td>×</td><td>√</td></tr><tr><td>occur in</td><td>runtime</td><td><strong>runtime</strong></td></tr><tr><td>must catch</td><td>×</td><td>√</td></tr><tr><td>caused by</td><td>programmer,such as NullPointerException, IndexOutOfBoundsException</td><td>external, such as FileNotFoundException</td></tr><tr><td>thrown</td><td>during the normal operation of JVM</td></tr></tbody></table></div><p> Compile-Time Checking of Exceptions</p><h2 id="设计思想"><a href="#设计思想" class="headerlink" title="设计思想"></a>设计思想</h2><p><strong>RuntimeException</strong><br>一般情况下，不要捕获或声明RuntimeException。因为问题在于你的程序逻辑本身有问题，<br>如果你用异常流程处理了，反而让正常流程问题一直存在。<br>程序应该从逻辑角度尽可能避免这类异常的发生；</p><p><strong>non-RuntimeException</strong><br>RuntimeException之外的异常我们统称为非运行时异常。<br>从程序语法角度讲是必须进行处理的异常，如果不处理，程序就不能编译通过。</p><p>非运行时异常，编译期要做语法检查，即检查是否处理了catch。程序报Exception还是要运行期才能知道的。</p><p>An Exception is checked, and a RuntimeException is unchecked.</p><ul><li>A checked exception must be handled explicitly by the code (catch or throw)</li><li>An un-checked exception does not need to be explicitly handled.</li></ul><h2 id="ambiguous-common-errors-common-misconceptions"><a href="#ambiguous-common-errors-common-misconceptions" class="headerlink" title="ambiguous, common errors, common misconceptions"></a>ambiguous, common errors, common misconceptions</h2><p>Is non-RuntimeException CompiletimeException in java framework?<br>No, non-RuntimeException would be checked in compile time. But the Exception occurs in run time.</p><h2 id="where-did-RuntimeException-comes-from"><a href="#where-did-RuntimeException-comes-from" class="headerlink" title="where did RuntimeException comes from"></a>where did RuntimeException comes from</h2><p>since JDK1.0</p><h2 id="new-reasonable-framework"><a href="#new-reasonable-framework" class="headerlink" title="new/reasonable framework"></a>new/reasonable framework</h2><p>In my view, the RuntimeException should be renamed as CheckedException</p><ul><li>RuntimeException<ul><li>CheckedException</li><li>UncheckedException</li></ul></li><li>CompiletimeException<ul><li>..</li></ul></li></ul><h2 id="reference"><a href="#reference" class="headerlink" title="reference"></a>reference</h2><ul><li>《The Java™ Language Specification》11.2  Compile-Time Checking of Exceptions</li></ul><h2 id="other-framework"><a href="#other-framework" class="headerlink" title="other framework"></a>other framework</h2><ol><li><java 8="" language="" specification=""><blockquote><p>Some programming languages and their implementations react to such errors<br>by peremptorily terminating the program; other programming languages allow an<br>implementation to react in an arbitrary or unpredictable way. Neither of these<br>approaches is compatible with the design goals of the Java SE platform: to provide<br>portability and robustness.</p></blockquote></java></li></ol><blockquote><p>Instead, the Java programming language specifies that an exception will be thrown<br>when semantic constraints are violated and will cause a non-local transfer of control<br>from the point where the exception occurred to a point that can be specified by the<br>programmer.</p></blockquote><p>2.</p><h3 id="python-framework"><a href="#python-framework" class="headerlink" title="python framework"></a>python framework</h3><p>reference: <a href="http://www.cnblogs.com/rubylouvre/archive/2011/06/22/2086644.html" target="_blank" rel="noopener">http://www.cnblogs.com/rubylouvre/archive/2011/06/22/2086644.html</a></p><h3 id="c-framework"><a href="#c-framework" class="headerlink" title="c++ framework"></a>c++ framework</h3>]]></content>
      
      <categories>
          
          <category> CS </category>
          
          <category> programing </category>
          
          <category> lan </category>
          
          <category> java </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>java系列 - Map</title>
      <link href="/pub/8748fd7b/"/>
      <url>/pub/8748fd7b/</url>
      <content type="html"><![CDATA[<h1 id="diagram，java设计架构"><a href="#diagram，java设计架构" class="headerlink" title="diagram，java设计架构"></a>diagram，java设计架构</h1><p>来自网络 <a href="http://www.cnblogs.com/skywang12345/p/3308931.html" target="_blank" rel="noopener">http://www.cnblogs.com/skywang12345/p/3308931.html</a></p><p><img src="/images/raw/Java - diagram - java.util.Map - skywang.jpg"></p><p>Map 接口提供三种collection 视图，允许以键集、值集或键-值映射关系集的形式查看某个映射的内容。</p><p><img src="/images/raw/Java - diagram - java.util.Map - xusong.svg"></p><h1 id="summary"><a href="#summary" class="headerlink" title="summary"></a>summary</h1><div class="table-container"><table><thead><tr><th>类</th><th style="text-align:right">同步(线程安全)</th><th style="text-align:right">order</th><th style="text-align:right">null key</th><th>null value</th><th style="text-align:right">implementation</th><th style="text-align:right">增删查改(按key)</th><th>查(按value) containsValue</th><th>C</th><th style="text-align:center">C++(STL)</th><th>python</th></tr></thead><tbody><tr><td>HashMap</td><td style="text-align:right">×</td><td style="text-align:right">无序</td><td style="text-align:right">√</td><td>√</td><td style="text-align:right">hash table （采用seperate chaining解决键冲突）java8采用了哈希表与红黑树结合的方法</td><td style="text-align:right">O(1)</td><td>顺序查找 O(n)</td><td>比如redis的实现</td><td style="text-align:center"></td><td></td></tr><tr><td>LinkedHashmap</td><td style="text-align:right">×</td><td style="text-align:right">按插入顺序排序</td><td style="text-align:right">√</td><td>√</td><td style="text-align:right">同上</td><td style="text-align:right"></td><td></td><td></td><td style="text-align:center"></td><td></td></tr><tr><td>Hashtable</td><td style="text-align:right">√</td><td style="text-align:right">无序</td><td style="text-align:right">×</td><td>×</td><td style="text-align:right">同上</td><td style="text-align:right"></td><td></td><td></td><td style="text-align:center"></td><td></td></tr><tr><td>TreeMap</td><td style="text-align:right"></td><td style="text-align:right">按key自定义排序</td><td style="text-align:right"></td><td></td><td style="text-align:right">红黑树</td><td style="text-align:right">O(log n)</td><td></td><td></td><td style="text-align:center"></td><td>无</td></tr><tr><td>WeakHashMap</td><td style="text-align:right"></td><td style="text-align:right"></td><td style="text-align:right"></td><td></td><td style="text-align:right"></td><td style="text-align:right"></td><td></td><td></td><td style="text-align:center"></td><td></td></tr><tr><td>EnumMap</td><td style="text-align:right"></td><td style="text-align:right"></td><td style="text-align:right"></td><td></td><td style="text-align:right"></td><td style="text-align:right"></td><td></td><td></td><td style="text-align:center"></td></tr></tbody></table></div><ul><li>HashMap是非synchronized，而Hashtable是synchronized，这意味着Hashtable是线程安全的，多个线程可以共享一个Hashtable；而如果没有正确的同步的话，多个线程是不能共享HashMap的。Java 5提供了ConcurrentHashMap，它是HashTable的替代，比HashTable的扩展性更好。</li><li>HashMap的迭代器(Iterator)是fail-fast迭代器，而Hashtable的enumerator迭代器不是fail-fast的。所以当有其它线程改变了HashMap的结构（增加或者移除元素），将会抛出ConcurrentModificationException，但迭代器本身的remove()方法移除元素则不会抛出ConcurrentModificationException异常。但这并不是一个一定发生的行为，要看JVM。这条同样也是Enumeration和Iterator的区别。</li></ul><blockquote><p>sychronized意味着在一次仅有一个线程能够更改Hashtable。就是说任何线程要更新Hashtable时要首先获得同步锁，其它线程要等到同步锁被释放之后才能再次获得同步锁更新Hashtable。<br>Fail-safe和iterator迭代器相关。如果某个集合对象创建了Iterator或者ListIterator，然后其它的线程试图“结构上”更改集合对象，将会抛出ConcurrentModificationException异常。但其它线程可以通过set()方法更改集合对象是允许的，因为这并没有从“结构上”更改集合。但是假如已经从结构上进行了更改，再调用set()方法，将会抛出IllegalArgumentException异常。<br> 结构上的更改指的是删除或者插入一个元素，这样会影响到map的结构。</p></blockquote><p>有没有既linked，又线程安全的Map，答案没有。因为多个线程同时操作，不同的执行顺序会产生不同的结果。所以linked的东东都应该不存在线程安全性。不能加锁吗？ —by xs</p><h1 id="底层实现"><a href="#底层实现" class="headerlink" title="底层实现"></a>底层实现</h1><p>HashTable使用Enumeration，HashMap使用Iterator。<br>HashTable中hash数组默认大小是11，增加的方式是 old*2+1。HashMap中hash数组的默认大小是16，而且一定是2的指数。</p><p>6.哈希值的使用不同，HashTable直接使用对象的hashCode，代码是这样的：<br>int hash = key.hashCode();<br>int index = (hash &amp; 0x7FFFFFFF) % tab.length;<br>而HashMap重新计算hash值，而且用与代替求模：<br>int hash = hash(k);<br>int i = indexFor(hash, table.length);</p><p>static int hash(Object x) {<br>　　int h = x.hashCode();</p><p>　　h += ~(h &lt;&lt; 9);<br>　　h ^= (h &gt;&gt;&gt; 14);<br>　　h += (h &lt;&lt; 4);<br>　　h ^= (h &gt;&gt;&gt; 10);<br>　　return h;<br>}<br>static int indexFor(int h, int length) {<br>　　return h &amp; (length-1);<br>}<br>以上只是一些比较突出的区别，当然他们的实现上还是有很多不同的，比如<br>HashMap对null的操作</p><h1 id="哈希冲突"><a href="#哈希冲突" class="headerlink" title="哈希冲突"></a>哈希冲突</h1>]]></content>
      
      <categories>
          
          <category> CS </category>
          
          <category> programing </category>
          
          <category> lan </category>
          
          <category> java </category>
          
          <category> jdk </category>
          
          <category> rt </category>
          
          <category> util </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>java hotspot虚拟机 - init方法</title>
      <link href="/pub/e4c70599/"/>
      <url>/pub/e4c70599/</url>
      <content type="html"><![CDATA[<h2 id="初始化方法"><a href="#初始化方法" class="headerlink" title="初始化方法"></a>初始化方法</h2><p>在编译生成class文件时，会自动产生两个方法，一个是类的初始化方法<clinit>, 另一个是实例的初始化方法<init></init></clinit></p><p><clinit>：在jvm第一次加载class文件时调用，包括静态变量初始化语句和静态块的执行</clinit></p><p><init>:在实例创建出来的时候调用，包括调用new操作符；调用Class或java.lang.reflect.Constructor对象的newInstance()方法；调用任何现有对象的clone()方法；通过java.io.ObjectInputStream类的getObject()方法反序列化。</init></p><h2 id="init的实现"><a href="#init的实现" class="headerlink" title="init的实现"></a>init的实现</h2><p>是由jvm实现的，以下是hotspot jvm实现的版本</p><p>openjdk\hotspot\src\share\vm\oops\instanceKlass.cpp<br>openjdk\hotspot\src\share\vm\oops\instanceKlassKlass.cpp</p><p>为什么叫</p><h2 id="名词解释"><a href="#名词解释" class="headerlink" title="名词解释"></a>名词解释</h2><ul><li><p>oops原来不是Object Oriented Programming，实际指的是 Ordinary Object Pointer（普通对象指针）。它用来表示对象的实例信息，看起来像个指针实际上是藏在指针里的对象。而klass则包含 元数据和方法信息，用来描述Java类。</p></li><li><p>Klass</p></li><li>KlassKlass</li></ul><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>(见JVM规范8中的2.9节)</p>]]></content>
      
      <categories>
          
          <category> CS </category>
          
          <category> programing </category>
          
          <category> lan </category>
          
          <category> java </category>
          
          <category> jdk </category>
          
          <category> jvm </category>
          
          <category> HotSpot </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>java hotspot虚拟机 - SocketOutputStream</title>
      <link href="/pub/5eb3e0be/"/>
      <url>/pub/5eb3e0be/</url>
      <content type="html"><![CDATA[<h2 id="SocketOutputStream-java"><a href="#SocketOutputStream-java" class="headerlink" title="SocketOutputStream.java"></a>SocketOutputStream.java</h2><p>就只有这一个native方法</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Writes to the socket.</span></span><br><span class="line"><span class="comment">* @param fd the FileDescriptor</span></span><br><span class="line"><span class="comment">* @param b the data to be written</span></span><br><span class="line"><span class="comment">* @param off the start offset in the data</span></span><br><span class="line"><span class="comment">* @param len the number of bytes that are written</span></span><br><span class="line"><span class="comment">* @exception IOException If an I/O error has occurred.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> native <span class="keyword">void</span> <span class="title">socketWrite0</span><span class="params">(FileDescriptor fd, byte[] b, <span class="keyword">int</span> off, <span class="keyword">int</span> len)</span> throws IOException</span>;</span><br></pre></td></tr></table></figure><h2 id="SocketOutputStream-c"><a href="#SocketOutputStream-c" class="headerlink" title="SocketOutputStream.c"></a>SocketOutputStream.c</h2><p>路径: <code>openjdk\jdk\src\windows\native\java\net\SocketOutputStream.c</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;winsock2.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ctype.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;malloc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"java_net_SocketOutputStream.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"net_util.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"jni_util.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/************************************************************************</span></span><br><span class="line"><span class="comment"> * SocketOutputStream</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> jfieldID IO_fd_fdID;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Class:     java_net_SocketOutputStream</span></span><br><span class="line"><span class="comment"> * Method:    init</span></span><br><span class="line"><span class="comment"> * Signature: ()V</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">JNIEXPORT <span class="keyword">void</span> JNICALL</span><br><span class="line">Java_java_net_SocketOutputStream_init(JNIEnv *env, jclass cls) &#123;</span><br><span class="line">    IO_fd_fdID = NET_GetFileDescriptorID(env);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Class:     java_net_SocketOutputStream</span></span><br><span class="line"><span class="comment"> * Method:    socketWrite</span></span><br><span class="line"><span class="comment"> * Signature: (Ljava/io/FileDescriptor;[BII)V</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">JNIEXPORT <span class="keyword">void</span> JNICALL</span><br><span class="line">Java_java_net_SocketOutputStream_socketWrite0(JNIEnv *env, jobject <span class="keyword">this</span>,</span><br><span class="line">                                              jobject fdObj, jbyteArray data,</span><br><span class="line">                                              jint off, jint len) &#123;</span><br><span class="line">    <span class="keyword">char</span> *bufP;</span><br><span class="line">    <span class="keyword">char</span> BUF[MAX_BUFFER_LEN];</span><br><span class="line">    <span class="keyword">int</span> buflen;</span><br><span class="line">    <span class="keyword">int</span> fd;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (IS_NULL(fdObj)) &#123;</span><br><span class="line">        JNU_ThrowByName(env, JNU_JAVANETPKG <span class="string">"SocketException"</span>, <span class="string">"Socket closed"</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        fd = (*env)-&gt;GetIntField(env, fdObj, IO_fd_fdID);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (IS_NULL(data)) &#123;</span><br><span class="line">        JNU_ThrowNullPointerException(env, <span class="string">"data argument"</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Use stack allocate buffer if possible. For large sizes we allocate</span></span><br><span class="line"><span class="comment">     * an intermediate buffer from the heap (up to a maximum). If heap is</span></span><br><span class="line"><span class="comment">     * unavailable just use our stack buffer.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (len &lt;= MAX_BUFFER_LEN) &#123;</span><br><span class="line">        bufP = BUF;</span><br><span class="line">        buflen = MAX_BUFFER_LEN;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        buflen = min(MAX_HEAP_BUFFER_LEN, len);</span><br><span class="line">        bufP = (<span class="keyword">char</span> *)<span class="built_in">malloc</span>((<span class="keyword">size_t</span>)buflen);</span><br><span class="line">        <span class="keyword">if</span> (bufP == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            bufP = BUF;</span><br><span class="line">            buflen = MAX_BUFFER_LEN;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(len &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> loff = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> chunkLen = min(buflen, len);</span><br><span class="line">        <span class="keyword">int</span> llen = chunkLen;</span><br><span class="line">        <span class="keyword">int</span> retry = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        (*env)-&gt;GetByteArrayRegion(env, data, off, chunkLen, (jbyte *)bufP);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(llen &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> n = send(fd, bufP + loff, llen, <span class="number">0</span>);</span><br><span class="line">            <span class="keyword">if</span> (n &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                llen -= n;</span><br><span class="line">                loff += n;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             * Due to a bug in Windows Sockets (observed on NT and Windows</span></span><br><span class="line"><span class="comment">             * 2000) it may be necessary to retry the send. The issue is that</span></span><br><span class="line"><span class="comment">             * on blocking sockets send/WSASend is supposed to block if there</span></span><br><span class="line"><span class="comment">             * is insufficient buffer space available. If there are a large</span></span><br><span class="line"><span class="comment">             * number of threads blocked on write due to congestion then it's</span></span><br><span class="line"><span class="comment">             * possile to hit the NT/2000 bug whereby send returns WSAENOBUFS.</span></span><br><span class="line"><span class="comment">             * The workaround we use is to retry the send. If we have a</span></span><br><span class="line"><span class="comment">             * large buffer to send (&gt;2k) then we retry with a maximum of</span></span><br><span class="line"><span class="comment">             * 2k buffer. If we hit the issue with &lt;=2k buffer then we backoff</span></span><br><span class="line"><span class="comment">             * for 1 second and retry again. We repeat this up to a reasonable</span></span><br><span class="line"><span class="comment">             * limit before bailing out and throwing an exception. In load</span></span><br><span class="line"><span class="comment">             * conditions we've observed that the send will succeed after 2-3</span></span><br><span class="line"><span class="comment">             * attempts but this depends on network buffers associated with</span></span><br><span class="line"><span class="comment">             * other sockets draining.</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="keyword">if</span> (WSAGetLastError() == WSAENOBUFS) &#123;</span><br><span class="line">                <span class="keyword">if</span> (llen &gt; MAX_BUFFER_LEN) &#123;</span><br><span class="line">                    buflen = MAX_BUFFER_LEN;</span><br><span class="line">                    chunkLen = MAX_BUFFER_LEN;</span><br><span class="line">                    llen = MAX_BUFFER_LEN;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (retry &gt;= <span class="number">30</span>) &#123;</span><br><span class="line">                    JNU_ThrowByName(env, JNU_JAVANETPKG <span class="string">"SocketException"</span>,</span><br><span class="line">                        <span class="string">"No buffer space available - exhausted attempts to queue buffer"</span>);</span><br><span class="line">                    <span class="keyword">if</span> (bufP != BUF) &#123;</span><br><span class="line">                        <span class="built_in">free</span>(bufP);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                Sleep(<span class="number">1000</span>);</span><br><span class="line">                retry++;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             * Send failed - can be caused by close or write error.</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="keyword">if</span> (WSAGetLastError() == WSAENOTSOCK) &#123;</span><br><span class="line">                JNU_ThrowByName(env, JNU_JAVANETPKG <span class="string">"SocketException"</span>, <span class="string">"Socket closed"</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                NET_ThrowCurrent(env, <span class="string">"socket write error"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (bufP != BUF) &#123;</span><br><span class="line">                <span class="built_in">free</span>(bufP);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        len -= chunkLen;</span><br><span class="line">        off += chunkLen;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (bufP != BUF) &#123;</span><br><span class="line">        <span class="built_in">free</span>(bufP);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> CS </category>
          
          <category> programing </category>
          
          <category> lan </category>
          
          <category> java </category>
          
          <category> jdk </category>
          
          <category> jvm </category>
          
          <category> HotSpot </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>java hotspot虚拟机 - class文件</title>
      <link href="/pub/3a5d7b99/"/>
      <url>/pub/3a5d7b99/</url>
      <content type="html"><![CDATA[<h2 id="oop-klass-model概述"><a href="#oop-klass-model概述" class="headerlink" title="oop-klass model概述"></a>oop-klass model概述</h2><p>HotSpot JVM并没有根据Java实例对象直接通过虚拟机映射到新建的C++对象，而是设计了一个oop-klass model。</p><p>当我们在写Java代码的时候，我们会面对着无数个接口，类，对象和方法。但我们有木有想过，Java中的这些对象、类和方法，在HotSpot JVM中的结构又是怎么样呢？HotSpot JVM底层都是C++实现的，那么Java的对象模型与C++对象模型之间又有什么关系呢？今天就来分析一下HotSpot JVM中的对象模型：oop-klass model，它们的源码位于openjdk-8/openjdk/hotspot/src/share/vm/oops文件夹内。</p><p>那么为何要设计这样一个一分为二的对象模型呢？这是因为HotSopt JVM的设计者不想让每个对象中都含有一个vtable（虚函数表），所以就把对象模型拆成klass和oop，其中oop中不含有任何虚函数，而klass就含有虚函数表，可以进行method dispatch。这个模型其实是参照的 Strongtalk VM 底层的对象模型。</p><p>jdk版本：openjdk-7-fcs-src-b147-27_jun_2011<br>源码路径：openjdk\hotspot\src\share\vm\oops\</p><p>在oopsHierarchy.hpp里定义了oop和klass各自的体系。<br>这是oop的体系：</p><pre><code>typedef class oopDesc*                            oop;typedef class   instanceOopDesc*            instanceOop;typedef class   methodOopDesc*                    methodOop;typedef class   constMethodOopDesc*            constMethodOop;typedef class   methodDataOopDesc*            methodDataOop;typedef class   arrayOopDesc*                    arrayOop;typedef class     objArrayOopDesc*            objArrayOop;typedef class     typeArrayOopDesc*            typeArrayOop;typedef class   constantPoolOopDesc*            constantPoolOop;typedef class   constantPoolCacheOopDesc*   constantPoolCacheOop;typedef class   klassOopDesc*                    klassOop;typedef class   markOopDesc*                    markOop;typedef class   compiledICHolderOopDesc*    compiledICHolderOop;</code></pre><h2 id="概述，代码架构"><a href="#概述，代码架构" class="headerlink" title="概述，代码架构"></a>概述，代码架构</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">klass.cpp</span><br><span class="line">oop.cpp</span><br><span class="line">arrayKlass.cpp</span><br><span class="line">arrayOop.cpp</span><br><span class="line">instanceKlass.cpp</span><br><span class="line">instanceOop.cpp  // #include &quot;oops/oop.hpp&quot;</span><br><span class="line">methodKlass.cpp</span><br><span class="line"></span><br><span class="line">// A methodOop represents a Java method.</span><br><span class="line">// #include &quot;oops/constantPoolOop.hpp&quot;#include &quot;oops/instanceKlass.hpp&quot; #include &quot;oops/oop.hpp&quot;</span><br><span class="line">methodOop.cpp  </span><br><span class="line"></span><br><span class="line">methodDataKlass.cpp</span><br><span class="line">methodDataOop.cpp</span><br><span class="line">objArrayKlass.cpp</span><br><span class="line">objArrayOop.cpp</span><br><span class="line"></span><br><span class="line">symbol.cpp</span><br></pre></td></tr></table></figure><h2 id="名词解释"><a href="#名词解释" class="headerlink" title="名词解释"></a>名词解释</h2><ul><li>oop：<br>Ordinary Object Pointer（普通对象指针），oop.h中定义了oopDesc类(没有oop这个类)</li></ul><p>oop* 有这个而东东啊</p><ul><li>Desc：<br>即Describe， {name}Desc classes describe the format of Java objects so the fields can be accessed from C++</li><li><p>oopDesc:<br>oop对象的类型其实是oopDesc*。在Java程序运行的过程中，每创建一个新的对象，在JVM内部就会相应地创建一个对应类型的oop对象。各种oop类的共同基类为oopDesc类。</p></li><li><p>oop-klass model：</p></li></ul><h3 id="Klass"><a href="#Klass" class="headerlink" title="Klass"></a>Klass</h3><p>一个Klass对象代表一个类的元数据（相当于java.lang.Class对象）。它提供：<br>language level class object (method dictionary etc.)<br>provide vm dispatch behavior for the object</p><p>所有的函数都被整合到一个C++类中。<br>Klass对象的继承关系：xxxKlass &lt;:&lt; Klass &lt;:&lt; Metadata &lt;:&lt; MetaspaceObj</p><p>klass对象的布局如下：<br>来自klass.hpp</p><pre><code>// A Klass is the part of the klassOop that provides://  1: language level class object (method dictionary etc.)//  2: provide vm dispatch behavior for the object// Both functions are combined into one C++ class. The toplevel class &quot;Klass&quot;// implements purpose 1 whereas all subclasses provide extra virtual functions// for purpose 2.// One reason for the oop/klass dichotomy in the implementation is// that we don&#39;t want a C++ vtbl pointer in every object.  Thus,// normal oops don&#39;t have any virtual functions.  Instead, they// forward all &quot;virtual&quot; functions to their klass, which does have// a vtbl and does the C++ dispatch depending on the object&#39;s// actual type.  (See oop.inline.hpp for some of the forwarding code.)// ALL FUNCTIONS IMPLEMENTING THIS DISPATCH ARE PREFIXED WITH &quot;oop_&quot;!//  Klass layout://    [header        ] klassOop//    [klass pointer ] klassOop//    [C++ vtbl ptr  ] (contained in Klass_vtbl)//    [layout_helper ]//    [super_check_offset   ] for fast subtype checks//    [secondary_super_cache] for fast subtype checks//    [secondary_supers     ] array of 2ndary supertypes//    [primary_supers 0]//    [primary_supers 1]//    [primary_supers 2]//    ...//    [primary_supers 7]//    [java_mirror   ]//    [super         ]//    [name          ]//    [first subklass]//    [next_sibling  ] link to chain additional subklasses//    [modifier_flags]//    [access_flags  ]//    [verify_count  ] - not in product//    [alloc_count   ]//    [last_biased_lock_bulk_revocation_time] (64 bits)//    [prototype_header]//    [biased_lock_revocation_count]</code></pre><h3 id="oop"><a href="#oop" class="headerlink" title="oop"></a>oop</h3><p>oop类型其实是oopDesc*。在Java程序运行的过程中，每创建一个新的对象，在JVM内部就会相应地创建一个对应类型的oop对象。各种oop类的共同基类为oopDesc类。</p><p>JVM内部，一个Java对象在内存中的布局可以连续分成两部分：instanceOopDesc和实例数据。instanceOopDesc和arrayOopDesc又称为对象头。</p><p>instanceOopDesc对象头包含两部分信息：Mark Word 和 元数据指针(Klass*)：</p><pre><code>// from oop.hpp// oopDesc is abstract.// (see oopHierarchy for complete oop class hierarchy)class oopDesc {  friend class VMStructs; private:  volatile markOop  _mark;  // mark word  union _metadata {    // metadata    wideKlassOop    _klass;    narrowOop       _compressed_klass;  } _metadata;  ...</code></pre><ul><li>Mark word: // 存储对象的hashCode或锁信息等。</li><li>Klass*  // 存储到对象类型数据的指针</li></ul><h2 id="基础知识："><a href="#基础知识：" class="headerlink" title="基础知识："></a>基础知识：</h2><h3 id="C-vtbl-pointer："><a href="#C-vtbl-pointer：" class="headerlink" title="C++ vtbl pointer："></a>C++ vtbl pointer：</h3><h3 id="虚函数"><a href="#虚函数" class="headerlink" title="虚函数"></a>虚函数</h3><p>ss</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="http://www.sczyh30.com/posts/Java/jvm-klass-oop/" target="_blank" rel="noopener">深入探究JVM | klass-oop对象模型研究</a></p>]]></content>
      
      <categories>
          
          <category> CS </category>
          
          <category> programing </category>
          
          <category> lan </category>
          
          <category> java </category>
          
          <category> jdk </category>
          
          <category> jvm </category>
          
          <category> HotSpot </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> hotspot </tag>
            
            <tag> class </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>java系列 - object</title>
      <link href="/pub/1b34e5ea/"/>
      <url>/pub/1b34e5ea/</url>
      <content type="html"><![CDATA[<h2 id="Object-java"><a href="#Object-java" class="headerlink" title="Object.java"></a>Object.java</h2><h3 id="有7个native方法。"><a href="#有7个native方法。" class="headerlink" title="有7个native方法。"></a>有7个native方法。</h3><ul><li>private static native void registerNatives();</li><li>protected native Object clone() throws CloneNotSupportedException;</li><li>public final native Class&lt;?&gt; getClass();</li><li>public native int hashCode();</li><li>public final native void notify();</li><li>public final native void notifyAll();</li><li>public final native void wait(long timeout) throws InterruptedException;</li></ul><ul><li>但是构造函数是怎样实现的呢？</li></ul><h2 id="java-lang-Object-go"><a href="#java-lang-Object-go" class="headerlink" title="java/lang/Object.go"></a>java/lang/Object.go</h2><p>cao，还是给我个c的实现吧，靠靠靠</p><pre><code>package langimport (    &quot;unsafe&quot;    &quot;github.com/zxh0/jvm.go/jvmgo/rtda&quot;    &quot;github.com/zxh0/jvm.go/jvmgo/rtda/heap&quot;)func init() {    _object(clone, &quot;clone&quot;, &quot;()Ljava/lang/Object;&quot;)    _object(getClass, &quot;getClass&quot;, &quot;()Ljava/lang/Class;&quot;)    _object(hashCode, &quot;hashCode&quot;, &quot;()I&quot;)    _object(notifyAll, &quot;notifyAll&quot;, &quot;()V&quot;)    _object(wait, &quot;wait&quot;, &quot;(J)V&quot;)}func _object(method func(frame *rtda.Frame), name, desc string) {    heap.RegisterNativeMethod(&quot;java/lang/Object&quot;, name, desc, method)}// protected native Object clone() throws CloneNotSupportedException;// ()Ljava/lang/Object;func clone(frame *rtda.Frame) {    vars := frame.LocalVars()    this := vars.GetThis()    // todo    stack := frame.OperandStack()    stack.PushRef(this.Clone())}// public final native Class&lt;?&gt; getClass();// ()Ljava/lang/Class;func getClass(frame *rtda.Frame) {    vars := frame.LocalVars()    this := vars.GetThis()    class := this.Class().JClass()    stack := frame.OperandStack()    stack.PushRef(class)}// public native int hashCode();// ()Ifunc hashCode(frame *rtda.Frame) {    vars := frame.LocalVars()    this := vars.GetThis()    hash := int32(uintptr(unsafe.Pointer(this)))    stack := frame.OperandStack()    stack.PushInt(hash)}// public final native void notify();// public final native void notifyAll();// ()Vfunc notifyAll(frame *rtda.Frame) {    vars := frame.LocalVars()    this := vars.GetThis()    thread := frame.Thread()    monitor := this.Monitor()    if !monitor.HasOwner(thread) {        // todo        panic(&quot;IllegalMonitorStateException&quot;)    }    monitor.NotifyAll()}// public final native void wait(long timeout) throws InterruptedException;// (J)Vfunc wait(frame *rtda.Frame) {    vars := frame.LocalVars()    this := vars.GetThis()    // timeout := vars.GetLong(1) // todo    thread := frame.Thread()    monitor := this.Monitor()    if !monitor.HasOwner(thread) {        // todo        panic(&quot;IllegalMonitorStateException&quot;)    }    monitor.Wait()}</code></pre>]]></content>
      
      <categories>
          
          <category> CS </category>
          
          <category> programing </category>
          
          <category> lan </category>
          
          <category> java </category>
          
          <category> jdk </category>
          
          <category> jvm </category>
          
          <category> jvmGo.md </category>
          
          <category> native </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>java系列 - System</title>
      <link href="/pub/7d785abb/"/>
      <url>/pub/7d785abb/</url>
      <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>java.lang.System.java</p><h2 id="跟踪arraycopy"><a href="#跟踪arraycopy" class="headerlink" title="跟踪arraycopy"></a>跟踪arraycopy</h2><p>public static native void arraycopy(Object src,  int  srcPos, Object dest, int destPos, int length);</p><h3 id="System-c"><a href="#System-c" class="headerlink" title="System.c"></a>System.c</h3><pre><code>// jdk/src/share/native/java/lang/System.c/* Only register the performance-critical methods */static JNINativeMethod methods[] = {    {&quot;currentTimeMillis&quot;, &quot;()J&quot;,              (void *)&amp;JVM_CurrentTimeMillis},    {&quot;nanoTime&quot;,          &quot;()J&quot;,              (void *)&amp;JVM_NanoTime},    {&quot;arraycopy&quot;,     &quot;(&quot; OBJ &quot;I&quot; OBJ &quot;II)V&quot;, (void *)&amp;JVM_ArrayCopy},};</code></pre><h3 id="jvm-cpp"><a href="#jvm-cpp" class="headerlink" title="jvm.cpp"></a>jvm.cpp</h3><pre><code>// src/share/vm/prims/jvm.cppJVM_ENTRY(void, JVM_ArrayCopy(JNIEnv *env, jclass ignored, jobject src, jint src_pos,                               jobject dst, jint dst_pos, jint length))  JVMWrapper(&quot;JVM_ArrayCopy&quot;);  // Check if we have null pointers  if (src == NULL || dst == NULL) {    THROW(vmSymbols::java_lang_NullPointerException());  }  arrayOop s = arrayOop(JNIHandles::resolve_non_null(src));  arrayOop d = arrayOop(JNIHandles::resolve_non_null(dst));  assert(s-&gt;is_oop(), &quot;JVM_ArrayCopy: src not an oop&quot;);  assert(d-&gt;is_oop(), &quot;JVM_ArrayCopy: dst not an oop&quot;);  // Do copy  Klass::cast(s-&gt;klass())-&gt;copy_array(s, src_pos, d, dst_pos, length, thread);JVM_END</code></pre>]]></content>
      
      <categories>
          
          <category> CS </category>
          
          <category> programing </category>
          
          <category> lan </category>
          
          <category> java </category>
          
          <category> jdk </category>
          
          <category> rt </category>
          
          <category> system </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>java系列 - Collection Framework</title>
      <link href="/pub/aca7a464/"/>
      <url>/pub/aca7a464/</url>
      <content type="html"><![CDATA[<h2 id="Hierarchy"><a href="#Hierarchy" class="headerlink" title="Hierarchy"></a>Hierarchy</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Collection</span><br><span class="line">├List</span><br><span class="line">│├ArrayList</span><br><span class="line">│├LinkedList</span><br><span class="line">│└Vector</span><br><span class="line">│　└Stack   <span class="comment"># 实现了栈的基本操作，由于涉及不够规范，目前极少使用。使用queue接口的相关实现可以完全取代它</span></span><br><span class="line">├PriorityQueue</span><br><span class="line">├Set</span><br><span class="line">│├EnumSet  </span><br><span class="line">│├HashSet</span><br><span class="line">│├LinkedHashSet</span><br><span class="line">│├TreeSet</span><br><span class="line">└ArrayDeque</span><br></pre></td></tr></table></figure><p><img title="java collection framework的架构" src="/images/raw/Java - diagram - java.util.Collection - skywang.jpg"></p><p><a href="http://www.cnblogs.com/skywang12345/p/3308498.html" target="_blank" rel="noopener">http://www.cnblogs.com/skywang12345/p/3308498.html</a></p><h2 id="compare"><a href="#compare" class="headerlink" title="compare"></a>compare</h2><div class="table-container"><table><thead><tr><th style="text-align:left">类</th><th style="text-align:right">同步(线程安全)</th><th style="text-align:right">随机访问</th><th style="text-align:right">快速增删</th><th style="text-align:right">存储空间</th><th style="text-align:right">复杂度：增删改查，containsValue</th><th style="text-align:center">其他语言</th></tr></thead><tbody><tr><td style="text-align:left">Array</td><td style="text-align:right">..</td><td style="text-align:right">Yes</td><td style="text-align:right">O()</td><td style="text-align:right">最小</td></tr><tr><td style="text-align:left">ArrayList</td><td style="text-align:right">..</td><td style="text-align:right">Yes</td><td style="text-align:right">O()</td><td style="text-align:right">小</td><td style="text-align:right">.</td></tr><tr><td style="text-align:left">LinkedList</td><td style="text-align:right">..</td><td style="text-align:right">No</td><td style="text-align:right">O()</td><td style="text-align:right">大</td><td style="text-align:right">.</td><td style="text-align:center">redis中的list采用双向链表实现</td></tr><tr><td style="text-align:left">Vector</td><td style="text-align:right">..</td></tr><tr><td style="text-align:left">Stack</td></tr><tr><td style="text-align:left">Queue</td></tr></tbody></table></div><p>class Stack<e> extends Vector<e><br>interface Queue<e> extends Collection<e></e></e></e></e></p><h2 id="实例场景"><a href="#实例场景" class="headerlink" title="实例场景"></a>实例场景</h2><p>排队：秒杀。FIFO，<br>消息队列：<br>频繁插入：采用linkedList</p>]]></content>
      
      <categories>
          
          <category> CS </category>
          
          <category> programing </category>
          
          <category> lan </category>
          
          <category> java </category>
          
          <category> jdk </category>
          
          <category> rt </category>
          
          <category> util </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>陈云霁报告 - 听课笔记</title>
      <link href="/pub/8f038bde/"/>
      <url>/pub/8f038bde/</url>
      <content type="html"><![CDATA[<p>陈云霁 14岁上大学 24岁博士毕业 科大少年班。青年千人。</p><p>AI+芯片</p><h1 id="深度学习处理器"><a href="#深度学习处理器" class="headerlink" title="深度学习处理器"></a>深度学习处理器</h1><h2 id="寒武纪做的是终端芯片？还是服务器芯片？"><a href="#寒武纪做的是终端芯片？还是服务器芯片？" class="headerlink" title="寒武纪做的是终端芯片？还是服务器芯片？"></a>寒武纪做的是终端芯片？还是服务器芯片？</h2><p>貌似</p><h2 id="智能计算和普通计算的区别是什么？"><a href="#智能计算和普通计算的区别是什么？" class="headerlink" title="智能计算和普通计算的区别是什么？"></a>智能计算和普通计算的区别是什么？</h2><h2 id="符号主义不再流行"><a href="#符号主义不再流行" class="headerlink" title="符号主义不再流行"></a>符号主义不再流行</h2><p>符号逻辑表示问题，求解逻辑表达式</p><h2 id="行为主义"><a href="#行为主义" class="headerlink" title="行为主义"></a>行为主义</h2><h2 id="联结主义-人工神经网络"><a href="#联结主义-人工神经网络" class="headerlink" title="联结主义 - 人工神经网络"></a>联结主义 - 人工神经网络</h2><p>把神经细胞抽象成数字，把突出抽象成数字。</p><ul><li>轴突 - 输出</li><li>树突 - 输入</li><li>交接地方叫 -</li></ul><p>人工神经网络一千亿个突触，人脑有百万亿突触。数量级的差距。</p><p>人工神经元与生物神经元细胞的区别。</p><p>逐层抽象处理</p><h1 id=""><a href="#" class="headerlink" title="#"></a>#</h1><p>现有硬件的缺陷，cpu gpu高能耗，低性能。alpha go 几千台。耗电几千瓦，李世乭只需要吃碗饭。</p><p>ai算法不错，落地困难，有硬件原因。cpu/gpu构建大规模神经网络，消耗很大。因此，</p><p>华为，阿里，曙光等手机都集成了寒武纪芯片。</p><ul><li>拍照时识别东西。自动调节光圈，</li><li>本地机器翻译，不需要联网。牛逼，模型多大啊？很消耗内存吧。本地实时翻译。</li></ul><h1 id="存在的问题"><a href="#存在的问题" class="headerlink" title="存在的问题"></a>存在的问题</h1><p>传统的ASIC(将给定算法硬件化)的思路无法解决深度学习处理的需求。(并不难，比如把C的程序编程virlog程序)</p><ul><li>有限规模的硬件 VS 任意规模的算法<ul><li>电路做神经元 突触。芯片流片后都是固定的，多少神经元。</li><li>寒武纪采用的思路是：硬件神经元的虚拟化。通过时分复用，把有限规模的硬件虚拟成任意大规模的硬件<ul><li>缺陷是，数据搬运</li></ul></li></ul></li><li>结构固定的硬件 VS 千变万化的算法  <ul><li>任务不同(下棋，语音，图像)，结构差异(卷积、全连接等)。每天有大量新算法 VS 芯片研发周期长</li><li>寒武纪解决方案：抽象各种网络的通用算子，找不同算法，最耗时的部分。<ul><li>主要运算：向量内积、向量距离、计数、非线性函数、排序</li><li>三个柱子：所有变量可概括为三类。</li><li>新算法来了，我们只需要对现有算子的组合</li></ul></li></ul></li><li>能耗受限的硬件 VS 精度优先的算法<ul><li>手机上不要超过1w，不然手机发烫，电池续航也不行</li><li>服务器不超过300w，散热问题</li><li>google大脑不考虑能耗，只考虑精度</li><li>做硬件和做算法的人就存在矛盾</li><li>寒武纪解决方案：稀疏神经网络处理器<ul><li>很好。跳过90%的神经元。问题是多小能够稀疏化，比如0.01导致用户体验下降，那么就调高点。通过运行时，动态调节稀疏度。</li></ul></li></ul></li></ul><p>华为mate10的深度学习处理器，比iphone10高效。牛逼呀</p><p>google大脑采用了1.6万个cpu核，如果提高1万倍，就可以融入手机。寒武纪目标提高性能1万倍。</p><h1 id="寒武纪"><a href="#寒武纪" class="headerlink" title="寒武纪"></a>寒武纪</h1><ul><li>是通用机器学习处理器，大部分机器学习算法都支持。 牛逼</li></ul><p>7nm，流片成本1亿人民币。没有百万量就不能回本。</p><ul><li>距离通用的gpu，tpu距离多远？往电脑上一插就能用的。</li></ul><p>应用面没gpu广，比如gpu能处理图片，寒武纪不擅长图片。</p><p>性能功耗比: 寒武纪 &gt; tpu &gt; gpu</p><p>tpu做cnn效率高，做lstm效率低。</p><p>云端PCA加速卡，曙光出了单机20卡，基于寒武纪。</p><p>寒武纪芯片是否支持caffe tf pytorch？支持</p><p>陈天霁：华为芯片最领先，展讯、比特大陆(挖矿芯片，异军突起)</p><p>#</p><ul><li><a href="https://c.m.163.com/news/l/175243.html" target="_blank" rel="noopener">北大公开课 - 陈云霁</a></li></ul>]]></content>
      
      <categories>
          
          <category> -芯片 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>【Demo】 hexo-tag-instagram</title>
      <link href="/pub/fc959554/"/>
      <url>/pub/fc959554/</url>
      <content type="html"><![CDATA[<h1 id="Instagram"><a href="#Instagram" class="headerlink" title="Instagram"></a>Instagram</h1><p><a href="https://github.com/tea3/hexo-tag-instagram" target="_blank" rel="noopener">hexo-tag-instagram</a> embeds Instagram photo and movie for Hexo blog.</p><h2 id="Simple-Usage"><a href="#Simple-Usage" class="headerlink" title="Simple Usage"></a>Simple Usage</h2><p>By default, width:100%, captioned:true</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#123;%</span> <span class="string">instagram</span> <span class="attr">https://www.instagram.com/p/Bg71nq4HuAU/</span> <span class="string">%&#125;</span></span><br></pre></td></tr></table></figure><div class="instagram-wrapper"><blockquote class="instagram-media" data-instgrm-captioned="" data-instgrm-version="7" style=" background:#FFF; border:0; border-radius:3px; box-shadow:0 0 1px 0 rgba(0,0,0,0.5),0 1px 10px 0 rgba(0,0,0,0.15); margin: 1px auto; padding:0; width:99.375%; width:-webkit-calc(50%- 2px); width:calc(50% - 2px);"><div style="padding:8px;"> <div style=" background:#F8F8F8; line-height:0; margin-top:40px; padding:50.0% 0; text-align:center; width:100%;"> <div style=" background:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACwAAAAsCAMAAAApWqozAAAABGdBTUEAALGPC/xhBQAAAAFzUkdCAK7OHOkAAAAMUExURczMzPf399fX1+bm5mzY9AMAAADiSURBVDjLvZXbEsMgCES5/P8/t9FuRVCRmU73JWlzosgSIIZURCjo/ad+EQJJB4Hv8BFt+IDpQoCx1wjOSBFhh2XssxEIYn3ulI/6MNReE07UIWJEv8UEOWDS88LY97kqyTliJKKtuYBbruAyVh5wOHiXmpi5we58Ek028czwyuQdLKPG1Bkb4NnM+VeAnfHqn1k4+GPT6uGQcvu2h2OVuIf/gWUFyy8OWEpdyZSa3aVCqpVoVvzZZ2VTnn2wU8qzVjDDetO90GSy9mVLqtgYSy231MxrY6I2gGqjrTY0L8fxCxfCBbhWrsYYAAAAAElFTkSuQmCC); display:block; height:44px; margin:0 auto -44px; position:relative; top:-22px; width:44px;"></div></div><p style=" color:#c9c8cd; font-family:Arial,sans-serif; font-size:14px; line-height:17px; margin-bottom:0; margin-top:8px; overflow:hidden; padding:8px 0 7px; text-align:center; text-overflow:ellipsis; white-space:nowrap;"><a href="https://www.instagram.com/p/Bg71nq4HuAU/" style=" color:#c9c8cd; font-family:Arial,sans-serif; font-size:14px; font-style:normal; font-weight:normal; line-height:17px; text-decoration:none;" target="_blank"></a></p></div></blockquote></div><script async defer src="//platform.instagram.com/en_US/embeds.js"></script><p>It equals to<br><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#123;%</span> <span class="string">instagram</span> <span class="attr">url:https://www.instagram.com/p/Bg71nq4HuAU/</span> <span class="string">%&#125;</span></span><br><span class="line"><span class="comment"># or</span></span><br><span class="line"><span class="string">&#123;%</span> <span class="string">instagram</span> <span class="string">Bg71nq4HuAU</span> <span class="string">%&#125;</span></span><br><span class="line"><span class="comment"># or</span></span><br><span class="line"><span class="string">&#123;%</span> <span class="string">instagram</span> <span class="attr">id:Bg71nq4HuAU</span> <span class="string">%&#125;</span></span><br></pre></td></tr></table></figure></p><h2 id="Customization"><a href="#Customization" class="headerlink" title="Customization"></a>Customization</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% instagram false Bg71nq4HuAU 60% %&#125;</span><br></pre></td></tr></table></figure><div class="instagram-wrapper"><blockquote class="instagram-media" data-instgrm-version="7" style=" background:#FFF; border:0; border-radius:3px; box-shadow:0 0 1px 0 rgba(0,0,0,0.5),0 1px 10px 0 rgba(0,0,0,0.15); margin: 1px auto; padding:0; width:99.375%; width:-webkit-calc(60%- 2px); width:calc(60% - 2px);"><div style="padding:8px;"> <div style=" background:#F8F8F8; line-height:0; margin-top:40px; padding:50.0% 0; text-align:center; width:100%;"> <div style=" background:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACwAAAAsCAMAAAApWqozAAAABGdBTUEAALGPC/xhBQAAAAFzUkdCAK7OHOkAAAAMUExURczMzPf399fX1+bm5mzY9AMAAADiSURBVDjLvZXbEsMgCES5/P8/t9FuRVCRmU73JWlzosgSIIZURCjo/ad+EQJJB4Hv8BFt+IDpQoCx1wjOSBFhh2XssxEIYn3ulI/6MNReE07UIWJEv8UEOWDS88LY97kqyTliJKKtuYBbruAyVh5wOHiXmpi5we58Ek028czwyuQdLKPG1Bkb4NnM+VeAnfHqn1k4+GPT6uGQcvu2h2OVuIf/gWUFyy8OWEpdyZSa3aVCqpVoVvzZZ2VTnn2wU8qzVjDDetO90GSy9mVLqtgYSy231MxrY6I2gGqjrTY0L8fxCxfCBbhWrsYYAAAAAElFTkSuQmCC); display:block; height:44px; margin:0 auto -44px; position:relative; top:-22px; width:44px;"></div></div><p style=" color:#c9c8cd; font-family:Arial,sans-serif; font-size:14px; line-height:17px; margin-bottom:0; margin-top:8px; overflow:hidden; padding:8px 0 7px; text-align:center; text-overflow:ellipsis; white-space:nowrap;"><a href="https://www.instagram.com/p/Bg71nq4HuAU/" style=" color:#c9c8cd; font-family:Arial,sans-serif; font-size:14px; font-style:normal; font-weight:normal; line-height:17px; text-decoration:none;" target="_blank"></a></p></div></blockquote></div><script async defer src="//platform.instagram.com/en_US/embeds.js"></script><p>It equals to</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% instagram captioned:false id:Bg71nq4HuAU width:60% %&#125;</span><br></pre></td></tr></table></figure><h2 id="Customization-Globally"><a href="#Customization-Globally" class="headerlink" title="Customization Globally"></a>Customization Globally</h2><p>You can also customize for all posts.</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># captioned: false. Hide the captions of all instagrams.</span></span><br><span class="line"><span class="comment"># width: set the width of all instagrams</span></span><br><span class="line"><span class="attr">tagInstagram:</span></span><br><span class="line"><span class="attr">  captioned:</span> <span class="literal">false</span></span><br><span class="line"><span class="attr">  width:</span> <span class="number">50</span><span class="string">%</span></span><br></pre></td></tr></table></figure><h1 id="Related-Github-Issue"><a href="#Related-Github-Issue" class="headerlink" title="Related Github Issue"></a>Related Github Issue</h1><ul><li><a href="https://github.com/tea3/hexo-tag-instagram/issues/3" target="_blank" rel="noopener">#3 Image Resize</a></li><li><a href="https://github.com/tea3/hexo-tag-instagram/pull/4" target="_blank" rel="noopener">#4 resize image in markdown</a></li></ul>]]></content>
      
      <categories>
          
          <category> demo </category>
          
          <category> hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
            <tag> plugin </tag>
            
            <tag> instagram </tag>
            
            <tag> hexo-tag-instagram </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>【Demo】 hexo-tag-chat</title>
      <link href="/pub/a03f82c/"/>
      <url>/pub/a03f82c/</url>
      <content type="html"><![CDATA[<link rel="stylesheet" href="/css/tag-chat.css"><h1 id="传统方法"><a href="#传统方法" class="headerlink" title="传统方法"></a>传统方法</h1><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">Q:</span> <span class="string">"文字狱是清朝哪位皇帝兴起的"</span><span class="string">;</span></span><br><span class="line"><span class="string">答:</span> <span class="string">"康熙"</span></span><br><span class="line"></span><br><span class="line"><span class="attr">Q:</span> <span class="string">"嵇康是哪一时期的琴家"</span><span class="string">;</span></span><br><span class="line"><span class="string">答:</span> <span class="string">"三国"</span></span><br><span class="line"></span><br><span class="line"><span class="attr">Q:</span> <span class="string">"唐代的乐队，使用的主要乐器是"</span><span class="string">;</span></span><br><span class="line"><span class="string">答:</span> <span class="string">"琵琶"</span></span><br><span class="line"></span><br><span class="line"><span class="attr">Q:</span> <span class="string">"拼音中四声起于"</span><span class="string">;</span></span><br><span class="line"><span class="string">答:</span> <span class="string">"元"</span></span><br><span class="line"></span><br><span class="line"><span class="attr">Q:</span> <span class="string">"元杂剧的楔子即"</span><span class="string">;</span></span><br><span class="line"><span class="string">答:</span> <span class="string">"序幕"</span></span><br></pre></td></tr></table></figure><h1 id="利用-hexo-tag-chat"><a href="#利用-hexo-tag-chat" class="headerlink" title="利用 hexo-tag-chat"></a>利用 hexo-tag-chat</h1><div class="chatContent" id="chatContent"><div class="clearfix">  <div class="message others"> <div class="avatar" data-author-id="lj"> <img src="http://c1.mifile.cn/f/i/hd/2016051101/a-lj.png" alt="雷军"> </div> <div class="content"> <div class="bubble  bubble_default left"> <div class="bubble_cont"> <div class="plain"> <pre>文字狱是清朝哪位皇帝兴起的;</pre> </div> </div> </div>  </div> </div>  </div><div class="clearfix">  <div class="message others"> <div class="avatar" data-author-id="lj"> <img src="http://c1.mifile.cn/f/i/hd/2016051101/a-lj.png" alt="雷军"> </div> <div class="content"> <div class="bubble  bubble_default left"> <div class="bubble_cont"> <div class="plain"> <pre>康熙</pre> </div> </div> </div>  </div> </div>  </div><div class="clearfix">  <div class="message others"> <div class="avatar" data-author-id="lj"> <img src="http://c1.mifile.cn/f/i/hd/2016051101/a-lj.png" alt="雷军"> </div> <div class="content"> <div class="bubble  bubble_default left"> <div class="bubble_cont"> <div class="plain"> <pre>嵇康是哪一时期的琴家;</pre> </div> </div> </div>  </div> </div>  </div><div class="clearfix">  <div class="message others"> <div class="avatar" data-author-id="lj"> <img src="http://c1.mifile.cn/f/i/hd/2016051101/a-lj.png" alt="雷军"> </div> <div class="content"> <div class="bubble  bubble_default left"> <div class="bubble_cont"> <div class="plain"> <pre>三国</pre> </div> </div> </div>  </div> </div>  </div><div class="clearfix">  <div class="message others"> <div class="avatar" data-author-id="lj"> <img src="http://c1.mifile.cn/f/i/hd/2016051101/a-lj.png" alt="雷军"> </div> <div class="content"> <div class="bubble  bubble_default left"> <div class="bubble_cont"> <div class="plain"> <pre>唐代的乐队，使用的主要乐器是;</pre> </div> </div> </div>  </div> </div>  </div><div class="clearfix">  <div class="message others"> <div class="avatar" data-author-id="lj"> <img src="http://c1.mifile.cn/f/i/hd/2016051101/a-lj.png" alt="雷军"> </div> <div class="content"> <div class="bubble  bubble_default left"> <div class="bubble_cont"> <div class="plain"> <pre>琵琶</pre> </div> </div> </div>  </div> </div>  </div><div class="clearfix">  <div class="message others"> <div class="avatar" data-author-id="lj"> <img src="http://c1.mifile.cn/f/i/hd/2016051101/a-lj.png" alt="雷军"> </div> <div class="content"> <div class="bubble  bubble_default left"> <div class="bubble_cont"> <div class="plain"> <pre>拼音中四声起于;</pre> </div> </div> </div>  </div> </div>  </div><div class="clearfix">  <div class="message others"> <div class="avatar" data-author-id="lj"> <img src="http://c1.mifile.cn/f/i/hd/2016051101/a-lj.png" alt="雷军"> </div> <div class="content"> <div class="bubble  bubble_default left"> <div class="bubble_cont"> <div class="plain"> <pre>元</pre> </div> </div> </div>  </div> </div>  </div><div class="clearfix">  <div class="message others"> <div class="avatar" data-author-id="lj"> <img src="http://c1.mifile.cn/f/i/hd/2016051101/a-lj.png" alt="雷军"> </div> <div class="content"> <div class="bubble  bubble_default left"> <div class="bubble_cont"> <div class="plain"> <pre>元杂剧的楔子即;</pre> </div> </div> </div>  </div> </div>  </div><div class="clearfix">  <div class="message others"> <div class="avatar" data-author-id="lj"> <img src="http://c1.mifile.cn/f/i/hd/2016051101/a-lj.png" alt="雷军"> </div> <div class="content"> <div class="bubble  bubble_default left"> <div class="bubble_cont"> <div class="plain"> <pre>序幕</pre> </div> </div> </div>  </div> </div>  </div></div>]]></content>
      
      <categories>
          
          <category> demo </category>
          
          <category> hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
            <tag> plugin </tag>
            
            <tag> hexo-tag-chat </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>贪多嚼不烂</title>
      <link href="/pub/48d1b830/"/>
      <url>/pub/48d1b830/</url>
      <content type="html"><![CDATA[<!--两年之内 - 目标gogole--><h2 id="当月重点"><a href="#当月重点" class="headerlink" title="当月重点"></a>当月重点</h2><ul><li>[ ] 数据结构 &amp; 算法</li><li>[ ] 阅读至少10篇paper</li><li>[ ] 贡献tf、pytorch代码，bug或tutorial</li><li>[ ] 自动求导</li><li>[ ] cuda基础</li></ul><h2 id="推迟-或-半完成状态"><a href="#推迟-或-半完成状态" class="headerlink" title="推迟 或 半完成状态"></a>推迟 或 半完成状态</h2><ul><li>[x] 检索</li><li>[ ] 专利</li></ul><h2 id="5月重点"><a href="#5月重点" class="headerlink" title="5月重点"></a>5月重点</h2><h2 id="tips"><a href="#tips" class="headerlink" title="tips"></a>tips</h2><p>少刷知乎，少刷博客。<br>多看paper，多看书</p>]]></content>
      
      
    </entry>
    
    <entry>
      <title></title>
      <link href="/pub/0/"/>
      <url>/pub/0/</url>
      <content type="html"><![CDATA[<h1 id="Demo-No-Title"><a href="#Demo-No-Title" class="headerlink" title="Demo: No-Title"></a>Demo: No-Title</h1><p>This is a post, which has no title.</p><p>Typically, we can locate this file by URL with default hexo settings.</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">permalink:</span> <span class="string">:year/:month/:day/:title/</span></span><br></pre></td></tr></table></figure><p>e.g. URL is as follows:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://blog.eson.org/2000/01/01/demo/hexo/no-title/</span><br></pre></td></tr></table></figure></p><p>It shows the full path of this post <code>_post/demo/hexo/no-title.md</code>.</p><h1 id="Trouble-in-hexo-abbrlink"><a href="#Trouble-in-hexo-abbrlink" class="headerlink" title="Trouble in hexo-abbrlink"></a>Trouble in hexo-abbrlink</h1><p><code>hexo-abbrlink</code> is a great plugin for hexo users. I setup <code>hexo-abbrlink</code> in my post.</p><p>In this case, url becomes<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://blog.eson.org/pub/0/</span><br></pre></td></tr></table></figure></p><p>God, I want to locate this post and add a title. But, how can I locate my error-post?</p><h1 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h1><h2 id="with-hexo-abbrlink-log"><a href="#with-hexo-abbrlink-log" class="headerlink" title="with hexo-abbrlink log"></a>with hexo-abbrlink log</h2><p>It would be better if <code>hexo-abbrlink</code> log the post with no title. Give me a warning.</p><h2 id="with-hexo-auto-category"><a href="#with-hexo-auto-category" class="headerlink" title="with hexo-auto-category"></a>with hexo-auto-category</h2><p>In this post, you may notice that the category is <code>demo</code>, <code>hexo</code>.<br>Actually, the full path of this post is <code>_post/demo/hexo/no-title.md</code>. It really helps.</p><p><code>hexo-auto-category</code> binds folder structure to category. It is also a good way to locate your post.</p><h1 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a>Summary</h1><p><code>hexo-abbrlink</code> and <code>hexo-auto-category</code></p>]]></content>
      
      <categories>
          
          <category> demo </category>
          
          <category> hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
            <tag> plugin </tag>
            
            <tag> hexo-abbrlink </tag>
            
        </tags>
      
    </entry>
    
  
  
</search>
